{
  "hash": "46bbf0f34f2d25af171c809ce27cc8b0",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n# Memory and Allocators in Zig\n\n## Introduction\n\nIn this chapter, we will talk about memory. How does Zig controls memory? What\ncommom tools are used? Are there any important aspect that makes memory\ndifferent/special in Zig? You will find the answers here.\n\nEvery computer needs memory. Is by having memory that computers can temporarily store\nthe values/results of your calculations. Without memory, programming languages would never have\nconcepts such as \"variables\", or \"objects\", to store the values that you generate.\n\n\n## Memory spaces\n\nEvery variable that you create in your Zig source code needs to be stored somewhere,\nin your computer's memory. Depending on where and how you define your variable, Zig\nwill use a different \"memory space\", or a different\ntype of memory to store this variable.\n\nEach type of memory normally serves for different purposes.\nIn Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:\n\n- Global data register (or the \"global data section\");\n- Stack;\n- Heap;\n\n\n### Compile-time known versus runtime known\n\nOne strategy that Zig uses to decide where it will store each variable that you declare, is by looking\nat the value of this particular variable. More specifically, by investigating if this value is\nknown at \"compile-time\" or at \"runtime\".\n\nWhen you write a program in Zig, some values that you write in your program are *known\nat compile time*. Meaning that, when you compile your Zig source code, during the compilation process,\nthe `zig` compiler can figure it out what is the exact value of a particular variable (or object)\nthat exists in your source code.\n\nFor example, in the source code below, we have two constant variables (`name` and `array`) declared.\nBecause the values of these particular variables are written down, in the source code itself (`\"Pedro\"`\nand the number sequence from 1 to 4), the `zig` compiler can easily discover the values of these constant\nvariables (`name` and `array`) during the compilation process.\n\n\nThis is what \"known at compile time\" means. It refers to any variable that you have in your Zig source code\nwhose value can be identified at compile time.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst name = \"Pedro\";\nconst array = [_]u8{1, 2, 3, 4};\n_ = name; _ = array;\n\nfn input_length(input: []const u8) usize {\n    return input.len;\n}\n```\n:::\n\n\nThe other side of the spectrum are variables whose values are not known at compile time.\nFunction arguments are a classic example of this. Because the value of each function\nargument depends on the value that you assign to this particular argument,\nwhen you call the function.\n\nFor example, the function `input_length()` contains an argument named `input`, which is an array of `u8` integers (`[]const u8`).\nIs impossible to know at compile time the value of this particular argument. We know that it will be an array of `u8` integers.\nBut we can't know which exact array of `u8` integers this argument will store, before we execute this function.\nIt is only *known at runtime*, which is the period of time when you program is executed.\n\nSo depending on which input your apply this `input_length()` function over, the `input` argument\nwill probably have a different value in each case.\nBecause of this intrinsic characteristic of any function, the value of the argument `input` is not \"compile-time known\".\nIt is known only at runtime.\n\n\n\n### Global data register\n\nThe global data register is a specific section of the executable of your Zig program, that is responsible\nfor storing any value that is known at compile time.\n\nEvery constant variable whose value is known at compile time that you declare in your source code,\nis stored in the global data register. Also, every literal value that you write in your source code,\nsuch as the string `\"this is a string\"`, or the integer `10`, or a boolean value such as `true`,\nis also stored in the global data register.\n\nHonestly, you don't need to care much about this memory space. Because you can't control it,\nyou can't deliberately access it or use it for your own purposes.\nAlso, this memory space does not affect the logic of your program.\nIt simply exists in your program.\n\n\n### Stack vs Heap\n\nIf you are familiar with system's programming, or just low-level programming in general, you\nprobably have heard of the \"duel\" between Stack vs Heap. These are two different types of memory,\nor different memory spaces, which are both available in Zig.\n\nThese two types of memory don't actually duel with\neach other. This is a commom mistake that beginners have, when seeing \"x vs y\" styles of\ntabloid headlines. These two types of memory are actually complementary to each other.\nSo, in almost every Zig program that you might ever write, you will likely use a combination of both.\nI will describe each memory space in detail over the next sections. But for now, I just want to\nstablish the main difference between these two types of memory.\n\nIn essence, the stack memory is normally used to store values whose length is fixed and known\nat compile time. In contrast, the heap memory is a much more *dinamic* type of memory space, meaning that, it is\nused to store values whose length might grow during the execution (runtime) of your program [@jenny2022].\nLengths that grow during runtime are intrinsically \"runtime known\" type of values.\nIn other words, if you have a variable whose length might grow during runtime, then, the length\nof this variable becomes not known at compile time. These types of variables are usually stored\nin the heap memory space.\n\n\n\n### Stack {#sec-stack}\n\nThe stack is a type of memory that uses the power of the *stack data structure*, hence the name. \nA \"stack\" is a type of *data structure* that uses a \"last in, first out\" (LIFO) mechanism to store the values\nyou give it to. I imagine you are familiar with this data structure.\nBut, if you are not, the [Wikipedia page](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))[^wiki-stack]\n, or, the [Geeks For Geeks page](https://www.geeksforgeeks.org/stack-data-structure/)[^geek-stack] are both\nexcellent and easy resources to fully understand how this data structure works.\n\n[^wiki-stack]: <https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>\n[^geek-stack]: <https://www.geeksforgeeks.org/stack-data-structure/>\n\nSo, the stack memory space is a type of memory that stores values using a stack data structure.\nIt adds and removes values from the memory by following a \"last in, first out\" (LIFO) principle.\n\nIn general, every function call that you make in Zig will always allocate some space in the stack [@jenny2022; @zigdocs].\nThe value of each function argument given to the function in this function call is stored in this\nstack space. Also, every local variable that you declare inside the function scope are\nnormally stored in this same stack space.\n\nLooking at the example below, the variable `result` is a local variable declared inside the scope of the `add()`\nfunction. Because of that, this variable is stored inside the stack space reserved for the `add()` function.\n\nAlso, the `r` variable (which is declared outside of the `add()` function scope) is also stored in the stack,\nspecially because it does not contain a value that is *compile-time known*.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) u8 {\n    const result = x + y;\n    return result;\n}\n```\n:::\n\n\nSo, any variable that you declare inside the scope of a function is always stored inside\nthe space that was reserved for that particular function in the stack memory. This\nalso counts for any variable declared inside the scope of your `main()` function. As you would expect, in this case, they\nare stored inside the stack space reserved for the `main()` function.\n\nOne very important detail about the stack memory is that **it frees itself automatically**.\nThis is very important, remember that. When variables are stored in the stack memory,\nyou don't have the work (or the responsibility) of freeing/destroying these objects.\nBecause they will be automatically destroyed once the stack space is freed at the end of the function scope.\n\n::: {.callout-important}\nVariables that are stored in the stack are automatically\nfreed/destroyed at the end of the function scope.\n:::\n\n\nAs I sad earlier, every time you make a function call in Zig, an amount of space in the stack memory is\nreserved for this particular function call. But once the function call returns (or ends, if you prefer to call it this way)\nthe space that was reserved in the stack is destroyed, and all of the variables that were in this space goes away with it.\nThis mechanism exists because this space, and the variables within it, are not necessary anymore,\nsince the function \"finished it's business\". Using the `add()` function that we exposed above as an example, it means that the variable `result` is automatically\ndestroyed once the function returns.\n\nOne important consequence of this mechanism is that, once the function returns, you can no longer access any memory\naddress that was inside the space in the stack reserved for this particular function. Because this space was\ndestroyed. This means that you can not make a function **return a pointer to one of it's local variables**.\n\nThink about that for a second. If all local variables are destroyed at the end of the function scope, why\nwould you even consider returning a pointer to one of these variables? This pointer is at best,\ninvalid, or, more likely, \"undefined\". So, yes, you should never write a function that returns a pointer to one\nof it's local variables.\n\nSo, using again the `add()` function as an example, if you rewrite this function so that it\nreturns a pointer to the local variable `result`, the `zig` compiler will actually compile\nyou program, with no warnings or erros. At first glance, it looks that this is good code\nthat works as expected. But this is a lie!\n\nIf you try to take a look at the value inside of the `r` variable,\nor, if you try to use this `r` variable in another expression\nor function call, then, you would have undefined behaviour, and major\nbugs in your program [@zigdocs, see \"Lifetime and Ownership\"[^life] and \"Undefined Behaviour\"[^undef] sections].\n\n[^life]: <https://ziglang.org/documentation/master/#Lifetime-and-Ownership>\n[^undef]: <https://ziglang.org/documentation/master/#Undefined-Behavior>\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\n// This code compiles succesfully. But it has\n// undefined behaviour. Never do this!!!\n\n// The `r` variable is undefined!\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) *const u8 {\n    const result = x + y;\n    return &result;\n}\n```\n:::\n\n\nThis \"invalid pointer to stack variable\" problem is very known across many programming language communities.\nIf you try to do the same thing, for example, in a C or C++ program (i.e. returning an address to\na local variable stored in the stack), you would also get undefined behaviour\nin the program.\n\n::: {.callout-important}\nIf a local variable in your function is stored in the stack, you should never\nreturn a pointer to this local variable from the function. Because\nthis pointer will always become undefined after the function returns, since the stack space of the function\nis destroyed at the end of it's scope.\n:::\n\nBut what if you really need to use this local variable in some way after your function returns?\nHow can you do this? The answer is: \"in the same you would do if this was a C or C++ program. By returning\nan address to a variable stored in the heap\". The heap memory have a much more flexible lifecycle,\nand allows you to get a valid pointer to a local variable of a function that already returned\nfrom it's scope.\n\n\n### Heap {#sec-heap}\n\nWhile the stack accepts only variables whose length is known at compile-time, the heap is much more dinamic\n(and flexible) type of memory. It is the perfect type of memory to use\non variables whose size/length might grow during the execution of your program.\nVirtually any application that behaves as a server is a classic use case of the heap.\nA HTTP server, a SSH server, a DNS server, a LSP server, ... any type of server.\n\nIn summary, a server is a type of application that runs for long periods of time,\nand that serves (or \"deals with\") any incoming request that reaches this particular server.\nThe heap is a good choice for this type of system, mainly because the server does not know upfront\nhow many requests it will receive from users, while it is active. It could be one single request,\nor, 5 thousand requests, or, it could also be zero requests.\nThe server needs to have the ability to allocate and manage it's memory according to how many requests it receives.\n\nAnother key difference between the stack and the heap, is that the heap is a type\nof memory that you, the programmer, have complete control over. This makes the heap a\nmore flexible type of memory, but it also makes harder to work with it. Because you,\nthe programmer, is responsible for managing everything related to it. Including where the memory is allocated,\nhow much memory is allocated, and where this memory is freed.\n\n> Unlike stack memory, heap memory is allocated explicitly by programmers and it wonâ€™t be deallocated until it is explicitly freed [@jenny2022].\n\nTo store a variable in the heap, you, the programmer, needs to explicitly tells Zig to do so,\nby using an allocator to allocate some space in the heap. \n\nMost allocators in Zig allocate memory on the heap. But some exceptions to this rule are\n`ArenaAllocator()` and `FixedBufferAllocator()`. The `ArenaAllocator()` is a special\ntype of allocator that works in conjunction with a second type of allocator.\nOn the other side, the `FixedBufferAllocator()` is an allocator that works based on\nbuffer object created on the stack. This means that the `FixedBufferAllocator()` makes\nallocations only on the stack.\n\nAt @sec-allocators, I will present how you can use allocators to allocate memory\nin Zig.\n\n\n### Summary\n\nAfter discussing all of these boring details, we can quickly recap what we learned.\nIn summary, the Zig compiler will use the following rules to decide where each\nvariable you declare is stored:\n\n1. every literal value (such as `\"this is string\"`, `10`, or `true`) is stored in the global data section.\n\n1. every constant variable (`const`) whose value **is known at compile-time** is also stored in the global data section.\n\n1. every variable (constant or not) whose value **is not known at compile time** is stored in the stack of the current scope.\n\n1. if a variable is created with the method `alloc()` or `create()` of an allocator object, this variable is stored in the memory space used by this particular allocator object. Most of allocators available in Zig use the heap memory, so, this variable is likely stored in the heap (`FixedBufferAllocator()` is an exception to that).\n\n\n\n## Allocators {#sec-allocators}\n\nOne key aspect about Zig, is that there are \"no hidden-memory allocations\" in Zig.\nWhat that really means, is that \"no allocations happen behind your back in the standard library\" [@zigguide].\n\nThis is a known problem specially in C++. Because in C++, there are some operators that allocates\nmemory behind the scene, and there is no way for you to known that, until you actually read the\nsource code of these operators, and find the memory allocation calls.\nMany programmers find this behaviour annoying and hard to keep track of.\n\nBut, in Zig, if a function, an operator, or anything from the standard library\nneeds to allocate some memory during it's execution, then, this function/operator needs to receive (as input) an allocator\nprovided by the user, to actually be able to allocate the memory it needs.\nThis creates a clear distinction between functions that \"do not\" from those that \"actually do\"\nallocate memory.\n\nSo, if a function, or operator, have an allocator object as one of it's inputs/arguments, then, you know for\nsure that this function/operator will allocate some memory during it's execution. You get a lot of control\nover where and how much memory this function can allocate. Because it is you,\nthe user/programmer, that provides the allocator for the function to use. This gives\nyou total control over memory management in Zig.\n\n### What are allocators?\n\nAllocators in Zig are objects that you can use to allocate memory for your program.\nThey work similar to the memory allocating functions in C, like `malloc()` and `calloc()`.\nSo, if you need to use more memory than you initially have, during the execution of your program, you can simply ask\nfor more memory using an allocator.\n\n\n\nZig offers different types of allocators, and they are usually available through the `std.heap` module of\nthe standard library. So, just import the Zig standard library into your Zig module (with `@import(\"std\")`), and you can start\nusing these allocators in your code.\n\n\n### Why you (or someone) need an allocator?\n\nAs we described at @sec-stack, everytime you make a function call in Zig,\na space in the stack is reserved for this function call. But the stack\nhave a key limitation which is: every variable stored in the stack have a\nknown fixed length.\n\nBut in reality, there are two very commom instances where this \"fixed length limitation\" of the stack is a deal braker:\n\n1. the variables that you create inside your function might grow in size during the execution of the function.\n\n2. sometimes, it is impossible to know upfront how many inputs you will receive during the function call, or how big this input will be.\n\nThese are two commom situations where the stack is not good for.\nThat is why you need a different memory management strategy to\nstore these variables inside your function. You need to use\na memory type that can grow together with your variables.\nThe heap fit this description.\n\nThis is commonly known as dynamic memory management. As the variables you create grow in size\nduring the execution of your program, you grow the amount of memory\nyou have by allocating more memory in the heap to store these variables. \nIn Zig, you allocate more memory in the heap by using an allocator object.\n\n\n### The different types of allocators\n\n\nAt the moment of the writing of this book, in Zig, we have 6 different\nallocators available in the standard library:\n\n- `GeneralPurposeAllocator()`.\n- `page_allocator()`.\n- `FixedBufferAllocator()` and `ThreadSafeFixedBufferAllocator()`.\n- `ArenaAllocator()`.\n- `c_allocator()` (requires you to link to libc).\n\n\n\n### The `alloc()` and `free()` methods\n\nLook at the example below. We are accessing the `stdin`, which is\nthe standard input channel to receive an input from the\nuser. Then, we use the method `alloc()` of an allocator to allocate an\narray capable of storing 50 `u8` values.\n\nNotice that this `alloc()` method receives two inputs. The first one, is a type.\nThis defines what type of values the allocated array will store. In the example\nbelow, we are allocating an array of unsigned 8-bit integers (`u8`). But\nyou can create an array to store any type of value you want. Next, we\ndefine the size of the allocated array, by specifying how much elements\nthis array will contain. In the case below, we are allocating an array of 50 elements.\n\nSo, in essence, the expression `var input: [50]u8 = undefined` would create\nan array for 50 `u8` values in the stack of the current scope. But, you\ncan allocate the same array in heap by using the expression `var input = try allocator.alloc(u8, 50)`.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdin = std.io.getStdIn();\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var input = try allocator.alloc(u8, 50);\n    defer allocator.free(input);\n    for (0..input.len) |i| {\n        input[i] = 0; // initialize all fields to zero.\n    }\n    // read user input\n    const input_reader = stdin.reader();\n    _ = try input_reader.readUntilDelimiterOrEof(\n        input,\n        '\\n'\n    );\n    std.debug.print(\"{s}\\n\", .{input});\n}\n```\n:::\n\n\nAlso, notice that in this example, we use the keyword `defer` to run small\npiece of code at the end of the current scope, which is the expression `allocator.free(input)`.\nWhen you execute this expression, the allocator will free the memory that it allocated\nfor the `input` variable.\n\nWe have talked about this at @sec-heap. You should always explicitly free any memory that you allocate\nusing an allocator. You do that by using the `free()` method of the same allocator object you\nused to allocate this memory. The `defer` keyword helps you to make sure that\nthis free operation is executed at the end of the current scope.\n\n\n### The `create()` and `destroy()` methods\n\n",
    "supporting": [
      "01-memory_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
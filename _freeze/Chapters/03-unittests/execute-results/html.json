{
  "hash": "555cc5c67a26414e89a3511dba578c1d",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n# Unit tests {#sec-unittests}\n\nIn this chapter, I want to dive in on how unit tests are done in\nZig. We are going to talk about what is the testing workflow in Zig, and\nalso, about the `test` command from the `zig` compiler.\n\n\n## Introducing the `test` block\n\nIn Zig, unit tests are written inside a `test` declaration, or, how I prefer to call it, inside a `test` block.\nEvery `test` block is written by using the keyword `test`.\nYou can optionally use a string literal to write a label, which is responsible for identifying\nthe specific group of unit tests that you are writing inside this specific `test` block.\n\nIn the example below, we are testing if the sum of two objects (`a` and `b`)\nis equal to 4. The `expect()` function from the Zig Standard Library\nis a function that receives a logical test as input. If this logical test\nresults in `true`, then, the test passes. But if it results\nin `false`, then, the test fails.\n\nYou can write any Zig code you want inside a `test` block.\nPart of this code might be some necessary commands to setup your testing\nenvironment, or just initializing some objects that you need to use\nin your unit tests.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\ntest \"testing simple sum\" {\n    const a: u8 = 2;\n    const b: u8 = 2;\n    try expect((a + b) == 4);\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1/1 file36921505bc29.test.testing simple sum...OKA\n  All 1 tests passed.\n```\n\n\n:::\n:::\n\n\nYou can have multiple `test` blocks written on the same Zig module.\nAlso, you can mix `test` blocks with your source code, with no problems\nor consequences. If you mix `test` blocks with your normal source code,\nwhen you execute the `build`, `build-exe`, `build-obj` or `build-lib` commands from the\n`zig` compiler that we exposed in @sec-compile-code, these `test` blocks are automatically\nignored by the compiler.\n\nIn other words, the `zig` compiler builds and execute your unit tests only\nwhen you ask it to. By default, the compiler always ignore `test`\nblocks written in your Zig modules. The compiler normally checks only if\nthere are any syntax errors in these `test` blocks.\n\nIf you take a look at the source code for most of the files present in the\nZig Standard Library[^zig-std-lib], you can see that the `test` blocks\nare written together with the normal source code of the library.\nYou can see this for example, at the [`array_list` module](https://github.com/ziglang/zig/blob/master/lib/std/array_list.zig)[^zig-array].\nSo, the standard that the Zig developers decided to adopt\nis to keep their unit tests together with the source code\nof the functionality that they are testing.\n\nEach programmer might have a different opinion on this.\nSome of them might prefer to keep unit tests separate from the actual\nsource code of their application. If that is your case, you can\nsimply create a separate `tests` folder in your project, and\nstart writing Zig modules that contains only unit tests (as you would normally do\non a Python project with `pytest`, for example), and everything will work fine.\nIt boils down to which is your preference here.\n\n[^zig-std-lib]: <https://github.com/ziglang/zig/tree/master/lib/std>\n[^zig-array]: <https://github.com/ziglang/zig/blob/master/lib/std/array_list.zig>\n\n\n## How to run your tests\n\nIf the `zig` compiler ignores any `test` block by default, how can\nyou compile and run your unit tests? The answer is the `test` command from\nthe `zig` compiler. By running the `zig test` command, the compiler will\nfind every instance of a `test` block in your Zig modules, and, it will\ncompile and run the unit tests that you wrote.\n\n\n```bash\nzig test simple_sum.zig\n```\n\n```\n1/1 simple_sum.test.testing simple sum... OK\nAll 1 tests passed.\n```\n\n\n## Testing memory allocations\n\nOne of the advantages of Zig is that it offers great tools\nthat help us, programmers, to avoid (but also detect) memory problems, such as\nmemory leaks and double-frees. The `defer` keyword\nis especially helpful in this regard.\n\nWhen developing your source code, you, the programmer, are responsible for making\nsure that your code does not produce such problems. However,\nyou can also use a special type of an allocator object in Zig\nthat is capable of automatically detecting such problems for you.\nThis is the `std.testing.allocator` object.\nThis allocator object offers some basic memory safety detection\nfeatures, which are capable of detecting memory leaks.\n\nAs we described in @sec-heap, to allocate memory on the heap, you need\nto use an allocator object, and your functions that use these objects to allocate memory\non the heap, should receive an allocator object as one of its inputs.\nEvery memory on the heap that you allocate using these allocator objects,\nmust also be freed using this same allocator object.\n\nSo, if you want to test the memory allocations performed by your functions,\nand make sure that you don't have problems in these allocations, you can simply\nwrite unit tests for these functions, where you provide the\n`std.testing.allocator` object as input to these functions.\n\nLook at the example below, where I'm defining a function that clearly causes\na memory leak. Because we allocate memory, but, at the same time,\nwe do not free this allocated memory at any point. So, when the function\nreturns, we lose the reference to the `buffer` object, which contains\nthe allocated memory, and, as a result, we can no longer free this memory.\n\nNotice that, inside a `test` block I execute this function with\nthe `std.testing.allocator`. The allocator object was capable\nof looking deeper in our program, and detecting the memory leak. As a result,\nthis allocator object returns an error message of \"memory leaked\", and also,\na stack trace showing the exact point where the memory was leaked.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nfn some_memory_leak(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u32, 10);\n    _ = buffer;\n    // Return without freeing the\n    // allocated memory\n}\n\ntest \"memory leak\" {\n    const allocator = std.testing.allocator;\n    try some_memory_leak(allocator);\n}\n```\n:::\n\n\n```\nTest [1/1] leak_memory.test.memory leak...\n    [gpa] (err): memory address 0x7c1fddf39000 leaked:\n./ZigExamples/debugging/leak_memory.zig:4:39: 0x10395f2\n    const buffer = try allocator.alloc(u32, 10);\n                                      ^\n./ZigExamples/debugging/leak_memory.zig:12:25: 0x10398ea\n    try some_memory_leak(allocator);\n\n... more stack trace\n```\n\n\n## Testing errors\n\nOne common style of unit tests are those that look for\nspecific errors in your functions. In other words, you write\na unit test that tries to assert if a specific function call\nreturns any error, or a specific type of error.\n\nIn C++ you would normally write this style of unit tests using, for example,\nthe functions `REQUIRE_THROWS()` or `CHECK_THROWS()` from the [`Catch2` test framework](https://github.com/catchorg/Catch2/tree/devel)[^catch2].\nIn the case of a Python project, you would probably use the\n[`raises()` function from `pytest`](https://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises)[^pytest].\nWhile in Rust, you would probably use `assert_eq!()` in conjunction with `Err()`.\n\n[^pytest]: <https://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises>\n[^catch2]: <https://github.com/catchorg/Catch2/tree/devel>\n\n\nBut in Zig, we use the `expectError()` function, from the `std.testing` module.\nWith this function, you can test if a specific function call returns the exact\ntype of error that you expect it to return. To use this function, you first write\n`try expectError()`. Then, on the first argument, you provide the type of error that you\nare expecting from the function call. Then, on the second argument, you write\nthe function call that you expect to fail.\n\nThe code example below demonstrates such type of unit test in Zig.\nNotice that, inside the function `alloc_error()` we are allocating\n100 bytes of memory, or, an array of 100 elements, for the object `ibuffer`. However,\nin the `test` block, we are using the `FixedBufferAllocator()`\nallocator object, which is limited to 10 bytes of space, because\nthe object `buffer`, which we provided to the allocator object,\nhave only 10 bytes of space.\n\nThat is why, the `alloc_error()` function raises an `OutOfMemory` error\non this case.\nBecause this function is trying to allocate more space than the allocator\nobject allows.\nSo, in essence, we are testing for a specific type of error,\nwhich is `OutOfMemory`. If the `alloc_error()` function returns any other type of error,\nthen, the `expectError()` function would make the entire test fail.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expectError = std.testing.expectError;\nfn alloc_error(allocator: Allocator) !void {\n    var ibuffer = try allocator.alloc(u8, 100);\n    defer allocator.free(ibuffer);\n    ibuffer[0] = 2;\n}\n\ntest \"testing error\" {\n    var buffer: [10]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    try expectError(error.OutOfMemory, alloc_error(allocator));\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1/1 file36923dd03ca.test.testing error...OKAll 1 t\n  tests passed.\n```\n\n\n:::\n:::\n\n\n\n\n\n## Testing simple equalities\n\nIn Zig, there are some different ways you can test for an equality.\nYou already saw that we can use `expect()` with the logical operator `==`\nto essentially reproduce an equality test. But we also have\nsome other helper functions that you should know about, especially\n`expectEqual()`, `expectEqualSlices()` and `expectEqualStrings()`.\n\n\nThe `expectEqual()` function, as the name suggests, is a classic\ntest equality function. It receives two objects as input. The first\nobject is the value that you expect to be in the second object.\nWhile second object is the object you have, or, the object that your application\nproduced as result. So, with `expectEqual()` you are essentially\ntesting if the values stored inside these two objects\nare equal or not.\n\nYou can see in the example below that, the test performed by\n`expectEqual()` failed. Because the objects `v1` and `v2` contain\ndifferent values in them.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\ntest \"values are equal?\" {\n    const v1 = 15;\n    const v2 = 18;\n    try std.testing.expectEqual(v1, v2);\n}\n```\n:::\n\n\n```\n1/1 ve.test.values are equal?...\n    expected 15, found 18\n    FAIL (TestExpectedEqual)\nve.zig:5:5: test.values are equal? (test)\n    try std.testing.expectEqual(v1, v2);\n    ^\n0 passed; 0 skipped; 1 failed.\n```\n\n\nAlthough useful, the `expectEqual()` function does not work with arrays.\nFor testing if two arrays are equal, you should use the `expectEqualSlices()`\nfunction instead. This function have three arguments. First, you provide\nthe data type contained in both arrays that you are trying to compare.\nWhile the second and third arguments corresponds to the array objects that you want to compare.\n\nIn the example below, we are using this function to test if two array\nobjects (`array1` and `array2`) are equal or not. Since they\nare in fact equal, the unit test passed with no errors.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\ntest \"arrays are equal?\" {\n    const array1 = [3]u32{1, 2, 3};\n    const array2 = [3]u32{1, 2, 3};\n    try std.testing.expectEqualSlices(\n        u32, &array1, &array2\n    );\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1/1 file36921ca62ed8.test.arrays are equal?...OKAl\n  ll 1 tests passed.\n```\n\n\n:::\n:::\n\n\n\nAt last, you might also want to use the `expectEqualStrings()` function.\nAs the name suggests, you can use this function to test if two strings\nare equal or not. Just provide the two string objects that you want to compare,\nas inputs to the function.\n\nIf the function finds any existing differences between the two strings,\nthen, the function will raise an error, and also, print an error message\nthat shows the exact difference between the two string objects provided,\nas the example below demonstrates:\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\ntest \"strings are equal?\" {\n    const str1 = \"hello, world!\";\n    const str2 = \"Hello, world!\";\n    try std.testing.expectEqualStrings(\n        str1, str2\n    );\n}\n```\n:::\n\n\n```\n1/1 t.test.strings are equal?...\n====== expected this output: =========\nhello, world!␃\n======== instead found this: =========\nHello, world!␃\n======================================\nFirst difference occurs on line 1:\nexpected:\nhello, world!\n^ ('\\x68')\nfound:\nHello, world!\n^ ('\\x48')\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "d955858e8c96c11c36427af044c591f0",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n\n\n\n# Debugging Zig applications\n\nBeing able to debug your applications is essential for any programmer who wants to\ndo serious programming in any language. That is why, in this chapter, we are going to talk about the\navailable strategies and tools to debug applications written in Zig.\n\n\n## Print debugging\n\nWe begin with the classic and battle-tested *print debugging* strategy.\nThe key advantage that debugging offers you is *visibility*.\nWith *print statements* you can easily see what results and objects\nare being produced by your application.\n\nThat is the essence of *print debugging*. Is to use\nprint expressions to see the values that are being generated by your program,\nand, as a result, get a much better understanding of how your program\nis behaving.\n\nMany programmers often resort to the print functions in Zig, such as the `stdout.print()`,\nor, the `std.debug.print()`, to get a better understanding of their programs.\nThis is a known and old strategy that is very simple and effective, and it is better known within\nthe programming community as *print debugging*.\nIn Zig, you can print information to the `stdout` or `stderr` streams of your system.\n\nLet's begin with `stdout`. First, you\nneed to get access to the `stdout`, by calling the `getStdOut()` method, from\nthe Zig Standard Library. This method returns a *file descriptor* object,\nand, through this object you can read/write to the `stdout`.\nI recommend you to check out all methods available in this object, by [checking the page in\nthe Zig Standard Library Official Reference for the type `File`](https://ziglang.org/documentation/master/std/#std.fs.File)[^zig-fiile-reference].\n\n[^zig-fiile-reference]: <https://ziglang.org/documentation/master/std/#std.fs.File>.\n\nFor our purpose here, which is to write something to the `stdout`, especially to debug our\nprogram, I recommend you to use the `writer()` method, which gives your a *writer* object.\nThis *writer* object offers some helper methods to write stuff into the file descriptor object\nthat represents the `stdout` stream. In special, the `print()` method.\n\n\nThe `print()` method from this *writer* object is a \"print formatter\" type of a function.\nIn other words, this method works exactly like the `printf()` function from C,\nor, like `println!()` from Rust.\nIn the first argument of the function, you specify a template string, and,\nin the second argument, you provide a list of values (or objects) that you want to insert\ninto your template message.\n\nIdeally, the template string in the first argument should contain some format specifier.\nEach format specifier is matched to a value (or object) that you have listed in the second argument.\nSo, if you provided 5 different objects in the second argument, then, the template string\nshould contain 5 format specifiers, one for each object provided.\n\nEach format specifier is represented by a single letter, and\nyou provide this format specifier inside a pair of curly braces. So, if you want to format\nyour object using the string specifier (`s`), then, you can insert the text `{s}` in your template string.\nHere is a quick list of the most used format specifiers:\n\n- `d`: for printing integers and floating-point numbers.\n- `c`: for printing characters.\n- `s`: for printing strings.\n- `p`: for printing memory addresses.\n- `x`: for printing hexadecimal values.\n- `any`: use any compatible format specifier (i.e. it automatically selects a format specifier for you).\n\nThe code example below gives you an example of use of this `print()` method\nwith the `d` format specifier.\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    _ = try stdout.print(\"Result: {d}\", .{result});\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResult: 50\n```\n\n\n:::\n:::\n\n\n\n\nIs important to emphasize that, the `stdout.print()` method, as you would expect,\nprint your template string into the `stdout` stream of your system.\nHowever, you can also print your template string into the `stderr` stream\nif your prefer. All you need to do, is to replace the `stdout.print()`\ncall with the function `std.debug.print()`. Like this:\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    std.debug.print(\"Result: {d}\\n\", .{result});\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResult: 50\n```\n\n\n:::\n:::\n\n\n\n\n\nYou could also achieve the exact same result by getting a file descriptor object to `stderr`,\nthen, creating a *writer* object to `stderr`, then, using the `print()` method of this\n*writer* object, like in the example below:\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stderr = std.io.getStdErr().writer();\n// some more lines ...\n_ = try stderr.print(\"Result: {d}\", .{result});\n```\n:::\n\n\n\n\n\n\n## Debugging through debuggers\n\nAlthough *print debugging* being a valid and very useful strategy,\nmost programmers prefer to use a debugger to debug their programs.\nSince Zig is a low-level language, you can use either GDB (GNU Debugger),\nor LLDB (LLVM Project Debugger) as your debugger.\n\nBoth debuggers can work with Zig code, and it's a matter of taste here.\nYou choose the debugger of your preference, and you work with it.\nIn this book, I will use LLDB as my debugger on the examples.\n\n\n### Compile your source code in debug mode {#sec-compile-debug-mode}\n\nIn order to debug your program through a debugger, you must compile\nyour source code in `Debug` mode. Because when you compile your\nsource code in other modes (such as `Release`), the compiler usually\nstrips out some essential information that is used by the debugger\nto read and track your program, like PDB (*Program Database*) files.\n\nBy compiling your source code in `Debug` mode, you ensure that the debugger\nwill find the necessary information in your program to debug it.\nBy default, the compiler uses the `Debug` mode when compiling your code.\nHaving this in mind, when you compile your program with the `build-exe`\ncommand (which was described at @sec-compile-code), if you don't specify\nan explicit mode through the `-O` command-line [^oargument]\nargument, then, the compiler will compile your code in `Debug` mode.\n\n[^oargument]: See <https://ziglang.org/documentation/master/#Debug>.\n\n\n### Let's debug a program\n\nAs an example, let's use LLDB to navigate and investigate the following\npiece of Zig code:\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\nfn add_and_increment(a: u8, b: u8) u8 {\n    const sum = a + b;\n    const incremented = sum + 1;\n    return incremented;\n}\n\npub fn main() !void {\n    var n = add_and_increment(2, 3);\n    n = add_and_increment(n, n);\n    _ = try stdout.print(\"Result: {d}!\\n\", .{n});\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResult: 13!\n```\n\n\n:::\n:::\n\n\n\n\nThere is nothing wrong with this program. But it is\na good start for us. First, we need to compile\nthis program with the `zig build-exe` command.\nFor this example, suppose that I have compiled the above\nZig code into a binary executable called `add_program`.\n\n```bash\nzig build-exe add_program.zig\n```\n\nNow, we can start LLDB with `add_program`, like this:\n\n```bash\nlldb add_program\n```\n\nFrom now on, LLDB is started, and you can know that I'm\nexecuting LLDB commands by looking at the prefix `(lldb)`.\nIf something is prefixed with `(lldb)`, then you know\nthat it is a LLDB command.\n\nThe first thing I will do, is to set a breakpoint at\nthe `main()` function, by executing `b main`.\nAfter that, I just start the execution of the program\nwith `run`.\nYou can see in the output below, that the execution\nstopped at the first line in the function `main()`, as we expected.\n\n```bash\n(lldb) b main\nBreakpoint 1: where = debugging`debug1.main + 22\n    at debug1.zig:11:30, address = 0x00000000010341a6\n(lldb) run\nProcess 8654 launched: 'add_program' (x86_64)\nProcess 8654 stopped\n* thread #1, name = 'add_program',\n    stop reason = breakpoint 1.1 frame #0: 0x10341a6\n    add_program`debug1.main at add_program.zig:11:30\n   8   \t}\n   9   \t\n   10  \tpub fn main() !void {\n-> 11  \t    var n = add_and_increment(2, 3);\n   12  \t    n = add_and_increment(n, n);\n   13  \t    try stdout.print(\"Result: {d}!\\n\", .{n});\n   14  \t}\n```\n\nI can start navigating through the code, and checking the objects\nthat are being generated. If you are not familiar with the commands\navailable in LLDB, I recommend you to read the official documentation\nof the project[^lldb].\nYou can also look for cheat sheets, which quickly describes all commands\navailable for you[^lldb-quick-list].\n\n[^lldb]: <https://lldb.llvm.org/>\n[^lldb-quick-list]: <https://gist.github.com/ryanchang/a2f738f0c3cc6fbd71fa>.\n\nCurrently, we are in the first line at the `main()` function. In this line, we create\nthe `n` object, by executing the `add_and_increment()` function.\nTo execute the current line of code, and go to the next line, we can\nrun the `n` LLDB command. Let's execute this command.\n\nAfter we executed this line, we can also look at the value stored inside this `n` object\nby using the `p` LLDB command. The syntax for this command is `p <name-of-object>`.\n\nIf we take a look at the value stored in the `n` object (`p n`),\nnotice that it stores the hexadecimal value `0x06`, which\nis the number 6 in decimal. We can also see that, this value have a type `unsigned char`,\nwhich is an unsigned 8-bit integer.\nWe have talked already about this at @sec-zig-strings, that `u8` integers in Zig are equivalent\nto the C data type `unsigned char`.\n\n\n\n```bash\n(lldb) n\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step over frame #0: 0x10341ae\n    debugging`debug1.main at debug1.zig:12:26\n   9   \t\n   10  \tpub fn main() !void {\n   11  \t    var n = add_and_increment(2, 3);\n-> 12  \t    n = add_and_increment(n, n);\n   13  \t    try stdout.print(\"Result: {d}!\\n\", .{n});\n   14  \t}\n(lldb) p n\n(unsigned char) $1 = '\\x06'\n```\n\nNow, on the next line of code, we are executing the `add_and_increment()` function once again.\nWhy not step inside this function? Shall we? We can do that, by executing the `s` LLDB command.\nNotice in the example below that, after executing this command, we have entered into the context of the\n`add_and_increment()` function.\n\nAlso notice in the example below that, I have walked two more lines in the function's body, then,\nI execute the `frame variable` LLDB command, to see at once, the value stored in each of the variables\nthat were created inside the current scope.\n\nYou can see in the output below that, the object `sum` stores the value `\\f`,\nwhich represents the *form feed* character. This character in the ASCII table,\ncorresponds to the hexadecimal value `0x0C`, or, in decimal, the number 12.\nSo, this means that the result of the expression `a + b` executed at line\n5, resulted in the number 12.\n\n```bash\n(lldb) s\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step in frame #0: 0x10342de\n    debugging`debug1.add_and_increment(a='\\x02', b='\\x03')\n    at debug1.zig:4:39\n-> 4   \tfn add_and_increment(a: u8, b: u8) u8 {\n   5   \t    const sum = a + b;\n   6   \t    const incremented = sum + 1;\n   7   \t    return incremented;\n(lldb) n\n(lldb) n\n(lldb) frame variable\n(unsigned char) a = '\\x06'\n(unsigned char) b = '\\x06'\n(unsigned char) sum = '\\f'\n(unsigned char) incremented = '\\x06'\n```\n\n\n\n## How to investigate the data type of your objects\n\nSince Zig is a strongly-typed language, the data types associated with your objects\nare very important for your program. So, debugging the data types associated\nwith your objects might be important to understand bugs and errors in your program.\n\nWhen you walk through your program with a debugger, you can inspect the types of\nyour objects by simply printing them to the console, with the LLDB `p` command.\nBut you also have alternatives embedded in the language itself to access the data\ntypes of your objects.\n\nIn Zig, you can retrieve the data type of an object, by using the built-in function\n`@TypeOf()`. Just apply this function over the object, and you get access to \nthe data type of the object.\n\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst expect = std.testing.expect;\n\npub fn main() !void {\n    const number: i32 = 5;\n    try expect(@TypeOf(number) == i32);\n    try stdout.print(\"{any}\\n\", .{@TypeOf(number)});\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\ni32\n```\n\n\n:::\n:::\n\n\n\n\nThis function is similar to the `type()` built-in function from Python,\nor, the `typeof` operator in Javascript.\n\n",
    "supporting": [
      "02-debugging_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Zig: a project-based book",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the ‚ÄúOpen Access‚Äù HTML version of the book ‚ÄúIntroduction to Zig: a project-based book‚Äù, written by Pedro Duarte Faria. This is an open book that provides an introduction to the Zig programming language, which is a new general-purpose, and low-level language for building robust and optimal software.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Introduction to Zig: a project-based book",
    "section": "About this book",
    "text": "About this book\nThis an open book, meaning that, it is open-source, and it will always be open for anyone that wants to read it. However, this book is still under construction üöß and active development, so, it‚Äôs contents might change drastically in the near future.\nAlso, this is a project-based book, which means that we learn how to use the Zig programming language through small and simple projects, in a similar style to the famous ‚ÄúPython Crash Course‚Äù book from Eric Matthes.\nOfficial book‚Äôs repository: https://github.com/pedropark99/zig-book",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "Introduction to Zig: a project-based book",
    "section": "About the author",
    "text": "About the author\nPedro Duarte Faria have a bachelor degree in Economics from Federal University of Ouro Preto - Brazil. Currently, he is a Data Platform Engineer at Blip1, and an Associate Developer for Apache Spark 3.0 certified by Databricks.\nThe author have more than 4 years of experience in the data industry. Developing data products, pipelines, reports and analysis for research institutions and some of the largest companies in the brazilian financial sector, such as the BMG Bank, Sodexo and Pan Bank.\nBut Pedro is also a passionate software developer that loves to learn and teach about programming. Although Pedro uses many different languages in his work, he is specialized in the R programming language, and have given several lectures and courses about it, inside graduate centers (such as PPEA-UFOP2), in addition to federal and state organizations (such as FJP-MG3).\nPersonal Website: https://pedro-faria.netlify.app/\nLinkedin: https://www.linkedin.com/in/pedro-faria-a68140209/\nMastodon: @pedropark99@fosstodon.org\nTwitter (X): @PedroPark9",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Introduction to Zig: a project-based book",
    "section": "License",
    "text": "License\nCopyright ¬© 2024 Pedro Duarte Faria. This book is licensed by the CC-BY 4.0 Creative Commons Attribution 4.0 International Public License4.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-compilation-metadata",
    "href": "index.html#book-compilation-metadata",
    "title": "Introduction to Zig: a project-based book",
    "section": "Book compilation metadata",
    "text": "Book compilation metadata\nThis book was compiled using the following versions of Zig and Quarto:\n\nSystem version: Linux, 5.15.153.1-microsoft-standard-WSL2, NA, x86_64.\nZig version: 0.13.0.\nQuarto version: 1.4.554.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-citation",
    "href": "index.html#book-citation",
    "title": "Introduction to Zig: a project-based book",
    "section": "Book citation",
    "text": "Book citation\nYou can use the following BibTex entry to cite this book:\n@book{pedro2024,\n    author = {Pedro Duarte Faria},\n    title = {Introduction to Zig},\n    subtitle = {a project-based book},\n    month = {December},\n    edition = {1},\n    year = {2024},\n    address = {Belo Horizonte},\n    url = {https://pedropark99.github.io/zig-book/}\n}",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#corresponding-author-and-maintainer",
    "href": "index.html#corresponding-author-and-maintainer",
    "title": "Introduction to Zig: a project-based book",
    "section": "Corresponding author and maintainer",
    "text": "Corresponding author and maintainer\nPedro Duarte Faria\nContact: pedropark99@gmail.com\nPersonal website: https://pedro-faria.netlify.app/",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Introduction to Zig: a project-based book",
    "section": "",
    "text": "https://www.blip.ai/en/‚Ü©Ô∏é\nhttps://ppea.ufop.br/‚Ü©Ô∏é\nhttp://fjp.mg.gov.br/‚Ü©Ô∏é\nhttps://creativecommons.org/licenses/by/4.0/‚Ü©Ô∏é",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html",
    "href": "Chapters/01-zig-weird.html",
    "title": "1¬† Introducing Zig",
    "section": "",
    "text": "1.1 What is Zig?\nZig is a modern, low-level, and general-purpose programming language. Some programmers interpret Zig as the ‚Äúmodern C language‚Äù. It is a simple language like C, but with some modern features.\nIn the author‚Äôs personal interpretation, Zig is tightly connected with ‚Äúless is more‚Äù. Instead of trying to become a modern language by adding more and more features, many of the core improvements that Zig brings to the table are actually about removing annoying and evil behaviours/features from C and C++. In other words, Zig tries to be better by simplifying the language, and by having more consistent and robust behaviour. As a result, analyzing, writing and debugging applications become much easier and simpler in Zig, than it is in C or C++.\nThis philosophy becomes clear with the following phrase from the official website of Zig:\nThis phrase is specially true for C++ programmers. Because C++ is a gigantic language, with tons of features, and also, there are lots of different ‚Äúflavors of C++‚Äù. These elements are what makes C++ so much complex and hard to learn. Zig tries to go in the opposite direction. Zig is a very simple language, more closely related to other simple languages such as C and Go.\nThe phrase above is still important for C programmers too. Because, even C being a simple language, it is still hard sometimes to read and understand C code. For example, pre-processor macros in C are an evil source of confusion. They really makes it hard sometimes to debug C programs. Because macros are essentially a second language embedded in C that obscures your C code. With macros, you are no longer 100% sure about which pieces of code are being sent to the compiler. It obscures the actual source code that you wrote.\nYou don‚Äôt have macros in Zig. In Zig, the code you write, is the actual code that get‚Äôs compiled by the compiler. You don‚Äôt have evil features that obscures you code. You also don‚Äôt have hidden control flow happening behind the scenes. And, you also don‚Äôt have functions or operators from the standard library that make hidden memory allocations behind your back.\nBy being a simpler language, Zig becomes much more clear and easier to read/write, but at the same time, it also achieves a much more robust state, with more consistent behaviour in edge situations. Once again, less is more.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#what-is-zig",
    "href": "Chapters/01-zig-weird.html#what-is-zig",
    "title": "1¬† Introducing Zig",
    "section": "",
    "text": "‚ÄúFocus on debugging your application rather than debugging your programming language knowledge‚Äù.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "href": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.2 Hello world in Zig",
    "text": "1.2 Hello world in Zig\nWe begin our journey in Zig by creating a small ‚ÄúHello World‚Äù program. To start a new Zig project in your computer, you simply call the init command from the zig compiler. Just create a new directory in your computer, then, init a new Zig project inside this directory, like this:\nmkdir hello_world\ncd hello_world\nzig init\ninfo: created build.zig\ninfo: created build.zig.zon\ninfo: created src/main.zig\ninfo: created src/root.zig\ninfo: see `zig build --help` for a menu of options\n\n1.2.1 Understanding the project files\nAfter you run the init command from the zig compiler, some new files are created inside of your current directory. First, a ‚Äúsource‚Äù (src) directory is created, containing two files, main.zig and root.zig. Each .zig file is a separate Zig module, which is simply a text file that contains some Zig code.\nThe main.zig file for example, contains a main() function, which represents the entrypoint of your program. It is where the execution of your program begins. As you would expect from a C, C++, Rust or Go, to build an executabe program in Zig, you also need to declare a main() function in your module. So, the main.zig module represents an executable program written in Zig.\nOn the other side, the root.zig module does not contain a main() function. Because it represents a library written in Zig. Libraries are different than executables. They don‚Äôt need to have an entrypoint to work. So, you can choose which file (main.zig or root.zig) you want to follow depending on which type of project (executable or library) you want to develop.\ntree .\n.\n‚îú‚îÄ‚îÄ build.zig\n‚îú‚îÄ‚îÄ build.zig.zon\n‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ main.zig\n    ‚îî‚îÄ‚îÄ root.zig\n\n1 directory, 4 files\nNow, in addition to the source directory, two other files were created in our working directory: build.zig and build.zig.zon. The first file (build.zig) represents a build script written in Zig. This script is executed when you call the build command from the zig compiler. In other words, this file contain Zig code that executes the necessary steps to build the entire project.\nIn general, low-level languages normally use a compiler to build your source code into binary executables or binary libraries. Nevertheless, this process of compiling your source code and building binary executables or binary libraries from it, became a real challenge in the programming world, once the projects became bigger and bigger. As a result, programmers created ‚Äúbuild systems‚Äù, which are a second set of tools designed to make this process of compiling and building complex projects, easier.\nExamples of build systems are CMake, GNU Make, GNU Autoconf and Ninja, which are used to build complex C and C++ projects. With these systems, you can write scripts, which are called ‚Äúbuild scripts‚Äù. They simply are scripts that describes the necessary steps to compile/build your project.\nHowever, these are separate tools, that do not belong to C/C++ compilers, like gcc or clang. As a result, in C/C++ projects, you have not only to install and manage your C/C++ compilers, but you also have to install and manage these build systems separately.\nBut instead of using a separate build system, in Zig, we use the Zig language itself to write build scripts. In other words, Zig contains a native build system in it. And we can use this build system to write small scripts in Zig, which describes the necessary steps to build/compile our Zig project2. So, everything you need to build a complex Zig project is the zig compiler, and nothing more.\nNow that we described this topic in more depth, let‚Äôs focus on the second generated file (build.zig.zon), which is the Zig package manager configuration file, where you can list and manage the dependencies of your project. Yes, Zig have a package manager (like pip in Python, cargo in Rust, or npm in Javascript) called Zon, and this build.zig.zon file is similar to the package.json file in Javascript projects, or, the Pipfile in Python projects.\n\n\n1.2.2 Looking at the root.zig file\nLet‚Äôs take a look at the root.zig file, and start to analyze some of the syntax of Zig. The first thing that you might notice, is that every line of code that have an expression in it, ends with a semicolon character (;). This is similar syntax to other languages such as C, C++ and Rust, which have the same rule.\nAlso, notice the @import() call at the first line. We use this built-in function to import functionality from other Zig modules into our current module. In other words, the @import() function works similarly to the #include pre-processor in C or C++, or, to the import statement in Python or Javascript code. In this example, we are importing the std module, which gives you access to the Zig standard library.\nIn this root.zig file, we can also see how assignments (i.e.¬†creating new objects) are made in Zig. You can create a new object in Zig by using the following syntax (const|var) name = value;. In the example below, we are creating two constant objects (std and testing). At Section 1.4 we talk more about objects in general.\n\nconst std = @import(\"std\");\nconst testing = std.testing;\n\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nFunctions in Zig are declared similarly to functions in Rust, using the fn keyword. In the example above, we are declaring a function called add(), which have two arguments named a and b, and returns a integer number (i32) as result.\nMaybe Zig is not exactly a strongly-typed language, because you do not need necessarily to specify the type of every single object you create across your source code. But you do have to explicitly specify the type of every function argument, and also, the return type of every function you create in Zig. So, at least in function declarations, Zig is a strongly-typed language.\nWe specify the type of an object or a function argument in Zig, by using a colon character (:) followed by the type after the name of this object/function argument. With the expressions a: i32 and b: i32, we know that, both a and b arguments have type i32, which is a signed 32 bit integer. In this part, the syntax in Zig is identical to the syntax in Rust, which also specifies types by using the colon character.\nLastly, we have the return type of the function at the end of the line, before we open the curly braces to start writing the function‚Äôs body, which, in the example above is again a signed 32 bit integer (i32) value. This specific part is different than it is in Rust. Because in Rust, the return type of a function is specified after an arrow (-&gt;). While in Zig, we simply declare the return type directly after the parentheses with the function arguments.\nWe also have an export keyword before the function declaration. This keyword is similar to the extern keyword in C. It exposes the function to make it available in the library API.\nIn other words, if you have a project where you are currently building a library for other people to use, you need to expose your functions so that they are available in the library‚Äôs API, so that users can use it. If we removed the export keyword from the add() function declaration, then, this function would be no longer exposed in the library object built by the zig compiler.\nHaving that in mind, the keyword export is a keyword used in libraries written in Zig. So, if you are not currently writing a library in your project, then, you do not need to care about this keyword.\n\n\n1.2.3 Looking at the main.zig file\nNow that we have learned a lot about Zig‚Äôs syntax from the root.zig file, let‚Äôs take a look at the main.zig file. A lot of the elements we saw in root.zig are also present in main.zig. But we have some other elements that we did not have seen yet, so let‚Äôs dive in.\nFirst, look at the return type of the main() function in this file. We can see a small change. Now, the return type of the function (void) is accompanied by an exclamation mark (!). What this exclamation mark is telling us, is that this main() function might also return an error.\nSo, in this example, the main() function can either return void, or, return an error. This is an interesting feature of Zig. If you write a function, and, something inside of the body of this function might return an error, then, you are forced to:\n\neither add the exclamation mark to the return type of the function, to make it clear that this function might return an error.\nor explicitly handle this error that might occur inside the function, to make sure that, if this error does happen, you are prepared, and your function will no longer return an error because you handled the error inside your function.\n\nIn most programming languages, we normally handle (or deals with) an error through a try catch pattern, and Zig, this is no different. But, if we look at the main() function below, you can see that we do have a try keyword in the 5th line. But we do not have a catch keyword in this code.\nThis means that, we are using the keyword try to execute a code that might return an error, which is the stdout.print() expression. But because we do not have a catch keyword in this line, we are not treating (or dealing with) this error. So, if this expression do return an error, we are not catching and solving this error in any way. That is why the exclamation mark was added to the return type of the function.\nSo, in essence, the try keyword executes the expression stdout.print(). If this expression returns a valid value, then, the try keyword do nothing essentially. It simply passes this value forward. But, if the expression do return an error, then, the try keyword will unwrap and return this error from the function, and also print it‚Äôs stack trace to stderr.\nThis might sound weird to you, if you come from a high-level language. Because in high-level languages, such as Python, if an error occurs somewhere, this error is automatically returned and the execution of your program will automatically stops, even if you don‚Äôt want to stop the execution. You are obligated to face the error.\nBut if you come from a low-level language, then, maybe, this idea do not sound so weird or distant to you. Because in C for example, normally functions doesn‚Äôt raise errors, or, they normally don‚Äôt stop the execution. In C, error handling is done by constantly checking the return value of the function. So, you run the function, and then, you use an if statement to check if the function returned a value that is valid, or, if it returned an error. If an error was returned from the function, then, the if statement will execute some code that fixes this error.\nSo, at least for C programmers, they do need to write a lot of if statements to constantly check for errors around their code. And because of that, this simple feature from Zig, might be extraordinary for them. Because this try keyword can automatically unwrap the error, and warn you about this error, and let you deal with it, without any extra work from the programmer.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nNow, another thing that you might have noticed in this code example, is that the main() function is marked with the pub keyword. This keyword means ‚Äúpublic‚Äù. It marks the main() function as a public function from this module.\nIn other words, every function that you declare in your Zig module is, by default, a private (or ‚Äústatic‚Äù) function that belongs to this Zig module, and can only be used (or called) from within this same module. Unless, you explicitly mark this function as a public function with the pub keyword. This means that the pub keyword in Zig do essentially the opposite of what the static keyword do in C/C++.\nBy making a function ‚Äúpublic‚Äù, you allow other Zig modules to access and call this function, and use it for they own purposes. all these other Zig modules need to do is, to import your module with the @import() built-in function. Then, they get access to all public functions that are present in your Zig module.\n\n\n1.2.4 Compiling your source code\nYou can compile your Zig modules into a binary executable by running the build-exe command from the zig compiler. You simply list all the Zig modules that you want to build after the build-exe command, separated by spaces. In the example below, we are compiling the module main.zig.\nzig build-exe src/main.zig\nSince we are building an executable, the zig compiler will look for a main() function declared in any of the files that you list after the build-exe command. If the compiler does not find a main() function declared somewhere, a compilation error will be raised, warning about this mistake.\nThe zig compiler also offers a build-lib and build-obj commands, which work the exact same way as the build-exe command. The only difference is that, they compile your Zig modules into a portale C ABI library, or, into object files, respectively.\nIn the case of the build-exe command, a binary executable file is created by the zig compiler in the root directory of your project. If we take a look now at the contents of our current directory, with a simple ls command, we can see the binary file called main that was created by the compiler.\nls\nbuild.zig  build.zig.zon  main  src\nIf I execute this binary executable, I get the ‚ÄúHello World‚Äù message in the terminal , as we expected.\n./main\nHello, world!\n\n\n1.2.5 Compile and execute at the same time\nOn the previous section, I presented the zig build-exe command, which compiles Zig modules into an executable file. However, this means that, in order to execute the executable file, we have to run two different commands. First, the zig build-exe command, and then, we call the executable file created by the compiler.\nBut what if we wanted to perform these two steps, all at once, in a single command? We can do that by using the zig run command.\nzig run src/main.zig\nHello, world!\n\n\n1.2.6 Compiling the entire project\nJust as I described at Section 1.2.1, as our project grows in size and complexity, we usually prefer to organize the compilation and build process of the project into a build script, using some sort of ‚Äúbuild system‚Äù.\nIn other words, as our project grows in size and complexity, the build-exe, build-lib and build-obj commands become harder to use directly. Because then, we start to list multiple and multiple modules at the same time. We also start to add built-in compilation flags to customize the build process for our needs, etc. It becomes a lot of work to write the necessary commands by hand.\nIn C/C++ projects, programmers normally opt to use CMake, Ninja, Makefile or configure scripts to organize this process. However, in Zig, we have a native build system in the language itself. So, we can write build scripts in Zig to compile and build Zig projects. Then, all we need to do, is to call the zig build command to build our project.\nSo, when you execute the zig build command, the zig compiler will search for a Zig module named build.zig inside your current directory, which should be your build script, containing the necessary code to compile and build your project. If the compiler do find this build.zig file in your directory, then, the compiler will essentially execute a zig run command over this build.zig file, to compile and execute this build script, which in turn, will compile and build your entire project.\nzig build\nAfter you execute this ‚Äúbuild project‚Äù command, a zig-out directory is created in the root of your project directory, where you can find the binary executables and libraries created from your Zig modules accordingly to the build commands that you specified at build.zig. We will talk more about the build system in Zig latter in this book.\nIn the example below, I‚Äôm executing the binary executable named hello_world that was generated by the compiler after the zig build command.\n./zig-out/bin/hello_world\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#how-to-learn-zig",
    "href": "Chapters/01-zig-weird.html#how-to-learn-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.3 How to learn Zig?",
    "text": "1.3 How to learn Zig?\nWhat are the best strategies to learn Zig? First of all, of course this book will help you a lot on your journey through Zig. But you will also need some extra resources if you want to be really good at Zig.\nAs a first tip, you can join a community with Zig programmers to get some help , when you need it:\n\nReddit forum: https://www.reddit.com/r/Zig/;\nZiggit community: https://ziggit.dev/;\nDiscord, Slack, Telegram, and others: https://github.com/ziglang/zig/wiki/Community;\n\nNow, one of the best ways to learn Zig is to simply read Zig code. Try to read Zig code often, and things will become more clear. A C/C++ programmer would also probably give you this same tip. Because this strategy really works!\nNow, where you can find Zig code to read? I personally think that, the best way of reading Zig code is to read the source code of the Zig Standard Library. The Zig Standard Library is available at the lib/std folder3 on the official GitHub repository of Zig. Access this folder, and start exploring the Zig modules.\nAlso, a great alternative is to read code from other large Zig codebases, such as:\n\nthe Javascript runtime Bun4.\nthe game engine Mach5.\na LLama 2 LLM model implementation in Zig6.\nthe financial transactions database tigerbeetle7.\nthe command-line arguments parser zig-clap8.\nthe UI framework capy9.\nthe Language Protocol implementation for Zig, zls10.\nthe event-loop library libxev11.\n\nAll these assets are available on GitHub, and this is great, because we can use the GitHub search bar in our advantage, to find Zig code that fits our description. For example, you can always include lang:Zig in the GitHub search bar when you are searching for a particular pattern. This will limit the search to only Zig modules.\nAlso, a great alternative is to consult online resources and documentations. Here is a quick list of resources that I personally use from time to time to learn more about the language each day:\n\nZig Language Reference: https://ziglang.org/documentation/master/;\nZig Standard Library Reference: https://ziglang.org/documentation/master/std/;\nZig Guide: https://zig.guide/;\nKarl Seguin Blog: https://www.openmymind.net/;\nZig News: https://zig.news/;\nRead the code written by one of the Zig core team members: https://github.com/kubkon;\nSome livecoding sessions are transmitted in the Zig Showtime Youtube Channel: https://www.youtube.com/@ZigSHOWTIME/videos;\n\nAnother great strategy to learn Zig, or honestly, to learn any language you want, is to practice it by solving exercises. For example, there is a famous repository in the Zig community called Ziglings12 , which contains more than 100 small exercises that you can solve. It is a repository of tiny programs written in Zig that are currently broken, and your responsibility is to fix these programs, and make them work again.\nA famous tech YouTuber known as The Primeagen also posted some videos (at YouTube) where he solves these exercises from Ziglings. The first video is named ‚ÄúTrying Zig Part 1‚Äù13.\nAnother great alternative, is to solve the Advent of Code exercises14. There are people that already took the time to learn and solve the exercises, and they posted their solutions on GitHub as well, so, in case you need some resource to compare while solving the exercises, you can look at these two repositories:\n\nhttps://github.com/SpexGuy/Zig-AoC-Template;\nhttps://github.com/fjebaker/advent-of-code-2022;",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-assignments",
    "href": "Chapters/01-zig-weird.html#sec-assignments",
    "title": "1¬† Introducing Zig",
    "section": "1.4 Creating new objects in Zig (i.e.¬†identifiers)",
    "text": "1.4 Creating new objects in Zig (i.e.¬†identifiers)\nLet‚Äôs talk more about objects in Zig. Readers that have past experience with other programming languages might know this concept through a different name, such as: ‚Äúvariable‚Äù or ‚Äúidentifier‚Äù. In this book, I choose to use the term ‚Äúobject‚Äù to refer to this concept.\nTo create a new object (or a new ‚Äúidentifier‚Äù) in Zig, we use the keywords const or var. These keywords specificy if the object that you are creating is mutable or not. If you use const, then the object you are creating is a constant (or immutable) object, which means that once you declare this object, you can no longer change the value stored inside this object.\nOn the other side, if you use var, then, you are creating a variable (or mutable) object. You can change the value of this object as many times you want. Using the keyword var in Zig is similar to using the keywords let mut in Rust.\n\n1.4.1 Constant objects vs variable objects\nIn the code example below, we are creating a new constant object called age. This object stores a number representing the age of someone. However, this code example does not compiles succesfully. Because on the next line of code, we are trying to change the value of the object age to 25.\nThe zig compiler detects that we are trying to change the value of an object/identifier that is constant, and because of that, the compiler will raise a compilation error, warning us about the mistake.\n\nconst age = 24;\n// The line below is not valid!\nage = 25;\n\nt.zig:10:5: error: cannot assign to constant\n    age = 25;\n      ~~^~~\nIn contrast, if you use var, then, the object created is a variable object. With var you can declare this object in your source code, and then, change the value of this object how many times you want over future points in your source code.\nSo, using the same code example exposed above, if I change the declaration of the age object to use the var keyword, then, the program gets compiled succesfully. Because now, the zig compiler detects that we are changing the value of an object that allows this behaviour, because it is an ‚Äúvariable object‚Äù.\n\nvar age: u8 = 24;\nage = 25;\n\n\n\n1.4.2 Declaring without an initial value\nBy default, when you declare a new object in Zig, you must give it an initial value. In other words, this means that we have to declare, and, at the same time, initialize every object we create in our source code.\nOn the other hand, you can, in fact, declare a new object in your source code, and not give it an explicit value. But we need to use a special keyword for that, which is the undefined keyword.\nIs important to emphasize that, you should avoid using undefined as much as possible. Because when you use this keyword, you leave your object uninitialized, and, as a consequence, if for some reason, your code use this object while it is uninitialized, then, you will definitely have undefined behaviour and major bugs in your program.\nIn the example below, I‚Äôm declaring the age object again. But this time, I do not give it an initial value. The variable is only initialized at the second line of code, where I store the number 25 in this object.\n\nvar age: u8 = undefined;\nage = 25;\n\nHaving these points in mind, just remember that you should avoid as much as possible to use undefined in your code. Always declare and initialize your objects. Because this gives you much more safety in your program. But in case you really need to declare an object without initializing it‚Ä¶ the undefined keyword is the way to do it in Zig.\n\n\n1.4.3 There is no such thing as unused objects\nEvery object (being constant or variable) that you declare in Zig must be used in some way. You can give this object to a function call, as a function argument, or, you can use it in another expression to calculate the value of another object, or, you can call a method that belongs to this particular object.\nIt doesn‚Äôt matter in which way you use it. As long as you use it. If you try to break this rule, i.e.¬†if your try to declare a object, but not use it, the zig compiler will not compile your Zig source code, and it will issue a error message warning that you have unused objects in your code.\nLet‚Äôs demonstrate this with an example. In the source code below, we declare a constant object called age. If you try to compile a simple Zig program with this line of code below, the compiler will return an error as demonstrated below:\n\nconst age = 15;\n\nt.zig:4:11: error: unused local constant\n    const age = 15;\n          ^~~\nEverytime you declare a new object in Zig, you have two choices:\n\nyou either use the value of this object;\nor you explicitly discard the value of the object;\n\nTo explicitly discard the value of any object (constant or variable), all you need to do is to assign this object to an special character in Zig, which is the underscore (_). When you assign an object to a underscore, like in the example below, the zig compiler will automatically discard the value of this particular object.\nYou can see in the example below that, this time, the compiler did not complain about any ‚Äúunused constant‚Äù, and succesfully compiled our source code.\n\n// It compiles!\nconst age = 15;\n_ = age;\n\nNow, remember, everytime you assign a particular object to the underscore, this object is essentially destroyed. It is discarded by the compiler. This means that you can no longer use this object further in your code. It doesn‚Äôt exist anymore.\nSo if you try to use the constant age in the example below, after we discarded it, you will get a loud error message from the compiler (talking about a ‚Äúpointless discard‚Äù) warning you about this mistake.\n\n// It does not compile.\nconst age = 15;\n_ = age;\n// Using a discarded value!\nstd.debug.print(\"{d}\\n\", .{age + 2});\n\nt.zig:7:5: error: pointless discard\n    of local constant\nThis same rule applies to variable objects. Every variable object must also be used in some way. And if you assign a variable object to the underscore, this object also get‚Äôs discarded, and you can no longer use this object.\n\n\n1.4.4 You must mutate every variable objects\nEvery variable object that you create in your source code must be mutated at some point. In other words, if you declare an object as a variable object, with the keyword var, and you do not change the value of this object at some point in the future, the zig compiler will detect this, and it will raise an error warning you about this mistake.\nThe concept behind this is that every object you create in Zig should be preferably a constant object, unless you really need an object whose value will change during the execution of your program.\nSo, if I try to declare a variable object such as where_i_live below, and I do not change the value of this object in some way, the zig compiler raises an error message with the phrase ‚Äúvariable is never mutated‚Äù.\n\nvar where_i_live = \"Belo Horizonte\";\n_ = where_i_live;\n\nt.zig:7:5: error: local variable is never mutated\nt.zig:7:5: note: consider using 'const'",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-primitive-data-types",
    "href": "Chapters/01-zig-weird.html#sec-primitive-data-types",
    "title": "1¬† Introducing Zig",
    "section": "1.5 Primitive Data Types",
    "text": "1.5 Primitive Data Types\nZig have many different primitive data types available for you to use. You can see the full list of available data types at the official Language Reference page15.\nBut here is a quick list:\n\nUnsigned integers: u8, 8-bit integer; u16, 16-bit integer; u32, 32-bit integer; u64, 64-bit integer; u128, 128-bit integer.\nSigned integers: i8, 8-bit integer; i16, 16-bit integer; i32, 32-bit integer; i64, 64-bit integer; i128, 128-bit integer.\nFloat number: f16, 16-bit floating point; f32, 32-bit floating point; f64, 64-bit floating point; f128, 128-bit floating point;\nBoolean: bool, represents true or false values.\nC ABI compatible types: c_long, c_char, c_short, c_ushort, c_int, c_uint, and many others.\nPointer sized integers: isize and usize.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-arrays",
    "href": "Chapters/01-zig-weird.html#sec-arrays",
    "title": "1¬† Introducing Zig",
    "section": "1.6 Arrays",
    "text": "1.6 Arrays\nYou create arrays in Zig by using a syntax that resembles the C syntax. First, you specify the size of the array (i.e.¬†the number of elements that will be stored in the array) you want to create inside a pair of brackets.\nThen, you specify the data type of the elements that will be stored inside this array. All elements present in an array in Zig must have the same data type. For example, you cannot mix elements of type f32 with elements of type i32 in the same array.\nAfter that, you simply list the values that you want to store in this array inside a pair of curly braces. In the example below, I am creating two constant objets that contain different arrays. The first object contains an array of 4 integer values, while the second object, an array of 3 floating point values.\nNow, you should notice that in the object ls, I am not explicitly specifying the size of the array inside of the brackets. Instead of using a literal value (like the value 4 that I used in the ns object), I am using the special character underscore (_). This syntax tells the zig compiler to fill this field with the number of elements listed inside of the curly braces. So, this syntax [_] is for lazy (or smart) programmers who leave the job of counting how many elements there are in the curly braces for the compiler.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst ls = [_]f64{432.1, 87.2, 900.05};\n_ = ns; _ = ls;\n\nIs worth noting that these are static arrays, meaning that they cannot grow in size. Once you declare your array, you cannot change the size of it. This is very commom in low level languages. Because low level languages normally wants to give you (the programmer) full control over memory, and the way in which arrays are expanded is tightly related to memory management.\n\n1.6.1 Selecting elements of the array\nOne very commom activity is to select specific portions of an array you have in your source code. In Zig, you can select a specific element from your array, by simply providing the index of this particular element inside brackets after the object name. In the example below, I am selecting the third element from the ns array. Notice that Zig is a ‚Äúzero-index‚Äù based language, like C, C++, Rust, Python, and many other languages.\n\nconst ns = [4]u8{48, 24, 12, 6};\ntry stdout.print(\"{d}\\n\", .{ ns[2] });\n\n12\n\n\nIn contrast, you can also select specific slices (or sections) of your array, by using a range selector. Some programmers also call these selectors of ‚Äúslice selectors‚Äù, and they also exist in Rust, and have the exact same syntax as in Zig. Anyway, a range selector is a special expression in Zig that defines a range of indexes, and it have the syntax start..end.\nIn the example below, at the second line of code, the sl object stores a slice (or a portion) of the ns array. More precisely, the elements at index 1 and 2 in the ns array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\n_ = sl;\n\nWhen you use the start..end syntax, the ‚Äúend tail‚Äù of the range selector is non-inclusive, meaning that, the index at the end is not included in the range that is selected from the array. Therefore, the syntax start..end actually means start..end - 1 in practice.\nYou can for example, create a slice that goes from the first to the last elements of the array, by using ar[0..ar.len] syntax In other words, it is a slice that access all elements in the array.\n\nconst ar = [4]u8{48, 24, 12, 6};\nconst sl = ar[0..ar.len];\n_ = sl;\n\nYou can also use the syntax start.. in your range selector. Which tells the zig compiler to select the portion of the array that begins at the start index until the last element of the array. In the example below, we are selecting the range from index 1 until the end of the array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..];\n_ = sl;\n\n\n\n1.6.2 More on slices\nAs we discussed before, in Zig, you can select specific portions of an existing array. This is called slicing in Zig (Sobeston 2024), because when you select a portion of an array, you are creating a slice object from that array.\nA slice object is essentially a pointer object accompained by a length number. The pointer object points to the first element in the slice, and the length number tells the zig compiler how many elements there are in this slice.\n\nSlices can be thought of as a pair of [*]T (the pointer to the data) and a usize (the element count) (Sobeston 2024).\n\nThrough the pointer contained inside the slice you can access the elements (or values) that are inside this range (or portion) that you selected from the original array. But the length number (which you can access through the len property of your slice object) is the really big improvement (over C arrays for example) that Zig brings to the table here.\nBecause with this length number the zig compiler can easily check if you are trying to access an index that is out of the bounds of this particular slice, or, if you are causing any buffer overflow problems. In the example below, we access the len property of the slice sl, which tells us that this slice have 2 elements in it.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\ntry stdout.print(\"{d}\\n\", .{sl.len});\n\n2\n\n\n\n\n1.6.3 Array operators\nThere are two array operators available in Zig that are very useful. The array concatenation operator (++), and the array multiplication operator (**). As the name suggests, these are array operators.\nOne important detail about these two operators is that they work only when both operands have a size (or ‚Äúlength‚Äù) that is compile-time known. We are going to talk more about the differences between ‚Äúcompile-time known‚Äù and ‚Äúruntime known‚Äù at Section 3.1.1. But for now, keep this information in mind, that you cannot use these operators in every situation.\nIn summary, the ++ operator creates a new array that is the concatenation, of both arrays provided as operands. So, the expression a ++ b produces a new array which contains all the elements from arrays a and b.\n\nconst a = [_]u8{1,2,3};\nconst b = [_]u8{4,5};\nconst c = a ++ b;\ntry stdout.print(\"{any}\\n\", .{c});\n\n{ 1, 2, 3, 4, 5 }\n\n\nThis ++ operator is particularly useful to concatenate strings together. Strings in Zig are described in depth at Section 1.8. In summary, a string object in Zig is essentially an arrays of bytes. So, you can use this array concatenation operator to effectively concatenate strings together.\nIn contrast, the ** operator is used to replicate an array multiple times. In other words, the expression a ** 3 creates a new array which contains the elements of the array a repeated 3 times.\n\nconst a = [_]u8{1,2,3};\nconst c = a ** 2;\ntry stdout.print(\"{any}\\n\", .{c});\n\n{ 1, 2, 3, 1, 2, 3 }",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-blocks",
    "href": "Chapters/01-zig-weird.html#sec-blocks",
    "title": "1¬† Introducing Zig",
    "section": "1.7 Blocks and scopes",
    "text": "1.7 Blocks and scopes\nBlocks are created in Zig by a pair of curly braces. A block is just a group of expressions (or statements) contained inside of a pair of curly braces. All of these expressions that are contained inside of this pair of curly braces belongs to the same scope.\nIn other words, a block just delimits a scope in your code. The objects that you define inside the same block belongs to the same scope, and, therefore, are accessible from within this scope. At the same time, these objects are not accessible outside of this scope. So, you could also say that blocks are used to limit the scope of the objects that you create in your source code. In less technical terms, blocks are used to specify where in your source code you can access whatever object you have in your source code.\nSo, a block is just a group of expressions contained inside a pair of curly braces. And every block have it‚Äôs own scope separated from the others. The body of a function is a classic example of a block. If statements, for and while loops (and any other structure in the language that uses the pair of curly braces) are also examples of blocks.\nThis means that, every if statement, or for loop, etc., that you create in your source code have it‚Äôs own separate scope. That is why you can‚Äôt access the objects that you defined inside of your for loop (or if statement) in an outer scope, i.e.¬†a scope outside of the for loop. Because you are trying to access an object that belongs to a scope that is different than your current scope.\nYou can create blocks within blocks, with multiple levels of nesting. You can also (if you want to) give a label to a particular block, with the colon character (:). Just write label: before you open the pair of curly braces that delimits your block. When you label a block in Zig, you can use the break keyword to return a value from this block, like as if it was a function‚Äôs body. You just write the break keyword, followed by the block label in the format :label, and the expression that defines the value that you want to return.\nLike in the example below, where we are returning the value from the y object from the block add_one, and saving the result inside the x object.\n\nvar y: i32 = 123;\nconst x = add_one: {\n    y += 1;\n    break :add_one y;\n};\nif (x == 124 and y == 124) {\n    try stdout.print(\"Hey!\", .{});\n}\n\nHey!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-zig-strings",
    "href": "Chapters/01-zig-weird.html#sec-zig-strings",
    "title": "1¬† Introducing Zig",
    "section": "1.8 How strings work in Zig?",
    "text": "1.8 How strings work in Zig?\nThe first project that we are going to build and discuss in this book is a base64 encoder/decoder (Chapter 4). But in order for us to build such a thing, we need to get a better understanding on how strings work in Zig. So let‚Äôs discuss this specific aspect of Zig.\nIn Zig, a string literal value is just a pointer to a null-terminated array of bytes (i.e.¬†the same thing as a C string). However, a string object in Zig is a little more than just a pointer. A string object in Zig is an object of type []const u8, and, this object always contains two things: the same null-terminated array of bytes that you would find in a string literal value, plus a length value. Each byte in this ‚Äúarray of bytes‚Äù is represented by an u8 value, which is an unsigned 8 bit integer, so, it is equivalent to the C data type unsigned char.\n\n// This is a string literal value:\n\"A literal value\";\n// This is a string object:\nconst object: []const u8 = \"A string object\";\n\nZig always assumes that this sequence of bytes is UTF-8 encoded. This might not be true for every sequence of bytes you have it, but is not really Zig‚Äôs job to fix the encoding of your strings (you can use iconv16 for that). Today, most of the text in our modern world, specially on the web, should be UTF-8 encoded. So if your string literal is not UTF-8 encoded, then, you will likely have problems in Zig.\nLet‚Äôs take for example the word ‚ÄúHello‚Äù. In UTF-8, this sequence of characters (H, e, l, l, o) is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In xecadecimal, this sequence is 0x48, 0x65, 0x6C, 0x6C, 0x6F. So if I take this sequence of hexadecimal values, and ask Zig to print this sequence of bytes as a sequence of characters (i.e.¬†a string), then, the text ‚ÄúHello‚Äù will be printed into the terminal:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};\n    try stdout.print(\"{s}\\n\", .{bytes});\n}\n\nHello\n\n\nIf you want to see the actual bytes that represents a string in Zig, you can use a for loop to iterate through each byte in the string, and ask Zig to print each byte as an hexadecimal value to the terminal. You do that by using a print() statement with the X formatting specifier, like you would normally do with the printf() function17 in C.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_object = \"This is an example of string literal in Zig\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_object) |byte| {\n        try stdout.print(\"{X} \", .{byte});\n    }\n    try stdout.print(\"\\n\", .{});\n}\n\nBytes that represents the string object: 54 68 69 \n   73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65 20 6F\n  F 66 20 73 74 72 69 6E 67 20 6C 69 74 65 72 61 6C 2\n  20 69 6E 20 5A 69 67 \n\n\n\n1.8.1 Strings in C\nAt first glance, this looks very similar to how C treats strings as well. In more details, string values in C are treated internally as an array of arbitrary bytes, and this array is also null-terminated.\nBut one key difference between a Zig string and a C string, is that Zig also stores the length of the array inside the string object. This small detail makes your code safer, because is much easier for the Zig compiler to check if you are trying to access an element that is ‚Äúout of bounds‚Äù, i.e.¬†if your trying to access memory that does not belong to you.\nTo achieve this same kind of safety in C, you have to do a lot of work that kind of seems pointless. So getting this kind of safety is not automatic and much harder to do in C. For example, if you want to track the length of your string troughout your program in C, then, you first need to loop through the array of bytes that represents this string, and find the null element ('\\0') position to discover where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.\nTo do that, you would need something like this in C. In this example, the C string stored in the object array is 25 bytes long:\n#include &lt;stdio.h&gt;\nint main() {\n    char* array = \"An example of string in C\";\n    int index = 0;\n    while (1) {\n        if (array[index] == '\\0') {\n            break;\n        }\n        index++;\n    }\n    printf(\"Number of elements in the array: %d\\n\", index);\n}\nNumber of elements in the array: 25\nBut in Zig, you do not have to do this, because the object already contains a len field which stores the length information of the array. As an example, the string_object object below is 43 bytes long:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_object = \"This is an example of string literal in Zig\";\n    try stdout.print(\"{d}\\n\", .{string_object.len});\n}\n\n43\n\n\n\n\n1.8.2 A better look at the object type\nNow, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the @TypeOf() function. If we look at the type of the simple_array object below, you will find that this object is a array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type i32 in Zig. That is what an object of type [4]i32 is.\nBut if we look closely at the type of the string_object object below, you will find that this object is a constant pointer (hence the *const annotation) to an array of 43 elements (or 43 bytes). Each element is a single byte (more precisely, an unsigned 8 bit integer - u8), that is why we have the [43:0]u8 portion of the type below. In other words, the string stored inside the string_object object is 43 bytes long. That is why you have the type *const [43:0]u8 below.\nIn the case of string_object, it is a constant pointer (*const) because the object string_object is declared as constant in the source code (in the line const string_object = ...). So, if we changed that for some reason, if we declare string_object as a variable object (i.e.¬†var string_object = ...), then, string_object would be just a normal pointer to an array of unsigned 8-bit integers (i.e.¬†* [43:0]u8).\nNow, if we create an pointer to the simple_array object, then, we get a constant pointer to an array of 4 elements (*const [4]i32), which is very similar to the type of the string_object object. This demonstrates that a string object (or a string literal) in Zig is already a pointer to an array.\nJust remember that a ‚Äúpointer to an array‚Äù is different than an ‚Äúarray‚Äù. So a string object in Zig is a pointer to an array of bytes, and not simply an array of bytes.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_object = \"This is an example of string literal in Zig\";\n    const simple_array = [_]i32{1, 2, 3, 4};\n    try stdout.print(\"Type of array object: {}\", .{@TypeOf(simple_array)});\n    try stdout.print(\n        \"Type of string object: {}\",\n        .{@TypeOf(string_object)}\n    );\n    try stdout.print(\n        \"Type of a pointer that points to the array object: {}\",\n        .{@TypeOf(&simple_array)}\n    );\n}\n\nType of array object: [4]i32\nType of string object: *const [43:0]u8\nType of a pointer that points to\n    the array object: *const [4]i32\n\n\n1.8.3 Byte vs unicode points\nIs important to point out that each byte in the array is not necessarily a single character. This fact arises from the difference between a single byte and a single unicode point.\nThe encoding UTF-8 works by assigning a number (which is called a unicode point) to each character in the string. For example, the character ‚ÄúH‚Äù is stored in UTF-8 as the decimal number 72. This means that the number 72 is the unicode point for the character ‚ÄúH‚Äù. Each possible character that can appear in a UTF-8 encoded string have its own unicode point.\nFor example, the Latin Capital Letter A With Stroke (»∫) is represented by the number (or the unicode point) 570. However, this decimal number (570) is higher than the maximum number stored inside a single byte, which is 255. In other words, the maximum decimal number that can be represented with a single byte is 255. That is why, the unicode point 570 is actually stored inside the computer‚Äôs memory as the bytes C8 BA.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_object = \"»∫\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_object) |char| {\n        try stdout.print(\"{X} \", .{char});\n    }\n}\n\nBytes that represents the string object: C8 BA \n\n\nThis means that to store the character »∫ in an UTF-8 encoded string, we need to use two bytes together to represent the number 570. That is why the relationship between bytes and unicode points is not always 1 to 1. Each unicode point is a single character in the string, but not always a single byte corresponds to a single unicode point.\nAll of this means that if you loop trough the elements of a string in Zig, you will be looping through the bytes that represents that string, and not through the characters of that string. In the »∫ example above, the for loop needed two iterations (instead of a single iteration) to print the two bytes that represents this »∫ letter.\nNow, all english letters (or ASCII letters if you prefer) can be represented by a single byte in UTF-8. As a consequence, if your UTF-8 string contains only english letters (or ASCII letters), then, you are lucky. Because the number of bytes will be equal to the number of characters in that string. In other words, in this specific situation, the relationship between bytes and unicode points is 1 to 1.\nBut on the other side, if your string contains other types of letters‚Ä¶ for example, you might be working with text data that contains, chinese, japanese or latin letters, then, the number of bytes necessary to represent your UTF-8 string will likely be much higher than the number of characters in that string.\nIf you need to iterate through the characters of a string, instead of its bytes, then, you can use the std.unicode.Utf8View struct to create an iterator that iterates through the unicode points of your string.\nIn the example below, we loop through the japanese characters ‚Äú„Ç¢„É°„É™„Ç´‚Äù. Each of the four characters in this string is represented by three bytes. But the for loop iterates four times, one iteration for each character/unicode point in this string:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    var utf8 = (\n        (try std.unicode.Utf8View.init(\"„Ç¢„É°„É™„Ç´\"))\n            .iterator()\n    );\n    while (utf8.nextCodepointSlice()) |codepoint| {\n        try stdout.print(\n            \"got codepoint {}\\n\",\n            .{std.fmt.fmtSliceHexUpper(codepoint)}\n        );\n    }\n}\n\ngot codepoint E382A2\ngot codepoint E383A1\ngot codepoint E383AA\ngot codepoint E382AB",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#safety-in-zig",
    "href": "Chapters/01-zig-weird.html#safety-in-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.9 Safety in Zig",
    "text": "1.9 Safety in Zig\nA general trend in modern low-level programming languages is safety. As our modern world become more interconnected with techology and computers, the data produced by all of this technology becomes one of the most important (and also, one of the most dangerous) assets that we have.\nThis is probably the main reason why modern low-level programming languages have been giving great attention to safety, specially memory safety, because memory corruption is still the main target for hackers to exploit. The reality is that we don‚Äôt have an easy solution for this problem. For now, we only have techniques and strategies that mitigates these problems.\nAs Richard Feldman explains on his most recent GOTO conference talk18 , we haven‚Äôt figured it out yet a way to achieve true safety in technology. In other words, we haven‚Äôt found a way to build software that won‚Äôt be exploited with 100% certainty. We can greatly reduce the risks of our software being exploited, by ensuring memory safety for example. But this is not enough to achieve ‚Äútrue safety‚Äù territory.\nBecause even if you write your program in a ‚Äúsafe language‚Äù, hackers can still exploit failures in the operational system where your program is running (e.g.¬†maybe the system where your code is running have a ‚Äúbackdoor exploit‚Äù that can still affect your code in unexpected ways), or also, they can exploit the features from the architecture of your computer. A recently found exploit that involves memory invalidation through a feature of ‚Äúmemory tags‚Äù present in ARM chips is an example of that (Kim et al. 2024).\nThe question is: what Zig and other languages have been doing to mitigate this problem? If we take Rust as an example, Rust is, for the most part19, a memory safe language by enforcing specific rules to the developer. In other words, the key feature of Rust, the borrow checker, forces you to follow a specific logic when you are writing your Rust code, and the Rust compiler will always complain everytime you try to go out of this pattern.\nIn contrast, the Zig language is not a memory safe language by default. Instead of forcing the developer to follow a specific rule, the Zig language achieves memory safety by offering tools that the developer can use for this purpose. In other words, the zig compiler does not obligates you to use such tools. But there is often no reason to not use these tools in your Zig code, so you often achieve a similar level of memory safety of Rust in Zig by simply using these tools.\nThe tools listed below are related to memory safety in Zig. That is, they help you to achieve memory safety in your Zig code:\n\ndefer allows you to keep free operations phisically close to allocations. This helps you to avoid memory leaks, ‚Äúuse after free‚Äù, and also ‚Äúdouble-free‚Äù problems. Furthermore, it also keeps free operations logically tied to the end of the current scope, which greatly reduces the mental overhead about object lifetime.\nerrdefer helps you to garantee that your program frees the allocated memory, even if a runtime error occurs.\npointers and object are non-nullable by default. This helps you to avoid memory problems that might arise from de-referencing null pointers.\nZig offers some native types of allocators (called ‚Äútesting allocators‚Äù) that can detect memory leaks and double-frees. These types of allocators are widely used on unit tests, so they make your unit tests a weapon that you can use to detect memory problems in your code.\narrays and slices in Zig have their lengths embedded in the object itself, which makes the zig compiler very effective on detecting ‚Äúindex out-of-range‚Äù type of errors, and avoiding buffer overflows.\n\nDespite these features that Zig offers that are related to memory safety issues, the language also have some rules that help you to achieve another type of safety, which is more related to program logic safety. These rules are:\n\npointers and objects are non-nullable by default. Which eliminates an edge case that might break the logic of your program.\nswitch statements must exaust all possible options.\nthe zig compiler forces you to handle every possible error.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#other-parts-of-zig",
    "href": "Chapters/01-zig-weird.html#other-parts-of-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.10 Other parts of Zig",
    "text": "1.10 Other parts of Zig\nWe already learned a lot about Zig‚Äôs syntax, and also, some pretty technical details about it. Just as a quick recap:\n\nWe talked about how functions are written in Zig at Section 1.2.2 and Section 1.2.3.\nHow to create new objects/identifiers at Section 1.2.2 and specially at Section 1.4.\nHow strings work in Zig at Section 1.8.\nHow to use arrays and slices at Section 1.6.\nHow to import functionality from other Zig modules at Section 1.2.2.\n\nBut, for now, this amount of knowledge is enough for us to continue with this book. Later, over the next chapters we will still talk more about other parts of Zig‚Äôs syntax that are also equally important as the other parts. Such as:\n\nHow Object-Oriented programming can be done in Zig through struct declarations at Section 2.3.\nBasic control flow syntax at Section 2.1.\nEnums at Section 7.6;\nPointers and Optionals at Chapter 6;\nError handling with try and catch at Chapter 10;\nUnit tests at Chapter 8;\nVectors;\nBuild System at Chapter 9;\n\n\n\n\n\nKim, Juhee, Jinbum Park, Sihyeon Roh, Jaeyoung Chung, Youngjoo Lee, Taesoo Kim, and Byoungyoung Lee. 2024. ‚ÄúTikTag: Breaking ARM‚Äôs Memory Tagging Extension with Speculative Execution.‚Äù https://arxiv.org/abs/2406.08719.\n\n\nSobeston. 2024. ‚ÄúZig Guide.‚Äù https://zig.guide/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#footnotes",
    "href": "Chapters/01-zig-weird.html#footnotes",
    "title": "1¬† Introducing Zig",
    "section": "",
    "text": "New programming languages in general, take years and years to be developed.‚Ü©Ô∏é\nhttps://ziglang.org/learn/overview/#zig-build-system.‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/tree/master/lib/std‚Ü©Ô∏é\nhttps://github.com/oven-sh/bun.‚Ü©Ô∏é\nhttps://github.com/hexops/mach‚Ü©Ô∏é\nhttps://github.com/cgbur/llama2.zig/tree/main‚Ü©Ô∏é\nhttps://github.com/tigerbeetle/tigerbeetle‚Ü©Ô∏é\nhttps://github.com/Hejsil/zig-clap‚Ü©Ô∏é\nhttps://github.com/capy-ui/capy‚Ü©Ô∏é\nhttps://github.com/zigtools/zls‚Ü©Ô∏é\nhttps://github.com/mitchellh/libxev‚Ü©Ô∏é\nhttps://codeberg.org/ziglings/exercises/.‚Ü©Ô∏é\nhttps://www.youtube.com/watch?v=OPuztQfM3Fg&t=2524s&ab_channel=TheVimeagen.‚Ü©Ô∏é\nhttps://adventofcode.com/‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/#Primitive-Types.‚Ü©Ô∏é\nhttps://www.gnu.org/software/libiconv/‚Ü©Ô∏é\nhttps://cplusplus.com/reference/cstdio/printf/‚Ü©Ô∏é\nhttps://www.youtube.com/watch?v=jIZpKpLCOiU&ab_channel=GOTOConferences‚Ü©Ô∏é\nActually, a lot of existing Rust code is still memory unsafe, because they communicate with external libraries through FFI (foreign function interface), which disables the borrow-checker features through the unsafe keyword.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html",
    "href": "Chapters/03-structs.html",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "",
    "text": "2.1 Control flow\nSometimes, you need to make decisions in your program. Maybe you need to decide wether to execute or not a specific piece of code. Or maybe, you need to apply the same operation over a sequence of values. These kinds of tasks, involve using structures that are capable of changing the ‚Äúcontrol flow‚Äù of our program.\nIn computer science, the term ‚Äúcontrol flow‚Äù usually refers to the order in which expressions (or commands) are evaluated in a given language or program. But this term is also used to refer to structures that are capable of changing this ‚Äúevaluation order‚Äù of the commands executed by a given language/program.\nThese structures are better known by a set of terms, such as: loops, if/else statements, switch statements, among others. So, loops and if/else statements are examples of structures that can change the ‚Äúcontrol flow‚Äù of our program. The keywords continue and break are also examples of symbols that can change the order of evaluation, since they can move our program to the next iteration of a loop, or make the loop stop completely.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html#sec-zig-control-flow",
    "href": "Chapters/03-structs.html#sec-zig-control-flow",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "",
    "text": "2.1.1 If/else statements\nAn if/else statement performs an ‚Äúconditional flow operation‚Äù. A conditional flow control (or choice control) allows you to execute or ignore a certain block of commands based on a logical condition. Many programmers and computer science professionals also use the term ‚Äúbranching‚Äù in this case. In essence, we use if/else statements to use the result of a logical test to decide whether or not to execute a given block of commands.\nIn Zig, we write if/else statements by using the keywords if and else. We start with the if keyword followed by a logical test inside a pair of parentheses, and then, a pair of curly braces with contains the lines of code to be executed in case the logical test returns the value true.\nAfter that, you can optionally add an else statement. Just add the else keyword followed by a pair of curly braces, with the lines of code to executed in case the logical test defined in the if returns false.\nIn the example below, we are testing if the object x contains a number that is greater than 10. Judging by the output printed to the console, we know that this logical test returned false. Because the output in the console is compatible with the line of code present in the else branch of the if/else statement.\n\nconst x = 5;\nif (x &gt; 10) {\n    try stdout.print(\n        \"x &gt; 10!\\n\", .{}\n    );\n} else {\n    try stdout.print(\n        \"x &lt;= 10!\\n\", .{}\n    );\n}\n\nx &lt;= 10!\n\n\n\n\n2.1.2 Swith statements\nSwitch statements are also available in Zig. A switch statement in Zig have a similar syntax to a switch statement in Rust. As you would expect, to write a switch statement in Zig we use the switch keyword. We provide the value that we want to ‚Äúswitch over‚Äù inside a pair of parentheses. Then, we list the possible combinations (or ‚Äúbranchs‚Äù) inside a pair of curly braces.\nLet‚Äôs take a look at the code example below. You can see in this example that, I‚Äôm creating an enum type called Role. We talk more about enums at Section 7.6. But in essence, this Role type is listing different types of roles in a fictitious company, like SE for Software Engineer, DE for Data Engineer, PM for Product Manager, etc.\nNotice that we are using the value from the role object in the switch statement, to discover which exact area we need to store in the area variable object. Also notice that we are using type inference inside the switch statement, with the dot character, as we described at Section 2.4. This makes the zig compiler infer the correct data type of the values (PM, SE, etc.) for us.\nAlso notice that, we are grouping multiple values in the same branch of the switch statement. We just separate each possible value with a comma. So, for example, if role contains either DE or DA, the area variable would contain the value \"Data & Analytics\", instead of \"Platform\".\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Role = enum {\n    SE, DPE, DE, DA, PM, PO, KS\n};\n\npub fn main() !void {\n    var area: []const u8 = undefined;\n    const role = Role.SE;\n    switch (role) {\n        .PM, .SE, .DPE, .PO =&gt; {\n            area = \"Platform\";\n        },\n        .DE, .DA =&gt; {\n            area = \"Data & Analytics\";\n        },\n        .KS =&gt; {\n            area = \"Sales\";\n        },\n    }\n    try stdout.print(\"{s}\\n\", .{area});\n}\n\nPlatform\n\n\nNow, one very important aspect about this switch statement presented in the code example above, is that it exhaust all existing possibilities. In other words, all possible values that could be found inside the order object are explicitly handled in this switch statement.\nSince the role object have type Role, the only possible values to be found inside this object are PM, SE, DPE, PO, DE, DA and KS. There is no other possible value to be stored in this role object. This what ‚Äúexhaust all existing possibilities‚Äù means. The switch statement covers every possible case.\nIn Zig, switch statements must exhaust all existing possibilities. You cannot write a switch statement, and leave an edge case with no expliciting action to be taken. This is a similar behaviour to switch statements in Rust, which also have to handle all possible cases.\nTake a look at the dump_hex_fallible() function below as an example. This function also comes from the Zig Standard Library, but this time, it comes from the debug.zig module1. There are multiple lines in this function, but I omitted them to focus solely on the switch statement found in this function. Notice that this switch statement have four possible cases, or four explicit branches. Also, notice that we used an else branch in this case. Whenever you have multiple possible cases in your switch statement which you want to apply the same exact action, you can use an else branch to do that.\n\npub fn dump_hex_fallible(bytes: []const u8) !void {\n    // Many lines ...\n    switch (byte) {\n        '\\n' =&gt; try writer.writeAll(\"‚êä\"),\n        '\\r' =&gt; try writer.writeAll(\"‚êç\"),\n        '\\t' =&gt; try writer.writeAll(\"‚êâ\"),\n        else =&gt; try writer.writeByte('.'),\n    }\n}\n\nMany users would also use an else branch to handle a ‚Äúnot supported‚Äù case. That is, a case that cannot be properly handled by your code, or, just a case that should not be ‚Äúfixed‚Äù. So many programmers use an else branch to panic (or raise an error) to stop the current execution.\nTake the code example below as an example. We can see that, we are handling the cases for the level object being either 1, 2, or 3. All other possible cases are not supported by default, and, as consequence, we raise an runtime error in these cases, through the @panic() built-in function.\nAlso notice that, we are assigning the result of the switch statement to a new object called category. This is another thing that you can do with switch statements in Zig. If the branchs in this switch statement output some value as result, you can store the result value of the switch statement into a new object.\n\nconst level: u8 = 4;\nconst category = switch (level) {\n    1, 2 =&gt; \"beginner\",\n    3 =&gt; \"professional\",\n    else =&gt; {\n        @panic(\"Not supported level!\");\n    },\n};\ntry stdout.print(\"{s}\\n\", .{category});\n\nthread 13103 panic: Not supported level!\nt.zig:9:13: 0x1033c58 in main (switch2)\n            @panic(\"Not supported level!\");\n            ^\nFurthermore, you can also use ranges of values in switch statements. That is, you can create a branch in your switch statement that is used whenever the input value is contained in a range. These range expressions are created with the operator .... Is important to emphasize that the ranges created by this operator are inclusive on both ends.\nFor example, I could easily change the code example above to support all levels between 0 and 100. Like this:\n\nconst level: u8 = 4;\nconst category = switch (level) {\n    0...25 =&gt; \"beginner\",\n    26...75 =&gt; \"intermediary\",\n    76...100 =&gt; \"professional\",\n    else =&gt; {\n        @panic(\"Not supported level!\");\n    },\n};\ntry stdout.print(\"{s}\\n\", .{category});\n\nbeginner\n\n\nThis is neat, and it works with character ranges too. That is, I could simply write 'a'...'z', to match any character value that is a lowercase letter, and it would work fine.\n\n\n2.1.3 The defer keyword\nWith the defer keyword you can execute expressions at the end of the current scope. Take the foo() function below as an example. When we execute this function, the expression that prints the message ‚ÄúExiting function ‚Ä¶‚Äù get‚Äôs executed only at the end of the function scope.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn foo() !void {\n    defer std.debug.print(\n        \"Exiting function ...\\n\", .{}\n    );\n    try stdout.print(\"Adding some numbers ...\\n\", .{});\n    const x = 2 + 2; _ = x;\n    try stdout.print(\"Multiplying ...\\n\", .{});\n    const y = 2 * 8; _ = y;\n}\n\npub fn main() !void {\n    try foo();\n}\n\nAdding some numbers ...\nMultiplying ...\nExiting function ...\nIt doesn‚Äôt matter how the function exits (i.e.¬†because of an error, or, because of an return statement, or whatever), just remember, this expression get‚Äôs executed when the function exits.\n\n\n2.1.4 For loops\nA loop allows you to execute the same lines of code multiple times, thus, creating a ‚Äúrepetition space‚Äù in the execution flow of your program. Loops are particularly useful when we want to replicate the same function (or the same set of commands) over several different inputs.\nThere are different types of loops available in Zig. But the most essential of them all is probably the for loop. A for loop is used to apply the same piece of code over the elements of a slice or an array.\nFor loops in Zig have a slightly different syntax that you are probably used to see in other languages. You start with the for keyword, then, you list the items that you want to iterate over inside a pair of parentheses. Then, inside of a pair of pipes (|) you should declare an identifier that will serve as your iterator, or, the ‚Äúrepetition index of the loop‚Äù.\n\nfor (items) |value| {\n    // code to execute\n}\n\nInstead of using a (value in items) syntax, in Zig, for loops use the syntax (items) |value|. In the example below, you can see that we are looping through the items of the array stored at the object name, and printing to the console the decimal representation of each character in this array.\nIf we wanted, we could also iterate through a slice (or a portion) of the array, instead of iterating through the entire array stored in the name object. Just use a range selector to select the section you want. For example, I could provide the expression name[0..3] to the for loop, to iterate just through the first 3 elements in the array.\n\nconst name = [_]u8{'P','e','d','r','o'};\nfor (name) |char| {\n    try stdout.print(\"{d} | \", .{char});\n}\n\n80 | 101 | 100 | 114 | 111 | \n\n\nIn the above example we are using the value itself of each element in the array as our iterator. But there are many situations where we need to use an index instead of the actual values of the items.\nYou can do that by providing a second set of items to iterate over. More precisely, you provide the range selector 0.. to the for loop. So, yes, you can use two different iterators at the same time in a for loop in Zig.\nBut remember from Section 1.4 that, every object you create in Zig must be used in some way. So if you declare two iterators in your for loop, you must use both iterators inside the for loop body. But if you want to use just the index iterator, and not use the ‚Äúvalue iterator‚Äù, then, you can discard the value iterator by maching the value items to the underscore character, like in the example below:\n\nfor (name, 0..) |_, i| {\n    try stdout.print(\"{d} | \", .{i});\n}\n\n0 | 1 | 2 | 3 | 4 |\n\n\n2.1.5 While loops\nA while loop is created from the while keyword. A for loop iterates through the items of an array, but a while loop will loop continuously, and infinitely, until a logical test (specified by you) becomes false.\nYou start with the while keyword, then, you define a logical expression inside a pair of parentheses, and the body of the loop is provided inside a pair of curly braces, like in the example below:\n\nvar i: u8 = 1;\nwhile (i &lt; 5) {\n    try stdout.print(\"{d} | \", .{i});\n    i += 1;\n}\n\n1 | 2 | 3 | 4 | \n\n\n\n\n2.1.6 Using break and continue\nIn Zig, you can explicitly stop the execution of a loop, or, jump to the next iteration of the loop, using the keywords break and continue, respectively. The while loop present in the example below, is at first sight, an infinite loop. Because the logical value inside the parenthese will always be equal to true. What makes this while loop stop when the i object reaches the count 10? Is the break keyword!\nInside the while loop, we have an if statement that is constantly checking if the i variable is equal to 10. Since we are increasing the value of this i variable at each iteration of the while loop. At some point, this i variable will be equal to 10, and when it does, the if statement will execute the break expression, and, as a result, the execution of the while loop is stopped.\nNotice the expect() function from the Zig standard library after the while loop. This expect() function is an ‚Äúassert‚Äù type of function. This function checks if the logical test provided is equal to true. If this logical test is false, the function raises an assertion error. But it is equal to true, then, the function will do nothing.\n\nvar i: usize = 0;\nwhile (true) {\n    if (i == 10) {\n        break;\n    }\n    i += 1;\n}\ntry std.testing.expect(i == 10);\ntry stdout.print(\"Everything worked!\", .{});\n\nEverything worked!\n\n\nSince this code example was executed succesfully by the zig compiler, without raising any errors, then, we known that, after the execution of while loop, the i variable is equal to 10. Because if it wasn‚Äôt equal to 10, then, an error would be raised by expect().\nNow, in the next example, we have an use case for the continue keyword. The if statement is constantly checking if the current index is a multiple of 2. If it is, then we jump to the next iteration of the loop directly. But it the current index is not a multiple of 2, then, the loop will simply print this index to the console.\n\nconst ns = [_]u8{1,2,3,4,5,6};\nfor (ns) |i| {\n    if ((i % 2) == 0) {\n        continue;\n    }\n    try stdout.print(\"{d} | \", .{i});\n}\n\n1 | 3 | 5 |",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html#sec-fun-pars",
    "href": "Chapters/03-structs.html#sec-fun-pars",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "2.2 Function parameters are immutable",
    "text": "2.2 Function parameters are immutable\nWe have already discussed a lot of the syntax behind function declarations at Section 1.2.2 and Section 1.2.3. But I want to emphasize a curious fact about function parameters (a.k.a. function arguments) in Zig. In summary, function parameters are immutable in Zig.\nTake the code example below, where we declare a simple function that just tries to add some amount to the input integer, and returns the result back. But if you look closely at the body of this add2() function, you will notice that we try to save the result back into the x function argument.\nIn other words, this function not only use the value that it received through the function argument x, but it also tries to change the value of this function argument, by assigning the addition result into x. However, function arguments in Zig are immutable. You cannot change their values, or, you cannot assign values to them inside the body‚Äôs function.\nThis is the reason why, the code example below do not compile successfully. If you try to compile this code example, you get a compile error warning you that you are trying to change the value of a immutable (i.e.¬†constant) object.\n\nconst std = @import(\"std\");\nfn add2(x: u32) u32 {\n    x = x + 2;\n    return x;\n}\n\npub fn main() !void {\n    const y = add2(4);\n    std.debug.print(\"{d}\\n\", .{y});\n}\n\nt.zig:3:5: error: cannot assign to constant\n    x = x + 2;\n    ^\nIf a function argument receives as input a object whose data type is any of the primitive types that we have listed at Section 1.5 this object is always passed by value to the function. In other words, this object is copied to the function stack frame.\nHowever, if the input object have a more complex data type, for example, it might be a struct instance, or an array, or a union, etc., in cases like that, the zig compiler will take the liberty of deciding for you which strategy is best. The zig compiler will pass your object to the function either by value, or by reference. The compiler will always choose the strategy that is faster for you. This optimization that you get for free is possible only because function arguments are immutable in Zig.\nTo overcome this barrier, we need to take the lead, and explicitly choose to pass the object by reference. That is, instead of depending on the zig compiler to decide for us, we need to explicitly mark the function argument as a pointer. This way, we are telling the compiler that this function argument will be passed by reference to the function.\nBy making it a pointer, we can finally use and alter directly the value of this function argument inside the body of the add2() function. You can see that the code example below compiles successfully.\n\nconst std = @import(\"std\");\nfn add2(x: *u32) void {\n    const d: u32 = 2;\n    x.* = x.* + d;\n}\n\npub fn main() !void {\n    var x: u32 = 4;\n    add2(&x);\n    std.debug.print(\"Result: {d}\\n\", .{x});\n}\n\nResult: 6",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html#sec-structs-and-oop",
    "href": "Chapters/03-structs.html#sec-structs-and-oop",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "2.3 Structs and OOP",
    "text": "2.3 Structs and OOP\nZig is a language more closely related to C (which is a procedural language), than it is to C++ or Java (which are object-oriented languages). Because of that, you do not have advanced OOP (Object-Oriented Programming) patterns available in Zig, such as classes, interfaces or class inheritance. Nonetheless, OOP in Zig is still possible by using struct definitions.\nWith struct definitions, you can create (or define) a new data type in Zig. These struct definitions work the same way as they work in C. You give a name to this new struct (or, to this new data type you are creating), then, you list the data members of this new struct. You can also register functions inside this struct, and they become the methods of this particular struct (or data type), so that, every object that you create with this new type, will always have these methods available and associated with them.\nIn C++, when we create a new class, we normally have a constructor method (or, a constructor function) to construct or to instantiate every object of this particular class, and you also have a destructor method (or a destructor function) that is the function responsible for destroying every object of this class.\nIn Zig, we normally declare the constructor and the destructor methods of our structs, by declaring an init() and a deinit() methods inside the struct. This is just a naming convention that you will find across the entire Zig standard library. So, in Zig, the init() method of a struct is normally the constructor method of the class represented by this struct. While the deinit() method is the method used for destroying an existing instance of that struct.\nThe init() and deinit() methods are both used extensively in Zig code, and you will see both of them being used when we talk about allocators at Section 3.2. But, as another example, let‚Äôs build a simple User struct to represent an user of some sort of system. If you look at the User struct below, you can see the struct keyword, and inside of a pair of curly braces, we write the struct‚Äôs body.\nNotice the data members of this struct, id, name and email. Every data member have it‚Äôs type explicitly annotated, with the colon character (:) syntax that we described earlier at Section 1.2.2. But also notice that every line in the struct body that describes a data member, ends with a comma character (,). So every time you declare a data member in your Zig code, always end the line with a comma character, instead of ending it with the traditional semicolon character (;).\nNext, also notice in this example, that we registrated an init() function as a method of this User struct. This init() method is the constructor method that you use to instantiate every new User object. That is why this init() function return an User object as result.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst User = struct {\n    id: u64,\n    name: []const u8,\n    email: []const u8,\n\n    pub fn init(id: u64,\n                name: []const u8,\n                email: []const u8) User {\n\n        return User {\n            .id = id,\n            .name = name,\n            .email = email\n        };\n    }\n\n    pub fn print_name(self: User) !void {\n        try stdout.print(\"{s}\\n\", .{self.name});\n    }\n};\n\npub fn main() !void {\n    const u = User.init(1, \"pedro\", \"email@gmail.com\");\n    try u.print_name();\n}\n\npedro\n\n\nThe pub keyword plays an important role in struct declarations, and OOP in Zig. Every method that you declare in your struct that is marked with the keyword pub, becomes a public method of this particular struct.\nSo every method that you create in your struct, is, at first, a private method of that struct. Meaning that, this method can only be called from within this struct. But, if you mark this method as public, with the keyword pub, then, you can call the method directly from the User object you have in your code.\nIn other words, the functions marked by the keyword pub are members of the public API of that struct. For example, if I did not marked the print_name() method as public, then, I could not execute the line u.print_name(). Because I would not be authorized to call this method directly in my code.\n\n2.3.1 Anonymous struct literals\nYou can declare a struct object as a literal value. When we do that, we normally specify the data type of this struct literal by writing it‚Äôs data type just before the opening curly braces. For example, I could write a struct literal of type User that we defined in the previous section like this:\n\nconst eu = User {\n    .id = 1,\n    .name = \"Pedro\",\n    .email = \"someemail@gmail.com\"\n};\n_ = eu;\n\nHowever, in Zig, we can also write an anonymous struct literal. That is, you can write a struct literal, but not especify explicitly the type of this particular struct. An anonymous struct is written by using the syntax .{}. So, we essentially replaced the explicit type of the struct literal with a dot character (.).\nAs we described at Section 2.4, when you put a dot before a struct literal, the type of this struct literal is automatically inferred by the zig compiler. In essence, the zig compiler will look for some hint of what is the type of that struct. It can be the type annotation of an function argument, or the return type annotation of the function that you are using, or the type annotation of a variable. If the compiler do find such type annotation, then, it will use this type in your literal struct.\nAnonymous structs are very commom to use in function arguments in Zig. One example that you have seen already constantly, is the print() function from the stdout object. This function takes two arguments. The first argument, is a template string, which should contain string format specifiers in it, which tells how the values provided in the second argument should be printed into the message.\nWhile the second argument is a struct literal that lists the values to be printed into the template message specified in the first argument. You normally want to use an anonymous struct literal here, so that, the zig compiler do the job of specifying the type of this particular anonymous struct for you.\n\nconst std = @import(\"std\");\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nHello, world!\n\n\n\n\n2.3.2 Struct declarations must be constant\nTypes in Zig must be const or comptime (we are going to talk more about comptime at Section 12.1). What this means is that you cannot create a new data type, and mark it as variable with the var keyword. So struct declarations are always constant. You cannot declare a new struct using the var keyword. It must be const.\nIn the Vec3 example below, this declaration is allowed because I‚Äôm using the const keyword to declare this new data type.\n\nconst Vec3 = struct {\n    x: f64,\n    y: f64,\n    z: f64,\n};\n\n\n\n2.3.3 The self method argument\nIn every language that have OOP, when we declare a method of some class or struct, we usually declare this method as a function that have a self argument. This self argument is the reference to the object itself from which the method is being called from.\nIs not mandatory to use this self argument. But why would you not use this self argument? There is no reason to not use it. Because the only way to get access to the data stored in the data members of your struct is to access them through this self argument. If you don‚Äôt need to use the data in the data members of your struct inside your method, then, you very likely don‚Äôt need a method, you can just simply declare this logic as a simple function, outside of your struct declaration.\nTake the Vec3 struct below. Inside this Vec3 struct we declared a method named distance(). This method calculates the distance between two Vec3 objects, by following the distance formula in euclidean space. Notice that this distance() method takes two Vec3 objects as input, self and other.\n\nconst std = @import(\"std\");\nconst m = std.math;\nconst Vec3 = struct {\n    x: f64,\n    y: f64,\n    z: f64,\n\n    pub fn distance(self: Vec3, other: Vec3) f64 {\n        const xd = m.pow(f64, self.x - other.x, 2.0);\n        const yd = m.pow(f64, self.y - other.y, 2.0);\n        const zd = m.pow(f64, self.z - other.z, 2.0);\n        return m.sqrt(xd + yd + zd);\n    }\n};\n\nThe self argument corresponds to the Vec3 object from which this distance() method is being called from. While the other is a separate Vec3 object that is given as input to this method. In the example below, the self argument corresponds to the object v1, because the distance() method is being called from the v1 object, while the other argument corresponds to the object v2.\n\nconst v1 = Vec3 {\n    .x = 4.2, .y = 2.4, .z = 0.9\n};\nconst v2 = Vec3 {\n    .x = 5.1, .y = 5.6, .z = 1.6\n};\n\nstd.debug.print(\n    \"Distance: {d}\\n\",\n    .{v1.distance(v2)}\n);\n\nDistance: 3.3970575502926055\n\n\n2.3.4 About the struct state\nSometimes you don‚Äôt need to care about the state of your struct object. Sometimes, you just need to instantiate and use the objects, without altering their state. You can notice that when you have methods inside your struct declaration that might use the values that are present in the data members, but they do not alter the values in the data members of the struct in anyway.\nThe Vec3 struct that was presented at Section 2.3.3 is an example of that. This struct have a single method named distance(), and this method do use the values present in all three data members of the struct (x, y and z). But at the same time, this method do not change the values of these data members in any point.\nAs a result of that, when we create Vec3 objects we usually create them as constant objects, like the v1 and v2 objects presented at Section 2.3.3. We can create them as variable objects with the var keyword, if we want to. But because the methods of this Vec3 struct do not change the state of the objects in any point, is unnecessary to mark them as variable objects.\nBut why? Why am I talkin about this here? Is because the self argument in the methods is affected depending on whether the methods present in a struct change or not the state of the object itself. More specifically, when you have a method in a struct that changes the state of the object (i.e.¬†change the value of a data member), the self argument in this method must be annotated in a different manner.\nAs I described at Section 2.3.3, the self argument in methods of a struct is the argument that receives as input the object from which the method was called from. We usually annotate this argument in the methods by writing self, followed by the colon character (:), and the data type of the struct to which the method belongs to (e.g.¬†User, Vec3, etc.).\nIf we take the Vec3 struct that we defined in the previous section as an example, we can see in the distance() method that this self argument is annotated as self: Vec3. Because the state of the Vec3 object is never altered by this method.\nBut what if we do have a method that alters the state of the object, by altering the values of it‚Äôs data members. How should we annotate self in this instance? The answer is: ‚Äúwe should annotate self as a pointer of x, instead of just x‚Äù. In other words, you should annotate self as self: *x, instead of annotating it as self: x.\nIf we create a new method inside the Vec3 object that, for example, expands the vector by multiplying it‚Äôs coordinates by a factor o two, then, we need to follow this rule specified in the previous paragraph. The code example below demonstrates this idea:\n\nconst std = @import(\"std\");\nconst m = std.math;\nconst Vec3 = struct {\n    x: f64,\n    y: f64,\n    z: f64,\n\n    pub fn distance(self: Vec3, other: Vec3) f64 {\n        const xd = m.pow(f64, self.x - other.x, 2.0);\n        const yd = m.pow(f64, self.y - other.y, 2.0);\n        const zd = m.pow(f64, self.z - other.z, 2.0);\n        return m.sqrt(xd + yd + zd);\n    }\n\n    pub fn double(self: *Vec3) void {\n        self.x = self.x * 2.0;\n        self.y = self.y * 2.0;\n        self.z = self.z * 2.0;\n    }\n};\n\nNotice in the code example above that we have added a new method to our Vec3 struct named double(). This method essentially doubles the coordinate values of our vector object. Also notice that, in the case of the double() method, we annotated the self argument as *Vec3, indicating that this argument receives a pointer (or a reference, if you prefer to call it this way) to a Vec3 object as input.\n\nvar v3 = Vec3 {\n    .x = 4.2, .y = 2.4, .z = 0.9\n};\nv3.double();\nstd.debug.print(\"Doubled: {d}\\n\", .{v3.x});\n\nDoubled: 8.4\nNow, if you change the self argument in this double() method to self: Vec3, like in the distance() method, you will get the compiler error exposed below as result. Notice that this error message is indicating a line from the double() method body, indicating that you cannot alter the value of the x data member.\n// If we change the function signature of double to:\n    pub fn double(self: Vec3) void {\nThis error message indicates that the x data member belongs to a constant object, and, because of that, it cannot be changed. Ultimately, this error message is telling us that the self argument is constant.\nt.zig:16:13: error: cannot assign to constant\n        self.x = self.x * 2.0;\n        ~~~~^~\nIf you take some time, and think hard about this error message, you will understand it. You already have the tools to understand why we are getting this error message. We have talked about it already at Section 2.2. So remember, every function argument is immutable in Zig, and self is included in this rule.\nIt does not matter if the object that you pass as input to the function argument is a variable object or not. In this example, we marked the v3 object as a variable object. But this does not matter. Because it is not about the input object, it is about the function argument.\nThe problem begins when we try to alter the value of self directly, which is a function argument, and, every function argument is immutable by default. You may quest yourself how can we overcome this barrier, and once again, the solution was also discussed at Section 2.2. We overcome this barrier, by explicitly marking the self argument as a pointer.\n\n\n\n\n\n\nNote\n\n\n\nIf a method of your x struct alters the state of the object, by changing the value of any data member, then, remember to use self: *x, instead of self: x in the function signature of this method.\n\n\nYou could also interpret the content discussed in this section as: ‚Äúif you need to alter the state of your x struct object in one of it‚Äôs methods, you must explicitly pass the x struct object by reference to the self argument of this method‚Äù.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html#sec-type-inference",
    "href": "Chapters/03-structs.html#sec-type-inference",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "2.4 Type inference",
    "text": "2.4 Type inference\nZig is kind of a strongly typed language. I say ‚Äúkind of‚Äù because there are situations where you don‚Äôt have to explicitly write the type of every single object in your source code, as you would expect from a traditional strongly typed language, such as C and C++.\nIn some situations, the zig compiler can use type inference to solves the data types for you, easing some of the burden that you carry as a developer. The most commom way this happens is through function arguments that receives struct objects as input.\nIn general, type inference in Zig is done by using the dot character (.). Everytime you see a dot character written before a struct literal, or before a enum value, or something like that, you know that this dot character is playing a special party in this place. More specifically, it is telling the zig compiler something on the lines of: ‚ÄúHey! Can you infer the type of this value for me? Please!‚Äù. In other words, this dot character is playing a role similar to the auto keyword in C++.\nI give you some examples of this at Section 2.3.1, where we present anonymous struct literals. Anonymous struct literals are, essentially, struct literals that use type inference to infer the exact type of this particular struct literal. This type inference is done by looking for some minimal hint of the correct data type to be used. You could say that the zig compiler looks for any neighbouring type annotation that might tell him what would be the correct type.\nAnother commom place where we use type inference in Zig is at switch statements (which we talk about at Section 2.1.2). So I also gave some other examples of type inference at Section 2.1.2, where we were inferring the data types of enum values listed inside of switch statements (e.g.¬†.DE). But as another example, take a look at this fence() function reproduced below, which comes from the atomic.zig module2 of the Zig Standard Library.\nThere are a lot of things in this function that we haven‚Äôt talked about yet, such as: what comptime means? inline? extern? What is this star symbol before Self? Let‚Äôs just ignore all of these things, and focus solely on the switch statement that is inside this function.\nWe can see that this switch statement uses the order object as input. This order object is one of the inputs of this fence() function, and we can see in the type annotation, that this object is of type AtomicOrder. We can also see a bunch of values inside the switch statements that begins with a dot character, such as .release and .acquire.\nBecause these weird values contain a dot character before them, we are asking the zig compiler to infer the types of these values inside the switch statement. Then, the zig compiler is looking into the current context where these values are being used, and it is trying to infer the types of these values.\nSince they are being used inside a switch statement, the zig compiler looks into the type of the input object given to the switch statement, which is the order object in this case. Because this object have type AtomicOrder, the zig compiler infers that these values are data members from this type AtomicOrder.\n\npub inline fn fence(self: *Self, comptime order: AtomicOrder) void {\n    // LLVM's ThreadSanitizer doesn't support the normal fences so we specialize for it.\n    if (builtin.sanitize_thread) {\n        const tsan = struct {\n            extern \"c\" fn __tsan_acquire(addr: *anyopaque) void;\n            extern \"c\" fn __tsan_release(addr: *anyopaque) void;\n        };\n\n        const addr: *anyopaque = self;\n        return switch (order) {\n            .unordered, .monotonic =&gt; @compileError(@tagName(order) ++ \" only applies to atomic loads and stores\"),\n            .acquire =&gt; tsan.__tsan_acquire(addr),\n            .release =&gt; tsan.__tsan_release(addr),\n            .acq_rel, .seq_cst =&gt; {\n                tsan.__tsan_acquire(addr);\n                tsan.__tsan_release(addr);\n            },\n        };\n    }\n\n    return @fence(order);\n}\n\nThis is how basic type inference is done in Zig. If we didn‚Äôt use the dot character before the values inside this switch statement, then, we would be forced to write explicitly the data types of these values. For example, instead of writing .release we would have to write AtomicOrder.release. We would have to do this for every single value in this switch statement, and this is a lot of work. That is why type inference is commonly used on switch statements in Zig.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html#modules",
    "href": "Chapters/03-structs.html#modules",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "2.5 Modules",
    "text": "2.5 Modules\nWe already talked about what modules are, and also, how to import other modules into you current module through import statements, so that you can use functionality from these other modules in your current module. But in this section, I just want to make it clear that modules are actually structs in Zig.\nIn other words, every Zig module (i.e.¬†a .zig file) that you write in your project is internally stored as a struct object. Take the line exposed below as an example. In this line we are importing the Zig Standard Library into our current module.\nconst std = @import(\"std\");\nWhen we want to access the functions and objects from the standard library, we are basically accessing the data members of the struct stored in the std object. That is why we use the same syntax that we use in normal structs, with the dot operator (.) to access the data members and methods of the struct.\nWhen this ‚Äúimport statement‚Äù get‚Äôs executed, the result of this expression is a struct object that contains the Zig Standard Library modules, global variables, functions, etc. And this struct object get‚Äôs saved (or stored) inside the constant object named std.\nTake the thread_pool.zig module from the project zap3 as an example. This module is written as if it was a big struct. That is why we have a top-level and public init() method written in this module. The idea is that all top-level functions written in this module are methods from the struct, and all top-level objects and struct declarations are data members of this struct. The module is the struct itself.\nSo you would import and use this module by doing something like this:\nconst std = @import(\"std\");\nconst ThreadPool = @import(\"thread_pool.zig\");\nconst num_cpus = std.Thread.getCpuCount()\n    catch @panic(\"failed to get cpu core count\");\nconst num_threads = std.math.cast(u16, num_cpus)\n    catch std.math.maxInt(u16);\nconst pool = ThreadPool.init(\n    .{ .max_threads = num_threads }\n);",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/03-structs.html#footnotes",
    "href": "Chapters/03-structs.html#footnotes",
    "title": "2¬† Structs, Modules and Control Flow",
    "section": "",
    "text": "https://github.com/ziglang/zig/blob/master/lib/std/debug.zig‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/atomic.zig.‚Ü©Ô∏é\nhttps://github.com/kprotty/zap/blob/blog/src/thread_pool.zig‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Structs, Modules and Control Flow</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html",
    "href": "Chapters/01-memory.html",
    "title": "3¬† Memory and Allocators",
    "section": "",
    "text": "3.1 Memory spaces\nEvery object that you create in your Zig source code needs to be stored somewhere, in your computer‚Äôs memory. Depending on where and how you define your object, Zig will use a different ‚Äúmemory space‚Äù, or a different type of memory to store this object.\nEach type of memory normally serves for different purposes. In Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#memory-spaces",
    "href": "Chapters/01-memory.html#memory-spaces",
    "title": "3¬† Memory and Allocators",
    "section": "",
    "text": "Global data register (or the ‚Äúglobal data section‚Äù);\nStack;\nHeap;\n\n\n3.1.1 Compile-time known versus runtime known\nOne strategy that Zig uses to decide where it will store each object that you declare, is by looking at the value of this particular object. More specifically, by investigating if this value is known at ‚Äúcompile-time‚Äù or at ‚Äúruntime‚Äù.\nWhen you write a program in Zig, the values of some of the objects that you write in your program are known at compile time. Meaning that, when you compile your Zig source code, during the compilation process, the zig compiler can figure it out what is the exact value of a particular object that exists in your source code. Knowing the length (or the size) of each object is also important. So the length (or the size) of each object that you write in your program is, in some cases, known at compile time.\nThe zig compiler cares more about knowing the length (or the size) of a particular object , than to know it‚Äôs actual value. But, if the zig compiler knows the value of the object, then, it automatically knows the size of this object. Because it can simply calculate the size of the object by looking at the size of the value.\nTherefore, the priority for the zig compiler is to discover the size of each object in your source code. If the value of the object in question is known at compile-time, then, the zig compiler automatically knows the size/length of this object. But if the value of this object is not known at compile-time, then, the size of this object is only known at compile-time if, and only if, the type of this object have a known fixed size.\nIn order to a type have a known fixed size, this type must have data members whose size is fixed. If this type includes, for example, a variable sized array in it, then, this type do not have a known fixed size. Because this array can have any size at runtime (i.e.¬†it can be an array of 2 elements, or 50 elements, or 1 thousand elements, etc.).\nFor example, a string object, which internally is an array of constant u8 values ([]const u8) have a variable size. It can be a string object with 100 or 500 characters in it. If we do not know at compile-time, which exact string will be stored inside this string object, then, we cannot calculate the size of this string object at compile-time. So, any type, or any struct declaration that you make, that includes a string data member that do not have an explicit fixed size, makes this type, or this new struct that you are declaring, a type that do not have a known fixed size at compile-time.\nIn contrast, if the type or this struct that you are declaring, includes a data member that is an array, but this array have a known fixed size, like [60]u8 (which declares an array of 60 u8 values), then, this type, or, this struct that you are declaring, becomes a type with a known fixed size at compile-time. And because of that, in this case, the zig compiler do not need to known at compile-time the exact value of any object of this type. Since the compiler can find the necessary size to store this object by looking at the size of it‚Äôs type.\nLet‚Äôs look at an example. In the source code below, we have two constant objects (name and array) declared. Because the values of these particular objects are written down, in the source code itself (\"Pedro\" and the number sequence from 1 to 4), the zig compiler can easily discover the values of these constant objects (name and array) during the compilation process. This is what ‚Äúknown at compile time‚Äù means. It refers to any object that you have in your Zig source code whose value can be identified at compile time.\n\nconst name = \"Pedro\";\nconst array = [_]u8{1, 2, 3, 4};\n_ = name; _ = array;\n\nfn input_length(input: []const u8) usize {\n    const n = input.len;\n    return n;\n}\n\nThe other side of the spectrum are objects whose values are not known at compile time. Function arguments are a classic example of this. Because the value of each function argument depends on the value that you assign to this particular argument, when you call the function.\nFor example, the function input_length() contains an argument named input, which is an array of constant u8 integers ([]const u8). Is impossible to know at compile time the value of this particular argument. And it also is impossible to know the size/length of this particular argument. Because it is an array that do not have a fixed size specified explicitly in the argument type annotation.\nSo, we know that this input argument will be an array of u8 integers. But we do not know at compile-time, it‚Äôs value, and neither his size. This information is known only at runtime, which is the period of time when you program is executed. As a consequence, the value of the expression input.len is also known only at runtime. This is an intrinsic characteristic of any function. Just remember that the value of function arguments is usually not ‚Äúcompile-time known‚Äù.\nHowever, as I mentioned earlier, what really matters to the compiler is to know the size of the object at compile-time, and not necessarily it‚Äôs value. So, although we don‚Äôt know the value of the object n, which is the result of the expression input.len, at compile-time, we do know it‚Äôs size. Because the expression input.len always return a value of type usize, and the type usize have a known fixed size.\n\n\n3.1.2 Global data register\nThe global data register is a specific section of the executable of your Zig program, that is responsible for storing any value that is known at compile time.\nEvery constant object whose value is known at compile time that you declare in your source code, is stored in the global data register. Also, every literal value that you write in your source code, such as the string \"this is a string\", or the integer 10, or a boolean value such as true, is also stored in the global data register.\nHonestly, you don‚Äôt need to care much about this memory space. Because you can‚Äôt control it, you can‚Äôt deliberately access it or use it for your own purposes. Also, this memory space does not affect the logic of your program. It simply exists in your program.\n\n\n3.1.3 Stack vs Heap\nIf you are familiar with system‚Äôs programming, or just low-level programming in general, you probably have heard of the ‚Äúduel‚Äù between Stack vs Heap. These are two different types of memory, or different memory spaces, which are both available in Zig.\nThese two types of memory don‚Äôt actually duel with each other. This is a commom mistake that beginners have, when seeing ‚Äúx vs y‚Äù styles of tabloid headlines. These two types of memory are actually complementary to each other. So, in almost every Zig program that you ever write, you will likely use a combination of both. I will describe each memory space in detail over the next sections. But for now, I just want to stablish the main difference between these two types of memory.\nIn essence, the stack memory is normally used to store values whose length is fixed and known at compile time. In contrast, the heap memory is a dynamic type of memory space, meaning that, it is used to store values whose length might grow during the execution (runtime) of your program (Chen and Guo 2022).\nLengths that grow during runtime are intrinsically associated with ‚Äúruntime known‚Äù type of values. In other words, if you have an object whose length might grow during runtime, then, the length of this object becomes not known at compile time. If the length is not known at compile-time, the value of this object also becomes not known at compile-time. These types of objects should be stored in the heap memory space, which is a dynamic memory space, which can grow or shrink to fit the size of your objects.\n\n\n3.1.4 Stack\nThe stack is a type of memory that uses the power of the stack data structure, hence the name. A ‚Äústack‚Äù is a type of data structure that uses a ‚Äúlast in, first out‚Äù (LIFO) mechanism to store the values you give it to. I imagine you are familiar with this data structure. But, if you are not, the Wikipedia page1 , or, the Geeks For Geeks page2 are both excellent and easy resources to fully understand how this data structure works.\nSo, the stack memory space is a type of memory that stores values using a stack data structure. It adds and removes values from the memory by following a ‚Äúlast in, first out‚Äù (LIFO) principle.\nEvery time you make a function call in Zig, an amount of space in the stack is reserved for this particular function call (Chen and Guo 2022; Zig Software Foundation 2024). The value of each function argument given to the function in this function call is stored in this stack space. Also, every local object that you declare inside the function scope is usually stored in this same stack space.\nLooking at the example below, the object result is a local object declared inside the scope of the add() function. Because of that, this object is stored inside the stack space reserved for the add() function. The r object (which is declared outside of the add() function scope) is also stored in the stack. But since it is declared in the ‚Äúouter‚Äù scope, this object is stored in the stack space that belongs to this outer scope.\n\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) u8 {\n    const result = x + y;\n    return result;\n}\n\nSo, any object that you declare inside the scope of a function is always stored inside the space that was reserved for that particular function in the stack memory. This also counts for any object declared inside the scope of your main() function for example. As you would expect, in this case, they are stored inside the stack space reserved for the main() function.\nOne very important detail about the stack memory is that it frees itself automatically. This is very important, remember that. When objects are stored in the stack memory, you don‚Äôt have the work (or the responsibility) of freeing/destroying these objects. Because they will be automatically destroyed once the stack space is freed at the end of the function scope.\nSo, once the function call returns (or ends, if you prefer to call it this way) the space that was reserved in the stack is destroyed, and all of the objects that were in that space goes away with it. This mechanism exists because this space, and the objects within it, are not necessary anymore, since the function ‚Äúfinished it‚Äôs business‚Äù. Using the add() function that we exposed above as an example, it means that the object result is automatically destroyed once the function returns.\n\n\n\n\n\n\nImportant\n\n\n\nLocal objects that are stored in the stack space of a function are automatically freed/destroyed at the end of the function scope.\n\n\nThis same logic applies to any other special structure in Zig that have it‚Äôs own scope by surrounding it with curly braces ({}). For loops, while loops, if else statements, etc. For example, if you declare any local object in the scope of a for loop, this local object is accessible only within the scope of this particular for loop. Because once the scope of this for loop ends, the space in the stack reserved for this for loop is freed. The example below demonstrates this idea.\n\n// This does not compile succesfully!\nconst a = [_]u8{0, 1, 2, 3, 4};\nfor (0..a.len) |i| {\n    const index = i;\n    _ = index;\n}\n// Trying to use an object that was\n// declared in the for loop scope,\n// and that does not exist anymore.\nstd.debug.print(\"{d}\\n\", index);\n\nOne important consequence of this mechanism is that, once the function returns, you can no longer access any memory address that was inside the space in the stack reserved for this particular function. Because this space was destroyed. This means that, if this local object is stored in the stack, you cannot make a function that returns a pointer to this object.\nThink about that for a second. If all local objects in the stack are destroyed at the end of the function scope, why would you even consider returning a pointer to one of these objects? This pointer is at best, invalid, or, more likely, ‚Äúundefined‚Äù.\nConclusion, is totally fine to write a function that returns the local object itself as result, because then, you return the value of that object as the result. But, if this local object is stored in the stack, you should never write a function that returns a pointer to this local object. Because the memory address pointed by the pointer no longer exists.\nSo, using again the add() function as an example, if you rewrite this function so that it returns a pointer to the local object result, the zig compiler will actually compile you program, with no warnings or erros. At first glance, it looks that this is good code that works as expected. But this is a lie!\nIf you try to take a look at the value inside of the r object, or, if you try to use this r object in another expression or function call, then, you would have undefined behaviour, and major bugs in your program (Zig Software Foundation 2024, see ‚ÄúLifetime and Ownership‚Äù3 and ‚ÄúUndefined Behaviour‚Äù4 sections).\n\n// This code compiles succesfully. But it has\n// undefined behaviour. Never do this!!!\n\n// The `r` object is undefined!\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) *const u8 {\n    const result = x + y;\n    return &result;\n}\n\nThis ‚Äúinvalid pointer to stack variable‚Äù problem is very known across many programming language communities. If you try to do the same thing, for example, in a C or C++ program (i.e.¬†returning an address to a local object stored in the stack), you would also get undefined behaviour in the program.\n\n\n\n\n\n\nImportant\n\n\n\nIf a local object in your function is stored in the stack, you should never return a pointer to this local object from the function. Because this pointer will always become undefined after the function returns, since the stack space of the function is destroyed at the end of it‚Äôs scope.\n\n\nBut what if you really need to use this local object in some way after your function returns? How can you do this? The answer is: ‚Äúin the same you would do if this was a C or C++ program. By returning an address to an object stored in the heap‚Äù. The heap memory have a much more flexible lifecycle, and allows you to get a valid pointer to a local object of a function that already returned from it‚Äôs scope.\n\n\n3.1.5 Heap\nOne important limitation of the stack, is that, only objects whose length/size is known at compile-time can be stored in it. In contrast, the heap is a much more dynamic (and flexible) type of memory. It is the perfect type of memory to use on objects whose size/length might grow during the execution of your program.\nVirtually any application that behaves as a server is a classic use case of the heap. A HTTP server, a SSH server, a DNS server, a LSP server, ‚Ä¶ any type of server. In summary, a server is a type of application that runs for long periods of time, and that serves (or ‚Äúdeals with‚Äù) any incoming request that reaches this particular server.\nThe heap is a good choice for this type of system, mainly because the server does not know upfront how many requests it will receive from users, while it is active. It could be one single request, or, 5 thousand requests, or, it could also be zero requests. The server needs to have the ability to allocate and manage it‚Äôs memory according to how many requests it receives.\nAnother key difference between the stack and the heap, is that the heap is a type of memory that you, the programmer, have complete control over. This makes the heap a more flexible type of memory, but it also makes it harder to work with it. Because you, the programmer, is responsible for managing everything related to it. Including where the memory is allocated, how much memory is allocated, and where this memory is freed.\n\nUnlike stack memory, heap memory is allocated explicitly by programmers and it won‚Äôt be deallocated until it is explicitly freed (Chen and Guo 2022).\n\nTo store an object in the heap, you, the programmer, needs to explicitly tells Zig to do so, by using an allocator to allocate some space in the heap. At Section 3.2, I will present how you can use allocators to allocate memory in Zig.\n\n\n\n\n\n\nImportant\n\n\n\nEvery memory you allocate in the heap needs to be explicitly freed by you, the programmer.\n\n\nThe majority of allocators in Zig do allocate memory on the heap. But some exceptions to this rule are ArenaAllocator() and FixedBufferAllocator(). The ArenaAllocator() is a special type of allocator that works in conjunction with a second type of allocator. On the other side, the FixedBufferAllocator() is an allocator that works based on buffer objects created on the stack. This means that the FixedBufferAllocator() makes allocations only on the stack.\n\n\n3.1.6 Summary\nAfter discussing all of these boring details, we can quickly recap what we learned. In summary, the Zig compiler will use the following rules to decide where each object you declare is stored:\n\nevery literal value (such as \"this is string\", 10, or true) is stored in the global data section.\nevery constant object (const) whose value is known at compile-time is also stored in the global data section.\nevery object (constant or not) whose length/size is known at compile time is stored in the stack space for the current scope.\nif an object is created with the method alloc() or create() of an allocator object, this object is stored in the memory space used by this particular allocator object. Most of allocators available in Zig use the heap memory, so, this object is likely stored in the heap (FixedBufferAllocator() is an exception to that).\nthe heap can only be accessed through allocators. If your object was not created through the alloc() or create() methods of an allocator object, then, he is most certainly not an object stored in the heap.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#sec-allocators",
    "href": "Chapters/01-memory.html#sec-allocators",
    "title": "3¬† Memory and Allocators",
    "section": "3.2 Allocators",
    "text": "3.2 Allocators\nOne key aspect about Zig, is that there are ‚Äúno hidden-memory allocations‚Äù in Zig. What that really means, is that ‚Äúno allocations happen behind your back in the standard library‚Äù (Sobeston 2024).\nThis is a known problem, specially in C++. Because in C++, there are some operators that do allocate memory behind the scene, and there is no way for you to known that, until you actually read the source code of these operators, and find the memory allocation calls. Many programmers find this behaviour annoying and hard to keep track of.\nBut, in Zig, if a function, an operator, or anything from the standard library needs to allocate some memory during it‚Äôs execution, then, this function/operator needs to receive (as input) an allocator provided by the user, to actually be able to allocate the memory it needs.\nThis creates a clear distinction between functions that ‚Äúdo not‚Äù from those that ‚Äúactually do‚Äù allocate memory. Just look at the arguments of this function. If a function, or operator, have an allocator object as one of it‚Äôs inputs/arguments, then, you know for sure that this function/operator will allocate some memory during it‚Äôs execution.\nAn example is the allocPrint() function from the Zig standard library. With this function, you can write a new string using format specifiers. So, this function is, for example, very similar to the function sprintf() in C. In order to write such new string, the allocPrint() function needs to allocate some memory to store the output string.\nThat is why, the first argument of this function is an allocator object that you, the user/programmer, gives as input to the function. In the example below, I am using the GeneralPurposeAllocator() as my allocator object. But I could easily use any other type of allocator object from the Zig standard library.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nconst name = \"Pedro\";\nconst output = try std.fmt.allocPrint(\n    allocator,\n    \"Hello {s}!!!\",\n    .{name}\n);\ntry stdout.print(\"{s}\\n\", .{output});\n\nHello Pedro!!!\n\n\nYou get a lot of control over where and how much memory this function can allocate. Because it is you, the user/programmer, that provides the allocator for the function to use. This makes ‚Äútotal control‚Äù over memory management easier to achieve in Zig.\n\n3.2.1 What are allocators?\nAllocators in Zig are objects that you can use to allocate memory for your program. They are similar to the memory allocating functions in C, like malloc() and calloc(). So, if you need to use more memory than you initially have, during the execution of your program, you can simply ask for more memory using an allocator.\nZig offers different types of allocators, and they are usually available through the std.heap module of the standard library. So, just import the Zig standard library into your Zig module (with @import(\"std\")), and you can start using these allocators in your code.\nFurthermore, every allocator object is built on top of the Allocator interface in Zig. This means that, every allocator object you find in Zig must have the methods alloc(), create(), free() and destroy(). So, you can change the type of allocator you are using, but you don‚Äôt need to change the function calls to the methods that do the memory allocation (and the free memory operations) for your program.\n\n\n3.2.2 Why you need an allocator?\nAs we described at Section 3.1.4, everytime you make a function call in Zig, a space in the stack is reserved for this function call. But the stack have a key limitation which is: every object stored in the stack have a known fixed length.\nBut in reality, there are two very commom instances where this ‚Äúfixed length limitation‚Äù of the stack is a deal braker:\n\nthe objects that you create inside your function might grow in size during the execution of the function.\nsometimes, it is impossible to know upfront how many inputs you will receive, or how big this input will be.\n\nAlso, there is another instance where you might want to use an allocator, which is when you want to write a function that returns a pointer to a local object. As I described at Section 3.1.4, you cannot do that if this local object is stored in the stack. However, if this object is stored in the heap, then, you can return a pointer to this object at the end of the function. Because you (the programmer) control the lyfetime of any heap memory that you allocate. You decide when this memory get‚Äôs destroyed/freed.\nThese are commom situations where the stack is not good for. That is why you need a different memory management strategy to store these objects inside your function. You need to use a memory type that can grow together with your objects, or that you can control the lyfetime of this memory. The heap fit this description.\nAllocating memory on the heap is commonly known as dynamic memory management. As the objects you create grow in size during the execution of your program, you grow the amount of memory you have by allocating more memory in the heap to store these objects. And you that in Zig, by using an allocator object.\n\n\n3.2.3 The different types of allocators\nAt the moment of the writing of this book, in Zig, we have 6 different allocators available in the standard library:\n\nGeneralPurposeAllocator().\npage_allocator().\nFixedBufferAllocator() and ThreadSafeFixedBufferAllocator().\nArenaAllocator().\nc_allocator() (requires you to link to libc).\n\nEach allocator have it‚Äôs own perks and limitations. All allocators, except FixedBufferAllocator() and ArenaAllocator(), are allocators that use the heap memory. So any memory that you allocate with these allocators, will be placed in the heap.\n\n\n3.2.4 General-purpose allocators\nThe GeneralPurposeAllocator(), as the name suggests, is a ‚Äúgeneral purpose‚Äù allocator. You can use it for every type of task. In the example below, I‚Äôm allocating enough space to store a single integer in the object some_number.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const some_number = try allocator.create(u32);\n    defer allocator.destroy(some_number);\n\n    some_number.* = @as(u32, 45);\n}\n\nWhile useful, you might want to use the c_allocator(), which is a alias to the C standard allocator malloc(). So, yes, you can use malloc() in Zig if you want to. Just use the c_allocator() from the Zig standard library. However, if you do use c_allocator(), you must link to Libc when compiling your source code with the zig compiler, by including the flag -lc in your compilation process. If you do not link your source code to Libc, Zig will not be able to find the malloc() implementation in your system.\n\n\n3.2.5 Page allocator\nThe page_allocator() is an allocator that allocates full pages of memory in the heap. In other words, every time you allocate memory with page_allocator(), a full page of memory in the heap is allocated, instead of just a small piece of it.\nThe size of this page depends on the system you are using. Most systems use a page size of 4KB in the heap, so, that is the amount of memory that is normally allocated in each call by page_allocator(). That is why, page_allocator() is considered a fast, but also ‚Äúwasteful‚Äù allocator in Zig. Because it allocates a big amount of memory in each call, and you most likely will not need that much memory in your program.\n\n\n3.2.6 Buffer allocators\nThe FixedBufferAllocator() and ThreadSafeFixedBufferAllocator() are allocator objects that work with a fixed sized buffer that is stored in the stack. So these two allocators only allocates memory in the stack. This also means that, in order to use these allocators, you must first create a buffer object, and then, give this buffer as an input to these allocators.\nIn the example below, I am creating a buffer object that is 10 elements long. Notice that I give this buffer object to the FixedBufferAllocator() constructor. Now, because this buffer object is 10 elements long, this means that I am limited to this space. I cannot allocate more than 10 elements with this allocator object. If I try to allocate more than that, the alloc() method will return an OutOfMemory error value.\n\nvar buffer: [10]u8 = undefined;\nfor (0..buffer.len) |i| {\n    buffer[i] = 0; // Initialize to zero\n}\n\nvar fba = std.heap.FixedBufferAllocator.init(&buffer);\nconst allocator = fba.allocator();\nconst input = try allocator.alloc(u8, 5);\ndefer allocator.free(input);\n\n\n\n3.2.7 Arena allocator\nThe ArenaAllocator() is an allocator object that takes a child allocator as input. The idea behind the ArenaAllocator() in Zig is similar to the concept of ‚Äúarenas‚Äù in the programming language Go5. It is an allocator object that allows you to allocate memory as many times you want, but free all memory only once. In other words, if you have, for example, called 5 times the method alloc() of an ArenaAllocator() object, you can free all the memory you allocated over these 5 calls at once, by simply calling the deinit() method of the same ArenaAllocator() object.\nIf you give, for example, a GeneralPurposeAllocator() object as input to the ArenaAllocator() constructor, like in the example below, then, the allocations you perform with alloc() will actually be made with the underlying object GeneralPurposeAllocator() that was passed. So, with an arena allocator, any new memory you ask for is allocated by the child allocator. The only thing that an arena allocator really do is helping you to free all the memory you allocated multiple times with just a single command. In the example below, I called alloc() 3 times. So, if I did not used an arena allocator, then, I would need to call free() 3 times to free all the allocated memory.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar aa = std.heap.ArenaAllocator.init(gpa.allocator());\ndefer aa.deinit();\nconst allocator = aa.allocator();\n\nconst in1 = allocator.alloc(u8, 5);\nconst in2 = allocator.alloc(u8, 10);\nconst in3 = allocator.alloc(u8, 15);\n_ = in1; _ = in2; _ = in3;\n\n\n\n3.2.8 The alloc() and free() methods\nIn the code example below, we are accessing the stdin, which is the standard input channel, to receive an input from the user. We read the input given by the user with the readUntilDelimiterOrEof() method.\nNow, after reading the input of the user, we need to store this input somewhere in our program. That is why I use an allocator in this example. I use it to allocate some amount of memory to store this input given by the user. More specifically, the method alloc() of the allocator object is used to allocate an array capable of storing 50 u8 values.\nNotice that this alloc() method receives two inputs. The first one, is a type. This defines what type of values the allocated array will store. In the example below, we are allocating an array of unsigned 8-bit integers (u8). But you can create an array to store any type of value you want. Next, on the second argument, we define the size of the allocated array, by specifying how much elements this array will contain. In the case below, we are allocating an array of 50 elements.\nAt Section 1.8 we described that strings in Zig are simply arrays of characters. Each character is represented by an u8 value. So, this means that the array that was allocated in the object input is capable of storing a string that is 50-characters long.\nSo, in essence, the expression var input: [50]u8 = undefined would create an array for 50 u8 values in the stack of the current scope. But, you can allocate the same array in the heap by using the expression var input = try allocator.alloc(u8, 50).\n\nconst std = @import(\"std\");\nconst stdin = std.io.getStdIn();\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var input = try allocator.alloc(u8, 50);\n    defer allocator.free(input);\n    for (0..input.len) |i| {\n        input[i] = 0; // initialize all fields to zero.\n    }\n    // read user input\n    const input_reader = stdin.reader();\n    _ = try input_reader.readUntilDelimiterOrEof(\n        input,\n        '\\n'\n    );\n    std.debug.print(\"{s}\\n\", .{input});\n}\n\nAlso, notice that in this example, we use the defer keyword (which I described at Section 2.1.3) to run a small piece of code at the end of the current scope, which is the expression allocator.free(input). When you execute this expression, the allocator will free the memory that it allocated for the input object.\nWe have talked about this at Section 3.1.5. You should always explicitly free any memory that you allocate using an allocator! You do that by using the free() method of the same allocator object you used to allocate this memory. The defer keyword is used in this example only to help us execute this free operation at the end of the current scope.\n\n\n3.2.9 The create() and destroy() methods\nWith the alloc() and free() methods, you can allocate memory to store multiple elements at once. In other words, with these methods, we always allocate an array to store multiple elements at once. But what if you need enough space to store just a single item? Should you allocate an array of a single element through alloc()?\nThe answer is no! In this case, you should use the create() method of the allocator object. Every allocator object offers the create() and destroy() methods, which are used to allocate and free memory for a single item, respectively.\nSo, in essence, if you want to allocate memory to store an array of elements, you should use alloc() and free(). But if you need to store just a single item, then, the create() and destroy() methods are ideal for you.\nIn the example below, I‚Äôm defining a struct to represent an user of some sort. It could be an user for a game, or a software to manage resources, it doesn‚Äôt mater. Notice that I use the create() method this time, to store a single User object in the program. Also notice that I use the destroy() method to free the memory used by this object at the end of the scope.\n\nconst std = @import(\"std\");\nconst User = struct {\n    id: usize,\n    name: []const u8,\n\n    pub fn init(id: usize, name: []const u8) User {\n        return .{ .id = id, .name = name };\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const user = try allocator.create(User);\n    defer allocator.destroy(user);\n\n    user.* = User.init(0, \"Pedro\");\n}\n\n\n\n\n\nChen, Jenny, and Ruohao Guo. 2022. ‚ÄúStack and Heap Memory.‚Äù Introduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nSobeston. 2024. ‚ÄúZig Guide.‚Äù https://zig.guide/.\n\n\nZig Software Foundation. 2024. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#footnotes",
    "href": "Chapters/01-memory.html#footnotes",
    "title": "3¬† Memory and Allocators",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)‚Ü©Ô∏é\nhttps://www.geeksforgeeks.org/stack-data-structure/‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/#Lifetime-and-Ownership‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/#Undefined-Behavior‚Ü©Ô∏é\nhttps://go.dev/src/arena/arena.go‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html",
    "href": "Chapters/01-base64.html",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "",
    "text": "4.1 How the base64 algorithm work?\nNow, how exactly the algorithm behind the base64 encoding works? Let‚Äôs discuss that. First, I will explain the base64 scale, which is the scale of 64 characters that represents the base64 encoding system.\nAfter that, I explain the algorithm behind a base64 encoder, which is the part of the algorithm that is responsible for encoding messages into the base64 encoding system. Then, after that, I explain the algorithm behind a base64 decoder, which is the part of the algorithm that is responsible for translating base64 messages back into their original meaning.\nIf you are unsure about the differences between an ‚Äúencoder‚Äù and a ‚Äúdecoder‚Äù, take a look at Section 4.2.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "href": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "",
    "text": "4.1.1 The base64 scale\nIn essence, the base64 encoding system is based on a scale that goes from 0 to 64 (hence the name). Each index in this scale is represented by a character (it is a scale of 64 characters). So, in order to convert some binary data, to the base64 encoding, we need to convert each binary number to the corresponding character in this ‚Äúscale of 64 characters‚Äù.\nThe base64 scale starts with all ASCII uppercase letters (A to Z) which represents the first 25 indexes in this scale (0 to 25). After that, we have all ASCII lowercase letters (a to z), which represents the range 26 to 51 in the scale. After that, we have the one digit numbers (0 to 9), which represents the indexes from 52 to 61 in the scale. Finally, the last two indexes in the scale (62 and 63) are represented by the characters + and /, respectively.\nThese are the 64 characters that compose the base64 scale. The equal sign character (=) is not part of the scale itself, but it is a special character in the base64 encoding system. This character is used solely as a suffix, to mark the end of the character sequence, or, to mark the end of meaningful characters in the sequence.\nThe bulletpoints below summarises the base64 scale:\n\nrange 0 to 25 is represented by: ASCII uppercase letters -&gt; [A-Z];\nrange 26 to 51 is represented by: ASCII lowercase letters -&gt; [a-z];\nrange 52 to 61 is represented by: one digit numbers -&gt; [0-9];\nindex 62 and 63 are represented by the characters + and /, respectively;\nthe character = represents the end of meaningful characters in the sequence;\n\n\n\n4.1.2 Creating the scale as a lookup table\nThe best way to represent this scale in code, is to represent it as a lookup table. Lookup tables are a classic strategy in computer science to speed calculations. The basic idea is to replace a runtime calculation (which can take a long time to be done) by a basic array indexing operation.\nInstead of calculating the results everytime you need them, you calculate all possible results at once, and then, you store them in an array (which behaves lake a ‚Äútable‚Äù). Then, every time that you need to use one of the characters in the base64 scale, instead of using many resources to calculate the exact character to be used, you simply retrieve this character from the array where you stored all the possible characters in the base64 scale. So we retrieve the character that we need directly from memory.\nWe can start building a Zig struct to store our base64 decoder/encoder logic. We start with the Base64 struct below. You can see that, for now, we only have one single data member in this struct, i.e.¬†the member _table, which represents our lookup table. We also have an init() method, to create a new instance of a Base64 object, and, a _char_at() method, which is a ‚Äúget chat at index ‚Ä¶‚Äù type of function.\n\nconst Base64 = struct {\n    _table: *const [64]u8,\n\n    pub fn init() Base64 {\n        const upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        const lower = \"abcdefghijklmnopqrstuvwxyz\";\n        const numbers_symb = \"0123456789+/\";\n        return Base64{\n            ._table = upper ++ lower ++ numbers_symb,\n        };\n    }\n\n    pub fn _char_at(self: Base64, index: u8) u8 {\n        return self._table[index];\n    }\n};\n\nIn other words, the _char_at() method is responsible for getting the character in the lookup table (i.e.¬†the _table struct data member) that corresponds to a particular index in the ‚Äúbase64 scale‚Äù. So, in the example below, we know that the character that corresponds to the index 28 in the ‚Äúbase64 scale‚Äù is the character ‚Äúc‚Äù.\n\nconst base64 = Base64.init();\ntry stdout.print(\n    \"Character at 28 index: {c}\\n\",\n    .{base64._char_at(28)}\n);\n\nCharacter at 28 index: c\n\n\n4.1.3 A base64 encoder\nThe algorithm behind a base64 encoder usually works on a window of 3 bytes. Because each byte have 8 bits, so, 3 bytes forms a set of \\(8 \\times 3 = 24\\) bits. This is desirable for the base64 algorithm, because 24 bits is divisble by 6, which form a set of 4 groups of 6 bits each.\nSo the base64 algorithm works by converting 3 bytes at a time into 4 characters in the base64 scale. It keeps iterating through the input string, 3 bytes at a time, and converting them into the base64 scale, producing 4 characters per iteration. It keeps iterating, and producing these ‚Äúnew characters‚Äù until it hits the end of the input string.\nNow you may think, what if you have a particular string that have a number of bytes that is not divisible by 3? What happens? For example, if you have a string that contains only two characters/bytes, such as ‚ÄúHi‚Äù. How the algorithm would behave in such situation? You find the answer at Figure¬†4.1. You can see at Figure¬†4.1 that the string ‚ÄúHi‚Äù, when converted to base64, becomes the string ‚ÄúSGk=‚Äù:\n\n\n\n\n\n\nFigure¬†4.1: The logic behind a base64 encoder\n\n\n\nTaking the string ‚ÄúHi‚Äù as an example, we have 2 bytes, or, 16 bits in total. So, we lack a full byte (8 bits) to complete the window of 24 bits that the base64 algorithm likes to work on. The first thing that the algorithm does, is to check how to divide the input bytes into groups of 6 bits.\nIf the algorithm notice that there is a group of 6 bits that, have some bits in it, but, at the same time, it is not full (in other words, \\(0 &lt; nbits &lt; 6\\), being \\(nbits\\) the number of bits), meaning that, it lacks some bits to fill the 6-bits requirement, the algorithm simply add extra zeros in this group to fill the space that it needs. That is why at Figure¬†4.1, on the third group after the 6-bit transformation, 2 extra zeros were added to fill the gap in this group.\nSo, when we have a 6-bit group that is not completely full, like the third group, extra zeros are added to fill the gap. But what about when an entire 6-bit group is empty, or, it simply doesn‚Äôt exist? This is the case of the fourth 6-bit group exposed at Figure¬†4.1.\nThis fourth group is necessary, because the algorithm works on 4 groups of 6 bits. But the input string does not have enough bytes to create a fourth 6-bit group. Every time that this happens, where a entire group of 6 bits is empty, this group becomes a ‚Äúpadding group‚Äù. Every ‚Äúpadding group‚Äù is mapped to the character = (equal sign), which represents ‚Äúnull‚Äù, or, the end of meaninful characters in the sequence. Hence, everytime that the algorithm produces a ‚Äúpadding group‚Äù, this group is mapped to =.\nAs another example, if you give the string ‚Äú0‚Äù as input to a base64 encoder, this string is translated into the base64 sequence ‚ÄúMA==‚Äù. The character ‚Äú0‚Äù is, in binary, the sequence 001100001. So, with the 6-bit transformation exposed at Figure¬†4.1, this single character would produce these two 6-bit groups: 001100, 000000. The remaining two 6-bit groups become ‚Äúpadding groups‚Äù. That is why the last two characters in the output sequence (MA==) are ==.\n\n\n4.1.4 A base64 decoder\nThe algorithm behind a base64 decoder is essentially the inverse process of a base64 encoder. A base64 decoder needs to be able to translate base64 messages back into their original meaning, i.e.¬†into the original sequence of binary data.\nA base64 decoder usually works on a window of 4 bytes. Because it wants to convert these 4 bytes back into the original sequence of 3 bytes, that was converted into 4 groups of 6 bits by the base64 encoder. Remember, in a base64 decoder we are essentially reverting the process made by the base64 encoder.\nEach byte in the input string (the base64 encoded string) normally contributes to re-create two different bytes in the output (the original binary data). In other words, each byte that comes out of a base64 decoder is created by transforming merging two different bytes in the input together. You can see this fact at Figure¬†4.2:\n\n\n\n\n\n\nFigure¬†4.2: The logic behind a base64 decoder\n\n\n\nThe exact transformations, or, the exact steps applied to each byte from the input to transform them into the bytes in the output, are a bit tricky to visualize in a figure like this. Because of that, I summarized these transformations as ‚ÄúSome bit shifting and additions ‚Ä¶‚Äù. These transformations will be described in depth later.\nBesides that, if you look again at Figure¬†4.2, you will notice that the character = was completly ignored in the algorithm. Remember, this is just a special character that marks the end of meaninful characters in the base64 sequence. So, every = character in a base64 encoded sequence should be ignored.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encode-vs-decode",
    "href": "Chapters/01-base64.html#sec-encode-vs-decode",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "4.2 Difference between encode and decode",
    "text": "4.2 Difference between encode and decode\nIf you don‚Äôt have any previous experience with base64, you might be confused about what is the differente between ‚Äúencode‚Äù and ‚Äúdecode‚Äù. Essentially, the terms ‚Äúencode‚Äù and ‚Äúdecode‚Äù here have the exact same meaning as they have in the field of encryption (i.e.¬†they mean the same thing as ‚Äúencode‚Äù and ‚Äúdecode‚Äù in hashing algorithms, like the MD5 algorithm).\nSo, ‚Äúencode‚Äù means that we want to encode, or, in other words, we want to translate some message into the base64 encoding system. We want to produce the sequence of base64 characters that represent this original message in the base64 encoding system.\nIn contrast, ‚Äúdecode‚Äù represents the inverse process. We want to decode, or, in other words, translate a base64 message back to it‚Äôs original content. So, in this process we get a sequence of base64 characters as input, and produce as output, the binary data that is represented by this sequence of base64 characters.\nSo, any base64 library is normally composed by these two parts: 1) the encoder, which is a function that encodes (i.e.¬†it converts) any sequence of binary data into a sequence of base64 characters; 2) the decoder, which is a function that converts a sequence of base64 characters back into the original sequence of binary data.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-base64-length-out",
    "href": "Chapters/01-base64.html#sec-base64-length-out",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "4.3 Calculating the size of the output",
    "text": "4.3 Calculating the size of the output\nOne task that we need to do is to calculate how much space we need to reserve for the output, both of the encoder and decoder. This is simple math, and can be done easily in Zig because every array have it‚Äôs length (it‚Äôs number of bytes) easily accesible by consulting the .len property of the array.\nFor the encoder, the logic is the following: for each 3 bytes that we find in the input, 4 new bytes are created in the output. So, we take the number of bytes in the input, divide it by 3, use a ceiling function, then, we multiply the result by 4. That way, we get the total number of bytes that will be produced by the encoder in it‚Äôs output.\nThe _calc_encode_length() function below encapsulates this logic. Notice that we convert the .len property of the array, which is always a integer (more precisely, an usize value), into a floating point number of 64 bits (f64). We do this, because the ceiling function (@ceil()) works only with floating point numbers. So, we convert it so that the division with the number 3.0 results in a floating point number. Then, after the ceiling process, we can convert the result back into an integer value (with the @intFromFloat() function).\n\nfn _calc_encode_length(input: []const u8) u64 {\n    if (input.len &lt; 3) {\n        const n_output: u64 = 4;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@ceil(len_as_float / 3.0) * 4.0);\n    return n_output;\n}\n\nIs important to notice that, when I am using the built-in functions from Zig to convert data types (@floatFromInt() and intFromFloat()), I‚Äôm always annotating explicitly the type of the variable that stores the result of these functions. I do that, because these functions need this information. @floatFromInt() needs to know which type of floating point number I want to use in it‚Äôs output. Is it f16? f32? f64? etc. The same goes to @intFromFloat().\nAlso, you might have notice that, if the input length is less than 3 bytes, then, the output length of the encoder will be always 4 bytes. This is because the algorithm will always fill the gap in the input with zeroes, until it fits the window of 24 bits that the algorithm likes to work on, as I described at Section 4.1.3. So the output of the algorithm will always be 4 bytes in this specific case.\nNow, for the decoder, we just need to apply the inverse logic: for each 4 bytes in the input, 3 bytes will be produced in the output of the decoder. I mean, this is roughly true, because we also need to take the = character into account, which is always ignored by the decoder, as we described at Section 4.1.4, and, at Figure¬†4.2. But we can ignore this fact for now, to make things simpler.\nSo, the function _calc_decode_length() summarizes this logic that we described. It is very similar to the function _calc_encode_length(), only the division part is twisted, and also, in the special case where we have less than 4 bytes in the input to work on.\n\nfn _calc_decode_length(input: []const u8) u64 {\n    if (input.len &lt; 4) {\n        const n_output: u64 = 3;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@floor(len_as_float / 4.0) * 3.0);\n    return n_output;\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encoder-logic",
    "href": "Chapters/01-base64.html#sec-encoder-logic",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "4.4 Building the encoder logic",
    "text": "4.4 Building the encoder logic\nIn this section, we can start building the logic behind the encode() function, which will be responsible for encoding messages into the base64 encoding system.\nIf you are an anxious person, and you want to see now the full source code of the implementation for this base64 encoder/decoder, you can find it at the ZigExamples folder in the official repository of this book2.\n\n4.4.1 The 6-bit transformation\nThe 6-bit transformation presented at Figure¬†4.1 is the core part of the base64 encoder algorithm. By understanding how this transformation is made in code, the rest of the algorithm becomes much simpler to comprehend.\nIn essence, this 6-bit transformation is made with the help of bitwise operators. Bitwise operators are essential to any type of low-level operation that is done at the bit-level. For the specific case of the base64 algorithm, the operators bif shift to the left (&lt;&lt;), bit shift to the right (&gt;&gt;), and the bitwise and (&) are used. They are the core solution for the 6-bit transformation.\nWe have 3 different scenarios that we need to account for in this transformation. First, is the perfect scenario, where we have the perfect window of 3 bytes to work on. Second, we have the scenario where we have a window of only two bytes to work with. And last, we have the scenario where we have a window of one single byte.\nIn each of these 3 scenarios, the 6-bit transformation works a bit different. To make the explanation easier, I will use the variable output to refer to the bytes in the output of the base64 encoder, and the variable input to refer to the bytes in the input of the encoder.\nSo, if you have the perfect window of 3 bytes, these are steps for the 6-bit transformation:\n\noutput[0] is produced by moving the bits from input[0] two positions to the right.\noutput[1] is produced by summing two components. First, take the last two bits from input[0], then, move them four positions to the left. Second, move the bits from input[1] four positions to the right. Sum these two components.\noutput[2] is produced by summing two components. First, take the last four bits from input[1], then, move them two positions to the left. Second, move the bits from input[2] six positions to the right.\noutput[3] is produced by taking the last six bits from input[2].\n\nThis is the perfect scenario, when we have a full window of 3 bytes to work on. Just to make things as clear as possible, the Figure¬†4.3 demonstrates visually how the step 2 mentioned above works. So this is the step necessary to produce the 2nd byte in the output of the encoder, by taking the 1st byte (dark purple) and the 2nd byte (orange) in the input. You can see that, at the end of the process, we get a new byte that contains the last 2 bits from the 1st byte in the input, and the first 4 bits from the 2nd byte in the input.\n\n\n\n\n\n\nFigure¬†4.3: How the 2nd byte in the output of the encoder is produced from the 1st byte (dark purple) and the 2nd byte (orange) of the input\n\n\n\nOn the other hand, we must be prepared for the possibilities where we do not have the perfect window of 3 bytes. If you have a window of 2 bytes, then, the steps 3 and 4, which produces the bytes output[2] and output[3], change a little bit, and they become:\n\noutput[2] is produced by taking the last 4 bits from input[1], then, move them two positions to the left.\noutput[3] is the character '='.\n\nFinally, if you have a window of a single byte, then, the steps 2 to 4, which produces the bytes output[1], output[2] and output[3] change, becoming:\n\noutput[1] is produced by taking the last two bits from input[0], then, move them four positions to the left.\noutput[2] and output[3] are the character =.\n\nIf these bulletpoints were a bit confusing for you, you may find the Table¬†4.1 more intuitive. This table unifies all this logic into a simple table. Notice that this table also provides the exact expression in Zig that creates the corresponding byte in the output.\n\n\n\nTable¬†4.1: How the 6-bit transformation translates into code in different window settings.\n\n\n\n\n\n\n\n\n\n\nNumber of bytes in the window\nByte index in the output\nIn code\n\n\n\n\n3\n0\ninput[0] &gt;&gt; 2\n\n\n3\n1\n((input[0] & 0x03) &lt;&lt; 4) + (input[1] &gt;&gt; 4)\n\n\n3\n2\n((input[1] & 0x0f) &lt;&lt; 2) + (input[2] &gt;&gt; 6)\n\n\n3\n3\ninput[2] & 0x3f\n\n\n2\n0\ninput[0] &gt;&gt; 2\n\n\n2\n1\n((input[0] & 0x03) &lt;&lt; 4) + (input[1] &gt;&gt; 4)\n\n\n2\n2\n((input[1] & 0x0f) &lt;&lt; 2)\n\n\n2\n3\n‚Äò=‚Äô\n\n\n1\n0\ninput[0] &gt;&gt; 2\n\n\n1\n1\n((input[0] & 0x03) &lt;&lt; 4)\n\n\n1\n2\n‚Äò=‚Äô\n\n\n1\n3\n‚Äò=‚Äô\n\n\n\n\n\n\n\n\n4.4.2 Bit-shifting in Zig\nBit-shifting in Zig works similarly to bit-shifting in C. All bitwise operators that exists in C are available in Zig. Here, in the base64 encoder algorithm, they are essential to produce the result we want.\nFor those who are not familiar with these operators, they are operators that operates at the bit-level of your values. This means that these operators takes the bits that form the value you have, and change them in some way. This ultimately also changes the value itself, because the binary representation of this value changes.\nWe already saw at Figure¬†4.3 visually what is the effect produced by a bit-shift. But let‚Äôs use the first byte in the output of the base64 encoder as another example of what bit-shifting means. This is the easiest byte of the 4 bytes in the output to build. Because we only need to move the bits from the first byte in the input two positions to the right, with the bit shift to the right (&gt;&gt;) operator.\nIf we take the string ‚ÄúHi‚Äù that we used at Figure¬†4.1 as an example, the first byte in this string is ‚ÄúH‚Äù, which is the sequence 01001000 in binary. If we move the bits of this byte, two places to the right, we get the sequence 00010010 as result. This binary sequence is the value 18 in decimal, and also, the value 0x12 in hexadecimal. Notice that the first 6 bits of the first byte in the input were moved to the end of the byte. With this operation, we get the first byte of the ouput, which corresponds to the index in the base64 scale for the first character in the base64 scale.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const input = \"Hi\";\n    var output = [4]u8{0,0,0,0};\n    output[0] = input[0] &gt;&gt; 2;\n    try stdout.print(\"{d}\\n\", .{output[0]});\n}\n\n18\n\n\nIf you recall Figure¬†4.1, the first byte present in the output should be equivalent to the 6-bit group 010010. Although being visually different, the sequences 010010 and 00010010 are semantically equal. They mean the same thing. They both represent the number 18 in decimal, and the value 0x12 in hexadecimal.\nSo, don‚Äôt take the ‚Äú6-bit group‚Äù factor so seriously. We do not need necessarily to get a 6-bit sequence as result. As long as the meaning of the 8-bit sequence we get is the same of the 6-bit sequence, we are in the clear.\n\n\n4.4.3 Selecting specific bits with the & operator\nIf you comeback to Section 4.4.1, you will see that to produce the second and third bytes in the output, we need to select specific bits from the first and second bytes in the input string. But how can we do that? The answer relies on the bitwise and (&) operator.\nThe Figure¬†4.3 already showed you what effect this & operator produces in the bits of it‚Äôs operands. But let‚Äôs make a clear description of it.\nIn summary, the & operator performs a logical conjunction operation between the bits of it‚Äôs operands. In more details, the operator & compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0 (Microsoft 2021).\nSo, if we apply this operator to the binary sequences 1000100 and 00001101 the result of this operation is the binary sequence 00000100. Because only at the sixth position in both binary sequences we had a 1 value. So any position where we do not have both binary sequences setted to 1, we get a 0 bit in the resulting binary sequence.\nWe loose information about the original bit values from both sequences in this case. Because we no longer know if this 0 bit in the resulting binary sequence was produced by combining 0 with 0, or 1 with 0, etc.\nAs an example, suppose you have the binary sequence 10010111, which is the number 151 in decimal. How can we get a new binary sequence which contains only the third and fourth bits?\nWe just need to combine this sequence with the sequence 00110000 (is 0x30 in hexadecimal) using the & operator. Notice that only the third and fourth positions in this binary sequence is setted to 1. As a consequence, only the third and fourth values of both binary sequences are potentially preserved in the output. All the remaining positions are setted to zero in the output sequence, which is 00010000 (is the number 16 in decimal).\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const bits = 0b10010111;\n    try stdout.print(\"{d}\\n\", .{bits & 0b00110000});\n}\n\n16\n\n\n\n\n4.4.4 Allocating space for the output\nAs I described at Section 3.1.4, to store a variable in the stack, this variable needs to have a known and fixed length at compile-time. This is a problem for our a base64 encoder/decoder case. Because the size of the output (from both the encoder and decoder) depends directly on the size of the input.\nHaving this in mind, we cannot know at compile time which is the size of the output for both the encoder and decoder. So, if we can‚Äôt know the size of the output at compile time, this means that we cannot store in the stack, the output for both the encoder and decoder.\nConsequently, we need to store this output on the heap, and, as I commented at Section 3.1.5, we can only store variables in the heap by using allocator objects. So, one the arguments to both the encode() and decode() functions, needs to be an allocator object, because we know for sure that, at some point inside the body of these functions, we need to allocate space on the heap to store the output of these functions.\nThat is why, both the encode() and decode() functions that I present in this book, have an argument called allocator, which receives a allocator object as input, identified by the type std.mem.Allocator from the Zig standard library.\n\n\n4.4.5 Writing the encode() function\nNow that we have a basic understanding on how the bitwise operators work, and how exactly they help us to achieve the result we want to achieve. We can now encapsulate all the logic that we described at Figure¬†4.1 and Table¬†4.1 into a nice function that we can add to our Base64 struct definition, that we started at Section 4.1.2.\nYou can find the encode() function below. Notice that the first argument of this function, is the Base64 struct itself. Therefore, tis argument clearly signals that this function is a method from the Base64 struct.\nBecause the encode() function itself is fairly long, I intentionally ommitted the Base64 struct definition in this source code, just for brevity reasons. So, just remember that this function is a public function (or a public method) from the Base64 struct.\nFurthermore, this encode() function have two other arguments:\n\ninput is the input sequence of characters that you want to encode in base64;\nallocator is an allocator object to use in the necessary memory allocations.\n\nI described everything you need to know about allocator objects at Section 3.2. So, if you are not familiar with them, I highly recommend you to comeback to that section, and read it. By looking at the encode() function, you will see that we use this allocator object to allocate enough memory to store the output of encoding process.\nRemember from Section 3.1.4, that the stack can be used only to store variables that have a compile-time known fixed size. Unfortunately, this is not the case here. The size of the encode() output is tidly related to the size of the input from the user. So, the size of the output is only known at runtime. That is why we use an allocator object, to allocate memory on the heap (which allows objects whose size are runtime-known), and store the output there.\nThe main for loop in the function is responsible for iterating the entire input string. In every iteration, we use a count variable to count how many iterations we had at the moment. When count reaches 3, then, we try to encode the 3 characters (or bytes) that we accumulated until this point in the temporary buffer object (buf).\nAfter encoding these 3 characters and storing the result in the output variable, we reset the count variable to zero, and start to count again on the next iteration of the loop. If the loop hits the end of the string, and, the count variable is less than 3, then, it means that the temporary buffer contains the last 1 or 2 bytes from the input. That is why we have two if statements after the for loop. To deal which each possible case.\n\npub fn encode(self: Base64,\n              allocator: std.mem.Allocator,\n              input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n\n    const n_out = _calc_encode_length(input);\n    var out = try allocator.alloc(u8, n_out);\n    var buf = [3]u8{ 0, 0, 0 };\n    var count: u8 = 0;\n    var iout: u64 = 0;\n\n    for (input, 0..) |_, i| {\n        buf[count] = input[i];\n        count += 1;\n        if (count == 3) {\n            out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n            out[iout + 1] = self._char_at(\n                ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n            );\n            out[iout + 2] = self._char_at(\n                ((buf[1] & 0x0f) &lt;&lt; 2) + (buf[2] &gt;&gt; 6)\n            );\n            out[iout + 3] = self._char_at(buf[2] & 0x3f);\n            iout += 4;\n            count = 0;\n        }\n    }\n\n    if (count == 1) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            (buf[0] & 0x03) &lt;&lt; 4\n        );\n        out[iout + 2] = '=';\n        out[iout + 3] = '=';\n    }\n\n    if (count == 2) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n        );\n        out[iout + 2] = self._char_at(\n            (buf[1] & 0x0f) &lt;&lt; 2\n        );\n        out[iout + 3] = '=';\n        iout += 4;\n    }\n\n    return out;\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-decoder-logic",
    "href": "Chapters/01-base64.html#sec-decoder-logic",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "4.5 Building the decoder logic",
    "text": "4.5 Building the decoder logic\nNow, we can focus on writting the base64 decoder logic. Remember from Figure¬†4.2 that, a base64 decoder do the inverse process of an encoder. So, all we need to do, is to write a decode() function that performs the inverse process that I exposed at Section 4.4.\n\n4.5.1 Mapping base64 characters to their indexes\nOne thing that we need to do, in order to decode a base64-encoded message, is to calculate the index in the base64 scale of every base64 character that we encounter in the decoder input.\nIn other words, the decoder receives as input, a sequence of base64 characters. We need to translate this sequence of characters into a sequence of indexes. These indexes are the index of each character in the base64 scale. This way, we get the value/byte that was calculated in the 6-bit transformation step of the encoder process.\nThere are probably better ways to calculate this, specially using a ‚Äúdivide and conquer‚Äù type of strategy. But for now, I am satisfied with a simple and ‚Äúbrute force‚Äù type of strategy. The _char_index() function below contains this strategy.\nWe are essentially looping through the lookup table with the base64 scale, and comparing the character we got with each character in the base64 scale. If these characters match, then, we return the index of this character in the base64 scale as the result.\nNotice that, if the input character is '=', the function returns the index 64, which is ‚Äúout of range‚Äù in the scale. But, as I described at Section 4.1.1, the character '=' does not belong to the base64 scale itself. It is a special and meaningless character in base64.\nAlso notice that this _char_index() function is a method from our Base64 struct, because of the self argument. Again, I ommitted the Base64 struct definition in this example, because of brevity reasons.\n\nfn _char_index(self: Base64, char: u8) u8 {\n    if (char == '=')\n        return 64;\n    var index: u8 = 0;\n    for (0..63) |i| {\n        if (self._char_at(i) == char) {\n            index = i;\n            break;\n        }\n    }\n\n    return index;\n}\n\n\n\n4.5.2 The 6-bit transformation\nOnce again, the core part of the algorithm is the 6-bit transformation. If we understand the necessary steps to perform this transformation, the rest of the algorithm becomes much easier.\nFirst of all, before we actually go to the 6-bit transformation, we need to make sure that we use _char_index() to convert the sequence of base64 characters into a sequence of indexes. So the snippet below will be important for the job to be done. The result of _char_index() will be stored in a temporary buffer, and this temporary buffer is what we are going to use in the 6-bit transformation, instead of the actual input object.\n\nfor (0..input.len) |i| {\n    buf[i] = self._char_index(input[i]);\n}\n\nNow, instead of producing 4 bytes (or 4 characters) as output per each window of 3 characters in the input, a base64 decoder produces 3 bytes (or 3 characters) as output per each window of 4 characters in the input. Once again, is the inverse process.\nSo, the steps to produce the 3 bytes in the output are:\n\noutput[0] is produced by summing two components. First, move the bits from buf[0] two positions to the left. Second, move the bits from buf[1] 4 positions to the right. Then, sum these two components.\noutput[1] is produced by summing two components. First, move the bits from buf[1] four positions to the left. Second, move the bits from buf[2] 2 positions to the right. Then, sum these two components.\noutput[2] is produced by summing two components. First, move the bits from buf[2] six positions to the left. Then, you sum the result with buf[3].\n\nBefore we continue, let‚Äôs try to visualize how these transformations make the original bytes that we had before the encoding process. First, think back at the 6-bit transformation performed by the encoder exposed at Section 4.4. The first byte in the output of the encoder is produced by moving the bits in the first byte of the input two positions to the right.\nSo, if for example the first byte in the input of the encoder was the sequence ABCDEFGH, then, the first byte in the output of the encoder would be 00ABCDEF (this sequence would be the first byte in the input of the decoder). Now, if the second byte in the input of the encoder was the sequence IJKLMNOP, then, the second byte in the encoder output would be 00GHIJKL (as we demonstrated at Figure¬†4.3).\nSo, if the sequences 00ABCDEF and 00GHIJKL sequences are the first byte and the second bytes, respectively, in the input of the decoder, the Figure¬†4.4 demonstrates visually how these two bytes are transformed into the first byte of the output of the decoder. Notice that the output byte is the sequence ABCDEFGH, which is the original byte from the input of the encoder.\n\n\n\n\n\n\nFigure¬†4.4: How the 1st byte in the decoder output is produced from the 1st byte (dark purple) and the 2nd byte (orange) of the input\n\n\n\nThe Table¬†4.2 presents how the three steps described ealier translate into Zig code:\n\n\n\nTable¬†4.2: The necessary steps for the 6-transformation in the decode process.\n\n\n\n\n\nByte index in the output\nIn code\n\n\n\n\n0\n(buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4)\n\n\n1\n(buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2)\n\n\n2\n(buf[2] &lt;&lt; 6) + buf[3]\n\n\n\n\n\n\n\n\n4.5.3 Writing the decode() function\nThe decode() function below contains the entire decoding process. Notice that, we first calculate the necessary size for the output, with _calc_decode_length(), then, we allocate memory for this output with the allocator object.\nThree temporary variables are created: 1) count, to hold the window count in each iteration of the for loop; 2) iout, to hold the current index in the output; 3) buf, which is the temporary buffer that holds the base64 indexes to be converted through the 6-bit transformation.\nThen, in each iteration of the for loop we fill the temporary buffer with the current window of bytes. When count hits the number 4, then, we have a full window of indexes in buf to be converted, and then, we apply the 6-bit transformation over the temporary buffer.\nNotice that we check if the indexes 2 and 3 in the temporary buffer are the number 64, which, if you recall from Section 4.5.1, is when the _calc_index() function receives a '=' character as input. So, if these indexes are equal to the number 64, the decode() function knows that it can simply ignore these indexes. They are not converted, because, as I described before, the character '=' have no meaning, despite being the end of meaningful characters in the sequence. So we can safely ignore them, when they appear in the sequence.\n\nfn decode(self: Base64,\n          allocator: std.mem.Allocator,\n          input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n    const n_output = _calc_decode_length(input);\n    var output = try allocator.alloc(u8, n_output);\n    for (output, 0..) |_, i| {\n        output[i] = 0;\n    }\n    var count: u8 = 0;\n    var iout: u64 = 0;\n    var buf = [4]u8{ 0, 0, 0, 0 };\n\n    for (0..input.len) |i| {\n        buf[count] = self._char_index(input[i]);\n        count += 1;\n        if (count == 4) {\n            output[iout] = (buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4);\n            if (buf[2] != 64) {\n                output[iout + 1] = (buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2);\n            }\n            if (buf[3] != 64) {\n                output[iout + 2] = (buf[2] &lt;&lt; 6) + buf[3];\n            }\n            iout += 3;\n            count = 0;\n        }\n    }\n\n    return output;\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#the-end-result",
    "href": "Chapters/01-base64.html#the-end-result",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "4.6 The end result",
    "text": "4.6 The end result\nNow that we have both decode() and encode() implemented. We have a full functioning base64 encoder/decoder implemented in Zig. Here is an example of use of our Base64 struct with the encode() and decode() methods that we implemented.\n\nvar memory_buffer: [1000]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(\n    &memory_buffer\n);\nconst allocator = fba.allocator();\n\nconst text = \"Testing some more shit\";\nconst etext = \"VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\";\nconst base64 = Base64.init();\nconst encoded_text = try base64.encode(\n    allocator, text\n);\nconst decoded_text = try base64.decode(\n    allocator, etext\n);\ntry stdout.print(\n    \"Encoded text: {s}\\n\", .{encoded_text}\n);\ntry stdout.print(\n    \"Decoded text: {s}\\n\", .{decoded_text}\n);\n\nEncoded text: VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\nDecoded text: Testing some more shit\nYou can also see the full source code at once, by visiting the official repository of this book3. More precisely inside the ZigExamples folder4.\n\n\n\n\nMicrosoft. 2021. ‚ÄúBitwise AND Operator: &.‚Äù Microsoft Learn. https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#footnotes",
    "href": "Chapters/01-base64.html#footnotes",
    "title": "4¬† Project 1 - Building a base64 encoder/decoder",
    "section": "",
    "text": "Notice that, the character ‚Äú0‚Äù is different than the actual number 0, which is simply zero in binary.‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/base64/base64_basic.zig.‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/base64/base64_basic.zig.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Project 1 - Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html",
    "href": "Chapters/02-debugging.html",
    "title": "5¬† Debugging Zig applications",
    "section": "",
    "text": "5.1 Printing debugging\nWe begin with the classic and battle-tested print debugging strategy. The key advantage that debugging offers you is visibility. With print statements you can easily see what results and objects that are being generated within your functions.\nThat is the essence of print debugging. Is to use print expressions to see the values that are being generated by your program, and, as a result, get a much better understanding of how your program is behaving.\nMany programmers often resort to the print functions in Zig, such as the stdout.print(), or, the std.debug.print(), to get a better understanding of their programs. This is an known and old strategy that is very simple and effective, and it is better known within the programming community as print debugging. In Zig, you can either print information to the stdout or stderr streams of your system.\nLet‚Äôs begin with stdout. First, you need to get access to the stdout, by calling the getStdOut() method, from the Zig standard library. This method returns a file descriptor object, and, through this object you can read/write to the stdout. I recommend you to check out all methods available in this object, by checking the page in the Zig Standard Library Official Reference for the type File1.\nFor our purpose here, which is to write something to the stdout, specially to debug our program, I recommend you to use the writer() method, which gives your a writer object. This writer object offers some helper methods to write stuff into the file descriptor object that represents the stdout stream. In special, the print() method.\nThe print() method from this writer object is a ‚Äúprint formatter‚Äù type of a function. In other words, this method works exactly like the printf() function from C, or, like println!() from Rust. In the first argument of the function, you specify a template string, and, in the second argument, you provide a list of values (or objects) that you want to insert into your template message.\nIdeally, the template string in the first argument should contain some format specifier. Each format specifier is matched to a value (or object) that you listed in the second argument. So, if you provided 5 different objects in the second argument, then, the template string should contain 5 format specifiers, one for each object provided.\nEach format specifier is represented by a single letter, and you provide this format specifier inside a pair of curly braces. So, if you want to format your object using the string specifier (s), then, you can insert the text {s} in your template string. Here is a quick list of the most used format specifiers:\nThe code example below, gives you an example of use of this print() method with the d format specifier.\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    _ = try stdout.print(\"Result: {d}\", .{result});\n}\n\nResult: 50\nIs important to emphasize that, the stdout.print() method, as you would expect, print your template string into the stdout stream of your system. However, you can also print your template string into the stderr stream if your prefer. All you need to do, is to replace the stdout.print() call with the function std.debug.print(). Like this:\nconst std = @import(\"std\");\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    std.debug.print(\"Result: {d}\\n\", .{result});\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#printing-debugging",
    "href": "Chapters/02-debugging.html#printing-debugging",
    "title": "5¬† Debugging Zig applications",
    "section": "",
    "text": "d: for printing integers and floating-point numbers.\nc: for printing characters.\ns: for printing strings.\np: for printing memory addresses.\nx: for printing hexadecimal values.\nany: use any compatible format specifier (i.e.¬†it automatically selects a format specifier for you).\n\n\n\n\n\nResult: 50",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#debugging-through-debuggers",
    "href": "Chapters/02-debugging.html#debugging-through-debuggers",
    "title": "5¬† Debugging Zig applications",
    "section": "5.2 Debugging through debuggers",
    "text": "5.2 Debugging through debuggers\nAlthough print debugging is a valid and very useful strategy, most programmers prefer to use a debugger to debug their programs. Since Zig is a low-level language, you can use either GDB (GNU Debugger), or LLDB (LLVM Project Debugger) as your debugger.\nBoth debuggers can work with Zig code, and it‚Äôs a matter of taste here. You choose the debugger of your preference, and you work with it. In this book, I will use LLDB as my debugger on the examples.\n\n5.2.1 Compile your source code in Debug mode\nIn order to debug your program through a debugger, you must compile your source code in Debug mode. Because when you compile your source code in other modes (such as Release), the compiler usually strips out some essential information that is used by the debugger to read and track your program, like PDB (Program Database) files.\nBy compiling your source code in Debug mode, you ensure that the debugger will find the necessary information in your program to debug it. By default, the compiler uses the Debug mode. Having this in mind, when you compile your program with the build-exe command (that we exposed at Section 1.2.4), if you don‚Äôt specify an explicit mode through the -O command-line 2 argument, then, the compiler will compile your code in Debug mode.\n\n\n5.2.2 Let‚Äôs debug a program\nAs an example, let‚Äôs debug some Zig code, and demonstrate how can we use LLDB to navigate and check the following piece of Zig code:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\nfn add_and_increment(a: u8, b: u8) u8 {\n    const sum = a + b;\n    const incremented = sum + 1;\n    return incremented;\n}\n\npub fn main() !void {\n    var n = add_and_increment(2, 3);\n    n = add_and_increment(n, n);\n    _ = try stdout.print(\"Result: {d}!\\n\", .{n});\n}\n\nResult: 13!\n\n\nThere is nothing wrong with this program. But it is a good start for us. First, we need to compile this program with the zig build-exe command. For this example, suppose that I compiled the above Zig code into a binary executable called add_program.\nzig build-exe add_program.zig\nNow, we can start LLDB with add_program, like this:\nlldb add_program\nFrom now on, LLDB is started, and you can know that I‚Äôm executing LLDB commands by looking at the prefix (lldb). If something is prefixed with (lldb), then you know that it is a LLDB command.\nThe first thing I will do, is to set a breakpoint at the main() function, by executing b main. After that, I just start the execution of the program with run. You can see in the output below, that the execution stopped at the first line in the function main(), as we expected.\n(lldb) b main\nBreakpoint 1: where = debugging`debug1.main + 22\n    at debug1.zig:11:30, address = 0x00000000010341a6\n(lldb) run\nProcess 8654 launched: 'add_program' (x86_64)\nProcess 8654 stopped\n* thread #1, name = 'add_program',\n    stop reason = breakpoint 1.1 frame #0: 0x10341a6\n    add_program`debug1.main at add_program.zig:11:30\n   8    }\n   9    \n   10   pub fn main() !void {\n-&gt; 11       var n = add_and_increment(2, 3);\n   12       n = add_and_increment(n, n);\n   13       try stdout.print(\"Result: {d}!\\n\", .{n});\n   14   }\nI can start to navigate through the code, and investigating the variables that are being generated. If you not familiar with the commands available in LLDB, I recommend you to read the official documentation of the project3. You can also look for cheat sheets. Which quickly describes all commands available for you, and, as a result, are also good resources for you4.\nCurrently, we are in the first line at the main() function. In this line, we create the n object, by executing the add_and_increment() function. To execute the current line of code, and go to the next line, we can run the n LLDB command. Let‚Äôs execute this command.\nAfter we executed this line, we can also look at the value stored inside this n object by using the p LLDB command. The syntax for this command is p &lt;name-of-object&gt;.\nIf we take a look at the value stored in the n object (p n), notice that it stores the hexadecimal value 0x06, which is the number 6 in decimal. We can also see that, this value have a type unsigned char, which is an unsigned 8-bit integer. We have talked already about this at Section 1.8, that u8 integers in Zig are equivalent to the C data type unsigned char.\n(lldb) n\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step over frame #0: 0x10341ae\n    debugging`debug1.main at debug1.zig:12:26\n   9    \n   10   pub fn main() !void {\n   11       var n = add_and_increment(2, 3);\n-&gt; 12       n = add_and_increment(n, n);\n   13       try stdout.print(\"Result: {d}!\\n\", .{n});\n   14   }\n(lldb) p n\n(unsigned char) $1 = '\\x06'\nNow, on the next line of code, we are executing the add_and_increment() function once again. Why not step inside this function? Shall we? We can do that, by executing the s LLDB command. Notice in the example below that, after executing this command, we entered inside the context of the add_and_increment() function.\nAlso notice in the example below that, I walked two more lines in the functions body, then, I executed the frame variable LLDB command, to see at once, the value stored in each of the variables that were created inside the current scope.\nYou can see in the output below that, the object sum stores the value \\f, which represents the form feed character. This character in the ASCII table, corresponds to the hexadecimal value 0x0C, or, in decimal, the number 12. So, this means that the result of the expression a + b executed at line 5, resulted in the number 12.\n(lldb) s\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step in frame #0: 0x10342de\n    debugging`debug1.add_and_increment(a='\\x02', b='\\x03')\n    at debug1.zig:4:39\n-&gt; 4    fn add_and_increment(a: u8, b: u8) u8 {\n   5        const sum = a + b;\n   6        const incremented = sum + 1;\n   7        return incremented;\n(lldb) n\n(lldb) n\n(lldb) frame variable\n(unsigned char) a = '\\x06'\n(unsigned char) b = '\\x06'\n(unsigned char) sum = '\\f'\n(unsigned char) incremented = '\\x06'",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#how-to-investigate-the-data-type-of-your-objects",
    "href": "Chapters/02-debugging.html#how-to-investigate-the-data-type-of-your-objects",
    "title": "5¬† Debugging Zig applications",
    "section": "5.3 How to investigate the data type of your objects",
    "text": "5.3 How to investigate the data type of your objects\nSince Zig is a strongly-typed language, the data types associated with your objects are very important for your program. So, debugging the data types associated with your objects might be important to understand bugs and errors in your program.\nWhen you walk through your program with a debugger, you can inspect the types of your objects by simply printing them to the console, with the LLDB p command. But you also have alternatives embedded in the language itself to access the data types of your objects.\nIn Zig, you can retrieve the data type of an object, by using the built-in function @TypeOf(). Just apply this function over the object, and you get access to the data type of the object.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst expect = std.testing.expect;\n\npub fn main() !void {\n    const number: i32 = 5;\n    try expect(@TypeOf(number) == i32);\n    try stdout.print(\"{any}\\n\", .{@TypeOf(number)});\n}\n\ni32\n\n\nThis function is similar to the type() built-in function from Python, or, the typeof operator in Javascript.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#footnotes",
    "href": "Chapters/02-debugging.html#footnotes",
    "title": "5¬† Debugging Zig applications",
    "section": "",
    "text": "https://ziglang.org/documentation/master/std/#std.fs.File.‚Ü©Ô∏é\nSee https://ziglang.org/documentation/master/#Debug.‚Ü©Ô∏é\nhttps://lldb.llvm.org/‚Ü©Ô∏é\nhttps://gist.github.com/ryanchang/a2f738f0c3cc6fbd71fa.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html",
    "href": "Chapters/05-pointers.html",
    "title": "6¬† Pointers and Optionals",
    "section": "",
    "text": "6.1 Constant objects vs variable objects\nYou can have a pointer that points to a constant object, or, a pointer that points to a variable object. But regardless of who this pointer is, a pointer must always respect the characteristics of the object that it points to. As a consequence, if the pointer points to a constant object, then, you cannot use this pointer to change the value that it points to. Because it points to a value that is constant. As we discussed at Section 1.4, you cannot change a value that is constant.\nFor example, if I have a number object, which is constant, I cannot execute the expression below where I‚Äôm trying to change the value of number to 6 through the pointer object. As demonstrated below, when you try to do something like that, you get a compile time error:\nconst number = 5;\nconst pointer = &number;\npointer.* = 6;\nIf I change the number object to be a variable object, by introducing the var keyword, then I can change the value of this object through a pointer, as demonstrated below:\nvar number: u8 = 5;\nconst pointer = &number;\npointer.* = 6;\ntry stdout.print(\"{d}\\n\", .{number});\n\n6\nYou can see this relationship on the data type of your pointer object. In other words, the data type of a pointer object already gives you some clues about whether the value that it points to is constant or not.\nWhen a pointer object points to a constant value, then, this pointer have a data type *const T, which means ‚Äúa pointer to a constant value of type T‚Äù. In contrast, if the pointer points to a variable value, then, the type of the pointer is usually *T, which is simply ‚Äúa pointer to a value of type T‚Äù.\nWhenever you see a pointer object whose type is in the format *const T, then, you know that you cannot use this pointer to change the value that it points to. Because this pointer points to a constant value of type T.\nHence, we talked about the value pointed by the pointer being constant or not, and the consequences that arises from it. But, what about the pointer object itself? I mean, what happens if the pointer object itself is constant or not? Think about it. We can have a constant pointer that points to a constant value. But we can also have a variable pointer that points to a constant value. And vice-versa.\nUntil this point, the pointer object was always constant, but what this means for us? What is the consequence of the pointer object being constant? The consequence is that we cannot change the pointer object, because it is constant. We can use the pointer object in multiple ways, but we cannot change the memory address that is inside this pointer object.\nHowever, if we mark the pointer object as a variable object, then, we can change the memory address pointed by this pointer object. The example below demonstrates that. Notice that the object pointed by the pointer object changes from c1 to c2.\nconst c1: u8 = 5;\nconst c2: u8 = 6;\nvar pointer = &c1;\ntry stdout.print(\"{d}\\n\", .{pointer.*});\npointer = &c2;\ntry stdout.print(\"{d}\\n\", .{pointer.*});\nThus, by setting the pointer object to a var or const object, you specify if the memory address contained in this pointer object can change or not in your program. On the other side, you can change the value pointed by the pointer, if, and only if this value is stored in a variable object. If this value is in a constant object, then, you cannot change this value through a pointer.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Pointers and Optionals</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#sec-pointer-var",
    "href": "Chapters/05-pointers.html#sec-pointer-var",
    "title": "6¬† Pointers and Optionals",
    "section": "",
    "text": "p.zig:6:12: error: cannot assign to constant\n    pointer.* = 6;\n\n\n\n\n\n\n\n\n\n5\n6",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Pointers and Optionals</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#types-of-pointer",
    "href": "Chapters/05-pointers.html#types-of-pointer",
    "title": "6¬† Pointers and Optionals",
    "section": "6.2 Types of pointer",
    "text": "6.2 Types of pointer\nIn Zig, there are two types of pointers (Zig Software Foundation 2024), which are:\n\nsingle-item pointer (*);\nmany-item pointer ([*]);\n\nSingle-item pointer objects are objects whose data types are in the format *T. So, for example, if an object have a data type *u32, it means that, this object contains a pointer that points to an unsigned 32-bit integer value. As another example, if an object have type *User, then, it contains a pointer to a User value.\nIn contrast, many-item pointer objects are objects whose data types are in the format [*]T. Notice that the star symbol (*) is now inside a pair of brackets ([]). If the star symbol is inside a pair of brackets, you know that this object is a many-item pointer.\nWhen you apply the & operator over an object, you will always get a single-item pointer. Many-item pointers are more of a ‚Äúinternal type‚Äù of the language, more closely related to slices. So, when you deliberately create a pointer with the & operator, you always get a single-item pointer as result. Remember that.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Pointers and Optionals</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#pointer-arithmethic",
    "href": "Chapters/05-pointers.html#pointer-arithmethic",
    "title": "6¬† Pointers and Optionals",
    "section": "6.3 Pointer arithmethic",
    "text": "6.3 Pointer arithmethic\nPointer arithmethic is available in Zig, and they work the same way they work in C. When you have a pointer that points to an array, the pointer usually points to the first element in the array, and you can use pointer arithmethic to advance this pointer and access the other elements in the array.\nNotice in the example below, that initially, the ptr object was pointing to the first element in the array ar. But then, I started to walk through the array, by advancing the pointer with simple pointer arithmethic.\n\nconst ar = [_]i32{1,2,3,4};\nvar ptr = &ar;\ntry stdout.print(\"{d}\\n\", .{ptr.*});\nptr += 1;\ntry stdout.print(\"{d}\\n\", .{ptr.*});\nptr += 1;\ntry stdout.print(\"{d}\\n\", .{ptr.*});\n\n1\n2\n3\nAlthough you can create a pointer to an array like that, and start to walk through this array by using pointer arithmethic, in Zig, we prefer to use slices, which were presented at Section 1.6.\nBehind the hood, slices already are pointers, and they also come with the len property, which indicates how many elements are in the slice. This is good because the zig compiler can use it to check for potential buffer overflows, and other problems like that.\nAlso, you don‚Äôt need to use pointer arithmethic to walk through the elements of a slice. You can simply use the slice[index] syntax to directly access any element you want in the slice. As I mentioned at Section 1.6, you can get a slice from an array by using a range selector inside brackets. In the example below, I‚Äôm creating a slice (sl) that covers the entire ar array. I can access any element of ar from this slice, and, the slice itself already is a pointer behind the hood.\n\nconst ar = [_]i32{1,2,3,4};\nconst sl = ar[0..ar.len];\n_ = sl;",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Pointers and Optionals</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#optionals-and-optional-pointers",
    "href": "Chapters/05-pointers.html#optionals-and-optional-pointers",
    "title": "6¬† Pointers and Optionals",
    "section": "6.4 Optionals and Optional Pointers",
    "text": "6.4 Optionals and Optional Pointers\nLet‚Äôs talk about optionals and how they relate to pointers in Zig. By default, objects in Zig are non-nullable. This means that, in Zig, you can safely assume that any object in your source code is not null.\nThis is a powerful feature of Zig when you compare it to the developer experience in C. Because in C, any object can be null at any point, and, as consequence, a pointer in C might point to a null value. This is a commom source of undefined behaviour in C. When programmers work with pointers in C, they have to constantly check if their pointers are pointing to null values or not.\nIf for some reason, your Zig code produces a null value somewhere, and, this null value ends up in an object that is non-nullable, a runtime error is always raised by your Zig program. Take the program below as an example. The zig compiler can see the null value at compile time, and, as result, it raises a compile time error. But, if a null value is raised during runtime, a runtime error is also raised by the Zig program, with a ‚Äúattempt to use null value‚Äù message.\n\nvar number: u8 = 5;\nnumber = null;\n\np5.zig:5:14: error: expected type 'u8',\n        found '@TypeOf(null)'\n    number = null;\n             ^~~~\nYou don‚Äôt get this type of security in C. In C, you don‚Äôt get warnings or errors about null values being produced in your program. If for some reason, your code produces a null value in C, most of the times, you end up getting a segmentation fault error as result, which can mean many things. That is why programmers have to constantly check for null values in C. Because they do not have much visibility of null values.\nPointers in Zig are also, by default, non-nullable. This is another amazing feature in Zig. So, any pointer you create in your code, you can safely assume that this pointer is pointing to a non-null value. Therefore, you don‚Äôt have this heavy work of checking if the pointers you create in Zig are pointing to a null value.\nThis is an important feature, because this is also a commom source source of undefined behaviour in C. For example, if you have a pointer x that points to an object y, the value of the object y might change during the runtime of your program, and, as consequence, the value pointed by the pointer x will change. I demonstrated already how the value pointed by a pointer might change at Section 6.1.\nSo, if for some reason, the value of y changes to a null value during runtime, and, you try to use the object y in some way in your code, the chances of producing a undefined behaviour in your program are sky high.\nIn C, when the value of y changes, you have no garantees that the value of the object y changed to a null value or not. You simply don‚Äôt know upfront if you have a null value in y or not. But in Zig, you can safely assume that the object y will never have a null value.\n\n6.4.1 What are optionals?\nOk, we know now that all objects are non-nullable by default in Zig. But what if we actually need to use an object that might receive a null value? Here is where optionals come in.\nAn optional object in Zig is an object that can be null. To mark an object as optional, we use the ? operator. When you put this ? operator right before the data type of an object, you transform this data type into an optional data type, and the object becomes an optional object.\nTake the snippet below as an example. We are creating a new variable object called num. This object have data type ?i32, which means that, this object contains either a signed 32-bit integer (i32), or, a null value. Both alternatives are valid values to the num object. That is why, I can actually change the value of this object to null, and, no errors are raised by the zig compiler, as demonstrated below:\n\nvar num: ?i32 = 5;\nnum = null;\n\n\n\n6.4.2 Optional pointers\nYou can also mark a pointer object as an optional pointer, meaning that, this pointer points to either a null value, or, a value that is not null. In other words, by marking a pointer in Zig as optional, you get a pointer in Zig that behaves like a pointer in C.\nWhen you mark a pointer as optional, the data type of this pointer object becomes ?*const T or ?*T, depending if the value pointed by the pointer is a constant value or not. The ? identifies the object as optional, and the * identifies it as a pointer object.\nIn the example below, we are creating a variable object named num, and an optional pointer object named ptr. Notice that the data type of the object ptr indicates that it is either a null value, or a pointer to an i32 value. Also, notice that the pointer object (ptr) can be marked as optional, even if the object num is not optional.\nWhat this code tells us is that, the num variable will never contain a null value. This variable will always contain a valid i32 value. But in contrast, the ptr object might contain either a null value, or, a pointer to an i32 value.\n\nvar num: i32 = 5;\nconst ptr: ?*i32 = &num;\n_ = ptr;\n\nBut what happens if we turn the table, and mark the num object as optional, instead of the pointer object. If we do that, then, the pointer object is not optional anymore. It would be a similar (altough different) result. Because then, we would have a pointer to an optional value. In other words, a pointer to a value that is either a null value, or, a not-null value.\nIn the example below, we are recreating this idea. Now, the ptr object have a data type of *?i32, instead of ?*i32. Notice that the * symbol comes before of ? this time. So now, we have a pointer that points to a value that is either null , or, a signed 32-bits integer.\n\nvar num: ?i32 = 5;\n// ptr have type `*?i32`, instead of `?*i32`.\nconst ptr = &num;\n_ = ptr;\n\n\n\n6.4.3 Null handling in optionals\nWhen you have an optional object in your Zig code, you have to explicitly handle the possibility of this object being null. Is like error-handling with try and catch. In Zig you also have to handle null values like if they were a type of error.\nWe can do that, by using either:\n\nan if statement, like you would do in C.\nthe orelse keyword.\nunwrap the optional value with the ? method.\n\nWhen you use an if statement, you use a pair of pipes to unwrap the optional value, and use this ‚Äúunwrapped object‚Äù inside the if block. Using the example below as a reference, if the object num is null, then, the code inside the if statement is not executed. Otherwise, the if statement will unwrap the object num into the not_null_num object. This not_null_num object is garanteed to be not null inside the scope of the if statement.\n\nconst num: ?i32 = 5;\nif (num) |not_null_num| {\n    try stdout.print(\n        \"{d}\\n\", .{not_null_num}\n    );\n}\n\n5\n\n\nNow, the orelse keyword behaves like a binary operator. You connect two expressions with this keyword. On the left side of orelse, you provide the expression that might result in a null value, and on the right side of orelse you provide another expression that will not result in a null value.\nThe idea behind the orelse keyword is: if the expression on the left side result in a not-null value, then, this not-null value is used. However, if this expression on the left side result in a null value, then, the value of the expression on the right side is used instead.\nLooking at the example below, since the x object is currently null, the orelse decided to use the alternative value, which is the number 15.\n\nconst x: ?i32 = null;\nconst dbl = (x orelse 15) * 2;\ntry stdout.print(\"{d}\\n\", .{dbl});\n\n30\n\n\nYou can use the if statement or the orelse keyword, when you want to solve (or deal with) this null value. However, if there is no clear solution to this null value, and the most logic and sane path is to simply panic and raise a loud error in your program when this null value is encountered, you can use the ? method of your optional object.\nIn essence, when you use this ? method, the optional object is unwraped. If a not-null value is found in the optional object, then, this not-null value is used. Otherwise, the unreachable keyword is used. You can read more about this unreacheable keyword at the official documentation1. But in essence, when you build your Zig source code using the build modes ReleaseSafe or Debug, this unreacheable keyword causes the program to panic and raise an error during runtime, like in the example below:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn return_null(n: i32) ?i32 {\n    if (n == 5) return null;\n    return n;\n}\n\npub fn main() !void {\n    const x: i32 = 5;\n    const y: ?i32 = return_null(x);\n    try stdout.print(\"{d}\\n\", .{y.?});\n}\n\nthread 12767 panic: attempt to use null value\np7.zig:12:34: 0x103419d in main (p7):\n    try stdout.print(\"{d}\\n\", .{y.?});\n                                 ^\n\n\n\n\nZig Software Foundation. 2024. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Pointers and Optionals</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#footnotes",
    "href": "Chapters/05-pointers.html#footnotes",
    "title": "6¬† Pointers and Optionals",
    "section": "",
    "text": "https://ziglang.org/documentation/master/#unreachable.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Pointers and Optionals</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html",
    "href": "Chapters/04-http-server.html",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "",
    "text": "7.1 What is a HTTP Server?\nFirst of all, what is a HTTP Server? A HTTP server, as any other type of server, is essentially a program that runs indefinetly, on a infinite loop, waiting for incoming connections from clients. Once the server receives an incoming connection, it will accept this connection, and it will send messages back-and-forth to the client through this connection.\nBut the messages that are transmitted inside this connection are in a specific format. They are HTTP messages (i.e.¬†messages that uses the HTTP Protocol specification). The HTTP Protocol is the backbone of the modern web. The world wide web as we know it today, would not exist without the HTTP Protocol.\nSo, Web servers (which is just a fancy name to HTTP Servers) are servers that exchange HTTP messages with clients. And these HTTP servers and the HTTP Protocol specification are simply essential to the operation of the internet of today.\nThat is the whole picture of the process. Again, we have two subjects involved here, a server (which is a program that is running indefinetly, waiting for connections), and a client (which is someone that wants to connect to and exchange HTTP messages with the server).\nYou may find the material about the HTTP Protocol available at the Mozilla MDN Docs1 , a great resource for you to also look at. It gives you a great overview on how HTTP works, and what role the server plays in this matter.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-how-http-works",
    "href": "Chapters/04-http-server.html#sec-how-http-works",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.2 How a HTTP Server works?",
    "text": "7.2 How a HTTP Server works?\nImagine a HTTP Server as if it were the receptionist of a large hotel. In a hotel, you have a reception, and inside that reception there is a receptionist waiting for customers to arrive. A HTTP Server is essentially a receptionist that is indefinetly waiting for new customers (or, in the context of HTTP, new clients) to arrive in the hotel.\nWhen a customer arrives at the hotel, that customer starts a conversation with the receptionist. He tells the receptionist how many days he wants to stay at the hotel. Then, the receptionist search for an available apartment. If there is an available apartment at the moment, the customer pays the hotel fees, then, he gets the keys to the apartment, and then, he goes to the apartment to rest.\nAfter this entire process of dealing with the customer (searching for available rooms, receiving payment, handing over the keys), the receptionist goes back to what he was doing earlier, which is to wait. Wait for new customers to arrive.\nThat is, in a nutshell, what a HTTP Server do. It waits for clients to connect to the server. When a client attempts to connect to the server, the server accepts this connection, and it starts to exchange messages with the client through this connection. The first message that happens inside this connection is always a message from the client to the server. This message is called the HTTP Request.\nThis HTTP Request is a HTTP message that contains what the client wants from the server. Is literally a request. The client that connected to the server is asking this server to do something for him.\nThere are different ‚Äútypes of request‚Äù that any client can do to a HTTP Server. But the most basic type of request, is when a client ask to the HTTP Server to serve (i.e.¬†to send) some specific web page (which is a HTML file) to him. When you type google.com in your web browser, you are essentially sending a HTTP Request to Google‚Äôs HTTP servers, which asks these servers to send the Google webpage to you.\nNonetheless, when the server reiceves this first message, the HTTP Request, it analyzes this request, to understand: who the client is? what he wants the server to do? this client provided all the necessary information to perform the action that he asked? Etc.\nOnce the server understands what the client wants, he simply perform the action that was requested, and, to finish the whole process, the server sends back a HTTP message to the client, informing if the action performed was succesful or not, and, at last, the server ends (or closes) the connection with the client.\nThis last HTTP message sent from the server to the client, is called the HTTP Response. Because the server is responding to the action that was requested by the client. The main objective of this response message is let the client knows if the action requested was succesful or not, before the server closes the connection.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-http-how-impl",
    "href": "Chapters/04-http-server.html#sec-http-how-impl",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.3 How a HTTP server is normally implemented?",
    "text": "7.3 How a HTTP server is normally implemented?\nLet‚Äôs use the C language as an example. There are many materials teaching how to write a simple HTTP server in C code, like Yu (2023), or Weerasiri (2023), or Meehan (2021). Having this in mind, I will not show C code examples here, because you can find them on the internet. But I will describe the theory behind the necessary steps to perform in the C code.\nIn essence, we normally implement a HTTP server in C using WebSocket technology, which involves the following steps:\n\nCreate a socket object.\nBind a name (or more specifically, an address) to this socket object.\nMake this socket object to start listening and waiting for incoming connections.\nWhen a connection arrive, we accept this connection, and we exchange the HTTP messages (HTTP Request and HTTP Response).\nThen, we simply close this connection.\n\nA socket object (which uses the WebSocket technology) is essentially a channel of communication. You are creating a channel where people can send messages to. When you create a socket object, this object is not binded to any particular address. This means that with this object you have a representation of a channel of communication in your hands. But this channel is not currently available, or, it is not currently accessible, because it do not have a known address where you can find it.\nThat is what the ‚Äúbind‚Äù operation do. It binds a name (or more specifically, an address) to this socket object, or, this channel of communication, so that it becomes available, or, accessible through this address. While the ‚Äúlisten‚Äù operation makes the socket object to listen for incoming connections in this address. In other words, the ‚Äúlisten‚Äù operation makes the socket to wait for incoming connections.\nNow, when a client actually attempts to connect to the server through the address we specify, then, the socket object needs to accept this incoming connection. When we accept it, then, the connection is established, client and server are now connected to each other, and they can read or write messages in this established connection.\nAfter we received the HTTP Request from the client, and sent the HTTP Response to the client, we can now close the connection, and end this communication.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#implementing-the-server---part-1",
    "href": "Chapters/04-http-server.html#implementing-the-server---part-1",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.4 Implementing the server - Part 1",
    "text": "7.4 Implementing the server - Part 1\n\n7.4.1 Creating the socket object\nLet‚Äôs begin with creating the socket for our server. Just to make things shorter, I will create this socket object in a separate Zig module. I will name it config.zig.\nIn Zig, we can create a web socket using the std.posix.socket() function, from the Zig Standard Library. As I meantioned earlier at Section 7.3, every socket object we create represents a communication channel, and we need to bind this channel to a specific address. An ‚Äúaddress‚Äù is defined as an IP address, or, more specifically, an IPv4 address2. Every IPv4 address is composed by two components. The first component is the host, which is a sequence of 4 numbers separated by dot characters (.) that identifies the machine used. While the second component is a port number, which identifies the specific door, or, the specific port to use in the host.\nThe sequence of 4 numbers (i.e.¬†the host) identifies the machine (i.e.¬†the computer itselft) where this socket will live in. Every computer normally have multiple ‚Äúdoors‚Äù available inside him, because this allows the computer to receive multiple connections at the same time. He simply use a single door for each connection. So the port number, is essentially a number that identifies the specific door in the computer that will be resposible for receiving the connection. That is, it identifies the ‚Äúdoor‚Äù in the computer that the socket will use to receive incoming connections.\nTo make things simpler, I will use an IP address that identifies our current machine in this example. This means that, our socket object will reside on the same computer that we are currently using (this is also known as the ‚Äúlocalhost‚Äù) to write this Zig source code.\nBy convention, the IP address that identifies the ‚Äúlocahost‚Äù, which is the current machine we are using, is the IP 127.0.0.1. So, that is the IP address we are going to use in our server. I can declare it in Zig by using an array of 4 integers, like this:\n\nconst localhost = [4]u8{\n    127, 0, 0, 1\n};\n_ = localhost;\n\nNow, we need to decide which port number to use. By convention, there are some port numbers that are reserved, meaning that, we cannot use them for our own purposes, like the port 22 (which is normally used for SSH connections). For TCP connections, which is our case here, a port number is a 16-bit unsigned integer (type u16 in Zig), thus ranging from 0 to 65535 (Wikipedia 2024). So, we can choose a number from 0 to 65535 for our port number. In the example of this book, I will use the port number 3490 (just a random number).\nNow that we have these two informations at hand, I can finally create our socket object, using the std.posix.socket() function. First, we use the host and the port number to create an Address object, with the std.net.Address.initIp4() function, like in the example below. After that, I use this address object inside the socket() function to create our socket object.\nThe Socket struct defined below summarizes all the logic behind this this process. In this struct, we have two data members, which are: 1) the address object; 2) and a stream object, which is the object we will use to read and write the messages into any connection we establish.\nNotice that, inside the constructor method of this struct, when we create the socket object, we are using the IPROTO.TCP property as an input to tell the function to create a socket for TCP connections.\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst net = @import(\"std\").net;\n\npub const Socket = struct {\n    _address: std.net.Address,\n    _stream: std.net.Stream,\n\n    pub fn init() !Socket {\n        const host = [4]u8{ 127, 0, 0, 1 };\n        const port = 3490;\n        const addr = net.Address.initIp4(host, port);\n        const socket = try std.posix.socket(\n            addr.any.family,\n            std.posix.SOCK.STREAM,\n            std.posix.IPPROTO.TCP\n        );\n        const stream = net.Stream{ .handle = socket };\n        return Socket{ ._address = addr, ._stream = stream };\n    }\n};\n\n\n\n7.4.2 Listening and receiving connections\nRemember that we stored the Socket struct declaration that we built at Section 7.4.1 inside a Zig module named config.zig. This is why I imported this module into our main module (main.zig) in the example below, as the SocketConf object, to access the Socket struct.\nOnce we created our socket object, we can focus now on making this socket object to listen and receive new incoming connections. We do that, by calling the listen() method from the Address object that is contained in the socket object, and then, we call the accept() method over the result.\nThe listen() method from the Address object produces a server object, which is an object that will stay open and running indefinitely, waiting to receive an incoming connection. Therefore, if you try to run the code example below, by calling the run command from the zig compiler, you will notice that the programs keeps running indefinitely, without a clear end.\nThis happens, because the program is waiting for something to happen. It is waiting for someone to try to connect to the address (http://127.0.0.1:3490) where the server is running and listening for incoming connections. This is what the listen() method do, it makes the socket to be active waiting for someone to connect.\nOn the other side, the accept() method is the function that establish the connection when someone try to connect to the socket. This means that, the accept() method returns a new connection object as a result. And you can use this connection object to read or write messages from or to the client. For now, we are not doing anything with this connection object. But we are going to use it on the next section.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n    _ = connection;\n}\n\nThis code example allows one single connection. In other words, the server will wait for one incoming connection, and as soon as the server is done with the first connection that it establishs, the program ends, and the server stops.\nThis is not the norm on the real world. Most people that write a HTTP server like this, usually put the accept() method inside a while (infinite) loop, where if a connection is created with accept(), a new thread of execution is created to deal with this new connection and the client. That is, real-world examples of HTTP Servers normally rely on parallel computing to work.\nWith this design, the server simply accepts the connection, and the whole process of dealing with the client, and receiving the HTTP Request, and sending the HTTP Response, all of this is done in the background, on a separate execution thread.\nSo, as soon as the server accepts the connection, and creates the separate thread, the server goes back to what he was doing, which is to wait indefinitely for a new connection to accept. Having this in mind, the code example exposed above, is a server that serves only a single client. Because the program terminates as soon as the connection is accepted.\n\n\n7.4.3 Reading the message from the client\nNow that we have a connection established, i.e.¬†the connection object that we created through the accept() function, we can now use this connection object to read any messages that the client send to our server. But we can also use it to send messages back to the client.\nThe basic idea is, if we write any data into this connection object, then, we are sending data to the client, and if we read the data present in this connection object, then, we are reading any data that the client sent to us, through this connection object. So, just have this logic in mind. ‚ÄúRead‚Äù is for reading messages from the client, and ‚Äúwrite‚Äù is to send a message to the client.\nRemember from Section 7.2 that, the first thing that we need to do is to read the HTTP Request sent by the client to our server. Because it is the first message that happens inside the established connection, and, as a consequence, it is the first thing that we need to deal with.\nThat is why, I‚Äôm going to create a new Zig module in this small project, named request.zig to keep all functions related to the HTTP Request together. Then, I will create a new function named read_request() that will use our connection object to read the message sent by the client, which is the HTTP Request.\n\nconst std = @import(\"std\");\nconst Connection = std.net.Server.Connection;\npub fn read_request(conn: Connection,\n                    buffer: []u8) !void {\n    const reader = conn.stream.reader();\n    _ = try reader.read(buffer);\n}\n\nThis function accepts a slice object which behaves as a buffer. The read_request() function reads the contents of the message sent into the connection object, and saves this content into this buffer object that we provided as input.\nNotice that I‚Äôm using the connection object that we created to read the message from the client. I first access the reader object that lives inside the connection object. Then, I call the read() method of this reader object to effectivelly read and save the data sent by the client into the buffer object that we created earlier. I‚Äôm discarting the return value of the read() method, by assigning it to the underscore character (_), because this return value is not useful for us right now.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#looking-at-the-current-state-of-the-program",
    "href": "Chapters/04-http-server.html#looking-at-the-current-state-of-the-program",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.5 Looking at the current state of the program",
    "text": "7.5 Looking at the current state of the program\nI think it is a good time to see how our program is currently working. Shall we? So, the first thing I will do is to update the main.zig module in our small Zig project, so that the main() function call this new read_request() function that we just created. I will also add a print statement at the end of the main() function, just so that you can see what the HTTP Request we just loaded into the buffer object looks like.\nAlso, I‚Äôm creating the buffer object in the main() function, which will be responsible for storing the message sent by the client, and, I‚Äôm also using a for loop to initialize all fields of this buffer object to the number zero. This is important to make sure that we don‚Äôt have uninitialized memory in this object. Because uninitialized memory may cause undefined behaviour in our program.\nSince the read_request() receives as input the buffer object as a slice object ([]u8), I am using the syntax array[0..array.len] to get access to a slice of this buffer object, and provide it as input to the function.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst Request = @import(\"request.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n    var buffer: [1000]u8 = undefined;\n    for (0..buffer.len) |i| {\n        buffer[i] = 0;\n    }\n    _ = try Request.read_request(\n        connection, buffer[0..buffer.len]\n    );\n    try stdout.print(\"{s}\\n\", .{buffer});\n}\n\nNow, I‚Äôm going to execute this program, with the run command from the zig compiler. But remember, as we sad earlier, as soon as I execute this program, it will hang indefinitely, because the program is waiting for a client trying to connect to the server.\nMore specifically, the program will pause at the line with the accept() call. As soon as a client try to connect to the server, then, the execution will ‚Äúunpause‚Äù, and the accept() function will finally be executed to create the connection object we need, and the remaining of the program will run.\nYou can see that at Figure¬†7.1. The message Server Addr: 127.0.0.1:3490 is printed to the console, and the program is now waiting for an incoming connection.\n\n\n\n\n\n\nFigure¬†7.1: A screenshot of running the program\n\n\n\nWell, we can finally try to connect to this server, and there are several ways we can do this. For example, we could use the following Python script:\nimport requests\nrequests.get(\"http://127.0.0.1:3490\")\nOr, we could also open any web browser of our preference, and type the URL localhost:3490. OBS: localhost is the same thing as the IP 127.0.0.1. When you press enter, and your web browser go to this address, first, the browser will probably print a message saying that ‚Äúthis page isn‚Äôt working‚Äù, and, then, it will probably change to a new message saying that ‚Äúthe site can‚Äôt be reached‚Äù.\nYou get these ‚Äúerror messages‚Äù in the web browser, because it got no response back from the server. In other words, when the web browser connected to our server, it did send the HTTP Request through the established connection. Then, the web browser was expecting to receive a HTTP Response back, but it got no response from the server (we didn‚Äôt implemented the HTTP Response logic yet).\nBut that is okay. We achieved the result that we wanted for now, which is to connect to the server, and see the HTTP Request that was sent by the web browser (or by the Python script) to the server.\nIf you comeback to the console that you left open when you executed the program, you will see that the program finished it‚Äôs execution, and, a new message is printed in the console, which is the actual HTTP Request message that was sent by the web browser to the server. You can see this message at Figure¬†7.2.\n\n\n\n\n\n\nFigure¬†7.2: A screenshot of the HTTP Request sent by the web browser",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-enum",
    "href": "Chapters/04-http-server.html#sec-enum",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.6 Learning about Enums in Zig",
    "text": "7.6 Learning about Enums in Zig\nEnums structures are available in Zig through the enum keyword. An enum (short for ‚Äúenumeration‚Äù) is a special structure that represents a group of constant values. So, if you have a variable which can assume a short and known set of values, you might want to associate this variable to an enum structure, to make sure that this variable only assumes a value from this set.\nA classic example for enums are primary colors. If for some reason, your program needs to represent one of the primary colors, you can create a enum that represents one of these colors. In the example below, we are creating the enum PrimaryColorRGB, which represents a primary color from the RGB color system. By using this enum, I am garanteed that the acolor object for example, will contain one of these three values: RED, GREEN or BLUE.\n\nconst PrimaryColorRGB = enum {\n    RED, GREEN, BLUE\n};\nconst acolor = PrimaryColorRGB.RED;\n_ = acolor;\n\nIf for some reason, my code tries to save in acolor, a value that is not in this set, I will get an error message warning me that a value such as ‚ÄúMAGENTA‚Äù do not exist inside the PrimaryColorRGB enum. Then I can easily fix my mistake.\n\nconst acolor = PrimaryColorRGB.MAGENTA;\n\ne1.zig:5:36: error: enum 'PrimaryColorRGB' has\n        no member named 'MAGENTA':\n    const acolor = PrimaryColorRGB.MAGENTA;\n                                   ^~~~~~~\nBehind the hood, enums in Zig work the same way that enums work in C. Each enum value is essentially represented as a integer. The first value in the set is represented as zero, then, the second value is one, ‚Ä¶ etc.\nOne thing that we are going to learn on the next section is that enums can have methods in them. Wait‚Ä¶ What? This is amazing! Yes, enums in Zig are similar to structs, and they can have private and public methods inside them.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#implementing-the-server---part-2",
    "href": "Chapters/04-http-server.html#implementing-the-server---part-2",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.7 Implementing the server - Part 2",
    "text": "7.7 Implementing the server - Part 2\nNow, on this section, I want to focus on parsing the HTTP Request we received from the client. However, to effectively parse a HTTP Request message, we first need to understand it‚Äôs structure. In summary, a HTTP Request is a text message that is divided into 3 different sections (or parts):\n\nThe top-level header indicating the method of the HTTP Request, the URI, and the HTTP version used in the message.\nA list of HTTP Headers.\nThe body of the HTTP Request.\n\n\n7.7.1 The top-level header\nThe first line of text in a HTTP Request always come with the three most essential information about the request being analyzed. These three key attributes of the HTTP Request are separated by a simple space in this first line of the request. The first information is the HTTP method that is being used in the request, second, we have the URI to which this HTTP Request is being sent to, and third, we have the version of the HTTP protocol that is being used in this HTTP Request.\nIn the snippet below, you will find an example of this first line in a HTTP Request. First, we have the the HTTP method of this request (GET). Many programmers refer to the URI component (/users/list) as the ‚ÄúAPI endpoint‚Äù to which the HTTP Request is being sent to. In the context of this specific request, since it is a GET request, you could also say that the URI component is the path to the resource we want to access, or, the path to the document (or the file) that we want to retrieve from the server.\nGET /users/list HTTP/1.1\nAlso, notice that this HTTP Request is using the version 1.1 of the HTTP protocol, which is the most popular version of the protocol used in the web.\n\n\n7.7.2 The list of HTTP headers\nMost HTTP Requests also include a section of HTTP Headers, which is just a list of attributes or key-value pairs associated with this particular request. This section always comes right after the ‚Äútop-level header‚Äù of the request.\nFor our purpose in this chapter, which is to build a simple HTTP Server, we are going to ignore this section of the HTTP Request, for simplicity. But most HTTP servers that exist in the wild parses and use these HTTP headers to change the way that the server responds to the request send by the client.\nFor example, many requests we encounter in the real-world comes with a HTTP header called Accept. In this header, we find a list of MIME types3. This list indicates the file formats that the client can read, or parse, or interpret. In other words, you also interpret this header as the client saying the following phrase to the server: ‚ÄúHey! Look, I can read only HTML documents, so please, send me back a document that is in a HTML format.‚Äù.\nSo, if the HTTP server can read and use this Accept header, then, the server can identify which is the best format of the document to send to the client. Maybe the HTTP server have the same document in multiple formats, for example, in JSON, in XML, in HTML and in PDF, but the client can only understand documents in the format HTML. That is the purpose of this Accept header.\n\n\n7.7.3 The body\nThe body comes after the list of HTTP headers, and it is an optional section of the HTTP Request, meaning that, not all HTTP Request will come with a body in it. For example, every HTTP Request that uses the GET method usually do not come with a body.\nBecause a GET request is used to request data, instead of sending it to the server. So, the body section is more related to the POST method, which is a method that involves sending data to the server, to be processed and stored.\nSince we are going to support only the GET method in this project, it means that we also do not need to care about the body of the request.\n\n\n7.7.4 Creating the HTTP Method enum\nEvery HTTP Request comes with a explicit method. The method used in a HTTP Request is identified by one these words:\n\nGET;\nPOST;\nOPTIONS;\nPATCH;\nDELETE;\nand some other methods.\n\nEach HTTP method is used for a specific type of task. The POST method for example is normally used to post some data into the destination. In other words, it is used to send some data to the HTTP server, so that it can be processed and stored by the server.\nAs another example, the GET method is normally used to get content from the server. In other words, we use this method whenever we want the server to send some content back to us. It can be any type of content. It can be a web page, a document file, or some data in JSON format.\nWhen a client send a POST HTTP Request, the HTTP Response sent by the server normally have the sole purpose of letting the client know if the server processed and stored the data succesfully. In contrast, when the server receives a GET HTTP Request, then, the server sends the content that the client asked for in the HTTP Response itself. This demonstrates that the method associated with the HTTP Request changes a lot on the dynamics and the roles that each party plays in the whole process.\nSince the HTTP method of the HTTP Request is identified by this very small and specific set of words, it would be interesting to create an enum structure to represent a HTTP method. This way, we can easily check if the HTTP Request we receive from the client is a HTTP method that we currently support in our small HTTP server project.\nThe Method structure below represents this enumeration. Notice that, for now, only the GET HTTP method is included in this enumeration. Because, for the purpose of this chapter, I want to implement only the GET HTTP method. That is why I am not including the other HTTP methods in this enumeration.\n\npub const Method = enum {\n    GET\n};\n\nNow, I think we should add two methods to this enum structure. One method is is_supported(), which will be a function that returns a boolean value, indicating if the input HTTP method is supported or not by our HTTP Server. The other is init(), which is a constructor function that takes a string as input, and tries to convert it into a Method value.\nBut in order to build these functions, I will use a functionality from the Zig Standard Library, called StaticStringMap(). This function allows us to create a simple map from strings to enum values. In other words, we can use this map structure to map a string to the respective enum value. To some extent, this specific structure from the standard library works almost like a ‚Äúhashtable‚Äù structure, and it is optmized for a small sets of words, or, a small set of keys, which is our case here.\nTo use this function, you have to import it from the std.static_string_map module. Just to make things shorter and easier to type, I am going to import this function through a different and shorter name (Map).\nWith Map() imported, we just apply this function over the enum structure that we are going to use in the resulting map. In our case here, it is the Method enum structure that we declared at the last code example. Then, I call the initComptime() method with the map, i.e.¬†the list of key-value pairs that we are going to use.\nYou can see in the example below that I write this map using multiple anonymous struct literals. Inside the first (or ‚Äútop-level‚Äù) struct literal we have a list (or a sequence) of struct literals. Each struct literal in this list represents a key-value pair. The first element in this struct is the key, while the second element is the value. The first element (or the key) in each key-value pair should always be a string value. While the second element should be a value from the enum structure that you used inside the Map() function.\n\nconst Map = std.static_string_map.StaticStringMap;\nconst MethodMap = Map(Method).initComptime(.{\n    .{ \"GET\", Method.GET },\n});\n\nTherefore, the MethodMap object is basically a std::map object from C++, or, a dict object from Python. You can retrieve (or get) the enum value that corresponds to a particular key, by using the get() method from the map object. This method returns an optional value, so, the get() method might result in a null value.\nWe can use this in our advantage to detect if a particular HTTP method is supported or not in our HTTP server. Because, if the get() method returns null, it means that it did not find this method inside our MethodMap object, and, as a consequence, this method is not supported by our HTTP server. In this specific case, a null value means ‚Äúnot supported method‚Äù.\nThe init() method below, takes a string value as input, and then, it simply passes this string value to the get() method of our MethodMap object. As consequence, we should get the enum value that corresponds to this input string.\nNotice in the example below that, the init() method returns either an error (which might happen if the ? method returns unreacheable, checkout Section 6.4.3 for more details) or a Method object as result. Since GET is currently the only value in our Method enum structure, it means that, the init() method will most likely return the value Method.GET as result.\nAlso notice that, in the is_supported() method, we are using the optional value returned by the get() method from our MethodMap object. The if statement unwrapes the optional value returned by this method, and returns true in case this optional value is a not-null value. Otherwise, it simply returns false.\n\npub const Method = enum {\n    GET,\n    pub fn init(text: []const u8) !Method {\n        return MethodMap.get(text).?;\n    }\n    pub fn is_supported(m: []const u8) bool {\n        const method = MethodMap.get(m);\n        if (method) |_| {\n            return true;\n        }\n        return false;\n    }\n};\n\n\n\n7.7.5 Writing the parse request function\nNow that we created the enum that represents our HTTP method, we should start to write the function responsible for actually parsing the HTTP Request. Let‚Äôs first, understand the structure of a HTTP Request.\nThe first thing we can do, is to write a struct to represent the HTTP Request. Take the Request struct below as an example. It contains the three essential information from the ‚Äútop-level‚Äù header (i.e.¬†the first line) in the HTTP Request.\n\nconst Request = struct {\n    method: Method,\n    version: []const u8,\n    uri: []const u8,\n    pub fn init(method: Method,\n                uri: []const u8,\n                version: []const u8) Request {\n        return Request{\n            .method = method,\n            .uri = uri,\n            .version = version,\n        };\n    }\n};\n\nThe parse_request() function should receive a string as input. This input string contains the entire HTTP Request message, and the parsing function should read and understand the individual parts of this message.\nNow, remember that for the purpose of this chapter, we care about only about the first line in this message, which contains the ‚Äútop-level header‚Äù, or, the three essential attributes about the HTTP Request, which are the HTTP method used, the URI and the HTTP version.\nNotice that I use the function indexOfScalar() in parse_request(). This function from the Zig Standard Library returns the first index where the scalar value that we provide happens in a string. In this case, I‚Äôm looking at the first occurrence of the new line character (\\n). Because once again, we care only about the first line in the HTTP Request message. This is the line where we have the three information we want to parse (version of HTTP, the HTTP method and the URI).\nTherefore, we are using this indexOfScalar() function to limit our parsing process to the first line in the message. Is also worth mentioning that, the indexOfScalar() function returns an optional value. That is why I use the orelse keyword to provide an alternative value, in case the value returned by the function is a null value.\nSince each of these three attributes are separated by a simple space, we could use the function splitScalar() from the Zig Standard Library to split the input string into sections by looking for every position that appears a simple space. In other words, this splitScalar() function is equivalent to the split() method in Python, or, the std::getline() function from C++, or the strtok() function in C.\nWhen you use this splitScalar() function you get an iterator as the result. This iterator have a next() method that you can use to advance the iterator to the next position, or, to the next section of the splitted string. Note that, when you use next(), the method not only advances the iterator, but it also returns a slice to the current section of the splitted string as result.\nNow, if you want to get a slice to the current section of the splitted string, but not advance the iterator to the next position, you can use the peek() method. Both next() and peek() methods return an optional value, that is why I use the ? method to unwrap these optional values.\n\npub fn parse_request(text: []u8) Request {\n    const line_index = std.mem.indexOfScalar(\n        u8, text, '\\n'\n    ) orelse text.len;\n    var iterator = std.mem.splitScalar(\n        u8, text[0..line_index], ' '\n    );\n    const method = try Method.init(iterator.next().?);\n    const uri = iterator.next().?;\n    const version = iterator.next().?;\n    const request = Request.init(method, uri, version);\n    return request;\n}\n\nHave you notice that the ‚Äústring utility functions‚Äù we imported from the Zig Standard Library, and that we applied over the input string, comes from the mem module (which is the ‚Äúmemory utility functions‚Äù module)?\nAs I described at Section 1.8, strings in Zig are simply arrays of bytes in the language. So, you will find inside this mem module lots of excellent utility functions to work directly with bytes and arrays in Zig, and, as a result, these functions will also be very useful if you have to work with string data.\n\n\n7.7.6 Using the parse request function\nNow that we wrote the function responsible for parsing the HTTP Request, we can add the function call to parse_request() in the main() function of our program.\nAfter, is a good idea to test once again the state of our program. I execute this program again with the run command from the zig compiler, then, I use my web browser to connect once again to the server through the URL localhost:3490, and finally, the end result of our Request object is printed to the console.\nA quick observation, since I used the any format specifier in the print statement, the data members version and uri of the Request struct were printed as raw integer values. String data being printed as integer values is commom in Zig, and remember, these integer values are just the decimal representation of the bytes that form the string in question.\nIn the result below, the sequence of decimal values 72, 84, 84, 80, 47, 49, 46, 49, and 13, are the bytes that form the text ‚ÄúHTTP/1.1‚Äù. And the integer 47, is the decimal value of the character /, which represents our URI in this request.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst Request = @import(\"request.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n\n    var buffer: [1000]u8 = undefined;\n    for (0..buffer.len) |i| {\n        buffer[i] = 0;\n    }\n    try Request.read_request(\n        connection, buffer[0..buffer.len]\n    );\n    const request = Request.parse_request(buffer[0..buffer.len]);\n    try stdout.print(\"{any}\\n\", .{request});\n}\n\nrequest.Request{\n    .method = request.Method.GET,\n    .version = {72, 84, 84, 80, 47, 49, 46, 49, 13},\n    .uri = {47}\n}\n\n\n7.7.7 Sending the HTTP Response to the client\nIn this last part, we are going to write the logic responsible for sending the HTTP Response from the server to the client. To make things simple, the server in this project will send just a simple web page containing the text ‚ÄúHello world‚Äù.\nFirst, I create a new Zig module in the project, named response.zig. In this module, I will declare just two functions. Each function corresponds to a specific status code in the HTTP Response. The send_200() function will send a HTTP Response with status code 200 (which means ‚ÄúSuccess‚Äù) to the client. While the send_404() sends a response with status code 404 (which means ‚ÄúNot found‚Äù).\nThis is definitely not the most ergonomic and adequate way of handling the HTTP Response, but it works for our case here. We are just building toy projects in this book after all. So, the source code we write do not need to be perfect. It just needs to work!\n\nconst std = @import(\"std\");\nconst Connection = std.net.Server.Connection;\npub fn send_200(conn: Connection) !void {\n    const message = (\n        \"HTTP/1.1 200 OK\\nContent-Length: 48\"\n        ++ \"\\nContent-Type: text/html\\n\"\n        ++ \"Connection: Closed\\n\\n&lt;html&gt;&lt;body&gt;\"\n        ++ \"&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n    );\n    _ = try conn.stream.write(message);\n}\n\npub fn send_404(conn: Connection) !void {\n    const message = (\n        \"HTTP/1.1 404 Not Found\\nContent-Length: 50\"\n        ++ \"\\nContent-Type: text/html\\n\"\n        ++ \"Connection: Closed\\n\\n&lt;html&gt;&lt;body&gt;\"\n        ++ \"&lt;h1&gt;File not found!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n    );\n    _ = try conn.stream.write(message);\n}\n\nNotice that both functions receives the connection object as input, and use the write() method to write the HTTP Response message directly into this communication channel. As result, the party in the other side of the connection (i.e.¬†the client), will receive such message.\nMost real-world HTTP Servers will have a single function (or a single struct) to effectively handle the response. It gets the HTTP Request already parsed as input, and then, it tries to build the HTTP Response bit by bit, before the function sends it over the connection.\nWe would also have a specialized struct to represent a HTTP Response, and a lot of methods that would be used to build each part or component of the response object. Take the Response struct created by the Javascript runtime Bun as an example. You can find this struct in the response.zig module4 in their GitHub project.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#the-end-result",
    "href": "Chapters/04-http-server.html#the-end-result",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "7.8 The end result",
    "text": "7.8 The end result\nWe can now, update once again our main() to incorporate our new functions from the respons.zig module. First I need to import this module into our main.zig module, then, I add the function calls to send_200() and send_404().\nNotice that I‚Äôm using if statements to decide which ‚Äúresponse function‚Äù to call, based specially on the URI present in the HTTP Request. If the user asked for a content (or a document) that is not present in our server, we should respond with a 404 status code. But since we have just a simple HTTP server, with no real documents to send, we can just check if the URI is the root path (/) or not to decide which function to call.\nAlso, notice that I‚Äôm using the function std.mem.eql() from the Zig Standard Library to check if the string from uri is equal or not the string \"/\". This function is used to check if two arrays are equal or not. In the first argument, you provide the type of the elements present in this array. While in the second and third arguments, you provide the arrays to be compared.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst Request = @import(\"request.zig\");\nconst Response = @import(\"response.zig\");\nconst Method = Request.Method;\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n\n    var buffer: [1000]u8 = undefined;\n    for (0..buffer.len) |i| {\n        buffer[i] = 0;\n    }\n    try Request.read_request(connection, buffer[0..buffer.len]);\n    const request = Request.parse_request(buffer[0..buffer.len]);\n    if (request.method == Method.GET) {\n        if (std.mem.eql(u8, request.uri, \"/\")) {\n            try Response.send_200(connection);\n        } else {\n            try Response.send_404(connection);\n        }\n    }\n}\n\nNow that we adjusted our main() function, I can now execute our program, and see the effects of these last changes. First, I execute the program once again, with the run command of the zig compiler. The program will hang, waiting for a client to connect.\nThen, I open my web browser, and try to connect to the server again, using the URL localhost:3490. This time, instead of getting ar ‚Äúerror message‚Äù from the browser, you will get the message ‚ÄúHello World‚Äù printed into your web browser. Because this time, the server sended the HTTP Response succesfully to the web browser, as demonstrated by Figure¬†7.3.\n\n\n\n\n\n\nFigure¬†7.3: The Hello World message sent in the HTTP Response\n\n\n\n\n\n\n\nMeehan, Eric. 2021. ‚ÄúCreating a Web Server from Scratch in c.‚Äù Youtube. https://www.youtube.com/watch?v=gk6NL1pZi1M&ab_channel=EricOMeehan.\n\n\nWeerasiri, Nipun Chamikara. 2023. ‚ÄúA Simple Web Server Written in c.‚Äù Medium. https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6.\n\n\nWikipedia. 2024. ‚ÄúPort (Computer Networking).‚Äù Wikipedia. https://en.wikipedia.org/wiki/Port_(computer_networking).\n\n\nYu, Jeffrey. 2023. ‚ÄúHow i Built a Simple HTTP Server from Scratch Using c.‚Äù DEV Community. https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#footnotes",
    "href": "Chapters/04-http-server.html#footnotes",
    "title": "7¬† Project 2 - Building a HTTP Server from scratch",
    "section": "",
    "text": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview.‚Ü©Ô∏é\nIt can be also an IPv6 address. But normally, we use a IPv4 address for that.‚Ü©Ô∏é\nhttps://en.wikipedia.org/wiki/Media_type.‚Ü©Ô∏é\nhttps://github.com/oven-sh/bun/blob/main/src/bun.js/webcore/response.zig.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Project 2 - Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html",
    "href": "Chapters/03-unittests.html",
    "title": "8¬† Unit tests",
    "section": "",
    "text": "8.1 Introducing the test block\nIn Zig, unit tests are written inside a test declaration, or, how I prefer to call it, inside a test block. Every test block is written by using the keyword test. You can optionally use a string literal to write a label, which is responsible for identifying the specific group of unit tests that you are writing inside this specific test block.\nIn the example below, we are testing if the sum of two objects (a and b) is equal to 4. The expect() function from the Zig Standard Library is a function that receives a logical test as input. If this logical test results in true, then, the test passes. But if it results in false, then, the test fails.\nYou can write any Zig code you want inside of each test block. Part of this code might be some necessary commands to setup your testing environment, or just initializing some necessary objects.\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\ntest \"testing simple sum\" {\n    const a: u8 = 2;\n    const b: u8 = 2;\n    try expect((a + b) == 4);\n}\nYou can have multiple test blocks written on the same Zig module. Also, you can mix test blocks with your source code, with no problems or consequences. If you mix test blocks with your normal source code, when you execute the build, build-exe, build-obj or build-lib commands from the zig compiler that we exposed at Section 1.2.4, these test blocks are automatically ignored by the compiler.\nIn other words, the zig compiler only builds and execute your tests when you ask it to. By default, the compiler always ignore test blocks written in your Zig modules. The compiler normally checks only if there are any syntax errors in these test blocks.\nIf you look at the source code for most of the files present in the Zig Standard Library1, you can see that the test blocks are written together with the normal source code of the library. You can see this for example, at the array_list module2. So, the standard that the Zig developers decided to adopt is to keep their unit tests together with the source code of the functionality that they are testing.\nEach programmer might have a different opinion on this. Some of them might prefer to keep unit tests separate from the actual source code of their application. If that is your case, you can simply create a separate tests folder in your project, and start writing Zig modules that contains only unit tests (as would normally do on a Python project with pytest, for example), and everything will work fine. It boils down to which is your preference here.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#how-to-run-your-tests",
    "href": "Chapters/03-unittests.html#how-to-run-your-tests",
    "title": "8¬† Unit tests",
    "section": "8.2 How to run your tests",
    "text": "8.2 How to run your tests\nIf the zig compiler ignores any test block by default, how can you compile and run your unit tests? The answer is the test command from the zig compiler. By running zig test command, the compiler will find every instance of test block in your Zig module, and, it will compile and run the unit tests you wrote.\nzig test simple_sum.zig\n1/1 simple_sum.test.testing simple sum... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-memory-allocations",
    "href": "Chapters/03-unittests.html#testing-memory-allocations",
    "title": "8¬† Unit tests",
    "section": "8.3 Testing memory allocations",
    "text": "8.3 Testing memory allocations\nOne of the advantages of Zig is that it offers great tools that hep us, programmers, to avoid (but also detect) memory problems, such as memory leaks and double-frees. The defer keyword is specially helpful in this regard.\nWhen developing your source code, you, the programmer, is responsible for making sure that your code do not produce such problems. However, you can also use a special type of allocator object in Zig, that is capable of automatically detect such problems for you. This is the std.testing.allocator object. This allocator object offers some basic memory safety detection features, which are capable of detecting memory leaks.\nAs we described at Section 3.1.5, to allocate memory on the heap, you need to use an allocator object, and your functions that use these objects to allocate memory on the heap, should receive an allocator object as one of it‚Äôs inputs. Every memory on the heap that you allocate using these allocator objects, must also be freed using this same allocator object.\nSo, if you want to test the memory allocations performed by your functions, and make sure that you don‚Äôt have problems in these allocations, you can simply write unit tests for these functions, where you provide the std.testing.allocator object as input to these functions.\nLook at the example below, where I‚Äôm defining a function that clearly causes a memory leak. Because we allocate memory with the allocator object, but we do not free this allocated memory in any point. So, when the function returns, we lose the reference to the buffer object, which contains the allocated memory, and, as a result, we can no longer free this memory.\nNotice that, inside a test block I execute this function with the std.testing.allocator. Since no visible errors were raised inside the test block, the zig compiler completes the process indicating that the unit tests performed inside the test block labeled as \"memory leak have all passed. But despite this result, the allocator object was capable of looking deeper in our program, and detecting the memory leak. As a result, this allocator object returns a message ‚Äútests leaked memory‚Äù, and also, a stack trace showing the exact point where the memory was leaked.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nfn some_memory_leak(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u32, 10);\n    _ = buffer;\n    // Return without freeing the\n    // allocated memory\n}\n\ntest \"memory leak\" {\n    const allocator = std.testing.allocator;\n    try some_memory_leak(allocator);\n}\n\nTest [1/1] leak_memory.test.memory leak...\n    [gpa] (err): memory address 0x7c1fddf39000 leaked: \n./ZigExamples/debugging/leak_memory.zig:4:39: 0x10395f2\n    const buffer = try allocator.alloc(u32, 10);\n                                      ^\n./ZigExamples/debugging/leak_memory.zig:12:25: 0x10398ea\n    try some_memory_leak(allocator);\n\n... more stack trace",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-errors",
    "href": "Chapters/03-unittests.html#testing-errors",
    "title": "8¬† Unit tests",
    "section": "8.4 Testing errors",
    "text": "8.4 Testing errors\nOne commom style of unit tests are those that look for specific errors in your functions. In other words, you write a unit test that tries to assert if a specific function call returns any error, or a specific type of error.\nIn C++ you would normally write this stye of unit test using, for example, the functions REQUIRE_THROWS() or CHECK_THROWS() from the Catch2 test framework3. In the case of a Python project, you would use the raises() function from pytest4. While in Rust, you would probably use assert_eq!() in conjunction with Err().\nBut in Zig, we use the expectError() function, from the std.testing module. With this function, you can test if a specific function call returns the exact type of error that you expect it to return. To use this function, you first write try expectError(). Then, on the first argument, you provide the type of error that you are expecting from the function call. Then, on the second argument, you write the function call you expect to fail.\nThe code example below demonstrates such type of unit test in Zig. Notice that, inside the function alloc_error() we are allocating 100 bytes of memory, or, an array of 100 elements, for the object ibuffer. However, in the test block, we are using the FixedBufferAllocator() allocator object, which is limited to 10 bytes of space, because the object buffer, which we provided to the allocator object, have only 10 bytes of space.\nThat is why, the alloc_error() function raises an OutOfMemory error on this case. Because this function is trying to allocate more space than the allocator object allows. So, in essence, we are testing for a specific type of error, which is OutOfMemory. If the alloc_error() function returns any other type of error, then, the expectError() function would make the entire test fail.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expectError = std.testing.expectError;\nfn alloc_error(allocator: Allocator) !void {\n    var ibuffer = try allocator.alloc(u8, 100);\n    defer allocator.free(ibuffer);\n    ibuffer[0] = 2;\n}\n\ntest \"testing error\" {\n    var buffer: [10]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    try expectError(error.OutOfMemory, alloc_error(allocator));\n}\n\n1/1 oom.test.testing error... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-simple-equalities",
    "href": "Chapters/03-unittests.html#testing-simple-equalities",
    "title": "8¬† Unit tests",
    "section": "8.5 Testing simple equalities",
    "text": "8.5 Testing simple equalities\nIn Zig, there are some different ways you can test for an equality. You already saw that we can use expect() with the logical operator == to essentially reproduce an equality test. But we also have some helper functions that you should know about, specially expectEqual(), expectEqualSlices() and expectEqualStrings().\nThe expectEqual() function, as the name suggests, is a classic test equality function. It receives two objects as input. The first object is the value that you expect to be in the second object. While second object is the object you have, or, the object that your application produced as result. So, with expectEqual() you are essentially testing if the values stored inside the two provided objects are equal or not.\nYou can see in the example below that, the test performed by expectEqual() failed. Because the objects v1 and v2 contain different values in them.\n\nconst std = @import(\"std\");\ntest \"values are equal?\" {\n    const v1 = 15;\n    const v2 = 18;\n    try std.testing.expectEqual(v1, v2);\n}\n\n1/1 ve.test.values are equal?...\n    expected 15, found 18\n    FAIL (TestExpectedEqual)\nve.zig:5:5: test.values are equal? (test)\n    try std.testing.expectEqual(v1, v2);\n    ^\n0 passed; 0 skipped; 1 failed.\nAlthough useful, the expectEqual() function does not work with arrays. For testing if two arrays are equal, you should use the expectEqualSlices() function instead. This function have three arguments. First, you provide the data type contained in both arrays that you are trying to compare. While the second and third arguments corresponds to the array objects that you want to compare.\nIn the example below, we are using this function to test if two array objects (array1 and array2) are equal or not. Since they are in fact equal, the unit test passed with no errors.\n\nconst std = @import(\"std\");\ntest \"arrays are equal?\" {\n    const array1 = [3]u32{1, 2, 3};\n    const array2 = [3]u32{1, 2, 3};\n    try std.testing.expectEqualSlices(\n        u32, &array1, &array2\n    );\n}\n\n1/1 oom.test.arrays are equal?... OK\nAll 1 tests passed.\nAt last, you might also want to use the expectEqualStrings() function. As the name suggests, you can use this function to test if two strings are equal or not. Just provide the two string objects that you want to compare, as inputs to the functions.\nIf the function finds any existing difference between the two strings, then, the function will raise an error, and also, print an error message that shows the exact difference between the two string objects provided, as the example below demonstrates:\n\nconst std = @import(\"std\");\ntest \"strings are equal?\" {\n    const str1 = \"hello, world!\";\n    const str2 = \"Hello, world!\";\n    try std.testing.expectEqualStrings(\n        str1, str2\n    );\n}\n\n1/1 t.test.strings are equal?... \n====== expected this output: =========\nhello, world!‚êÉ\n======== instead found this: =========\nHello, world!‚êÉ\n======================================\nFirst difference occurs on line 1:\nexpected:\nhello, world!\n^ ('\\x68')\nfound:\nHello, world!\n^ ('\\x48')",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#footnotes",
    "href": "Chapters/03-unittests.html#footnotes",
    "title": "8¬† Unit tests",
    "section": "",
    "text": "https://github.com/ziglang/zig/tree/master/lib/std‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/array_list.zig‚Ü©Ô∏é\nhttps://github.com/catchorg/Catch2/tree/devel‚Ü©Ô∏é\nhttps://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Unit tests</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html",
    "href": "Chapters/07-build-system.html",
    "title": "9¬† Build System",
    "section": "",
    "text": "9.1 How source code is built?\nWe already talked about the challenges of building source code in low-level languages at Section 1.2.1. As we described at that section, programmers invented Build Systems to surpass these challenges on the building processes of low-level languages.\nLow-level languages uses a compiler to compile (or to build) your source code into binary instructions. In C and C++, we normally use compilers like gcc, g++ or clang to compile our C and C++ source code into these instructions. Every language have it‚Äôs own compiler, and this is no different in Zig.\nIn Zig, we have the zig compiler to compile our Zig source code into binary instructions that can be executed by our computer. In Zig, the compilation (or the build) process involves the following components:\nThese are the things that you need to connect together in order to build your source code in Zig. In C and C++, you would have an extra component, which is the header files of the libraries that you are using. But header files do not exist in Zig, so, you only need to care about them if you are linking your Zig source code with a C library. If that is not your case, you can forget about it.\nYour build process is usually organized in a build script. In Zig, we normally write this build script into a Zig module in the root directory of our project, named as build.zig. You write this build script, then, when you run it, your project get‚Äôs built into binary files that you can use and distribute to your users.\nThis build script is normally organized around target objects. A target is simply something to be built, or, in other words, it‚Äôs something that you want the zig compiler to build for you. This concept of ‚Äútargets‚Äù is present in most Build Systems, specially in CMake3.\nThere are four types of target objects that you can build in Zig, which are:\nWe are going to talk more about these target objects at Section 9.3.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#how-source-code-is-built",
    "href": "Chapters/07-build-system.html#how-source-code-is-built",
    "title": "9¬† Build System",
    "section": "",
    "text": "The Zig modules that contains your source code;\nLibrary files (either a dynamic library or a static library);\nCompiler flags that tailors the build process to your needs.\n\n\n\n\n\n\nAn executable, which is simply a binary executable file (e.g.¬†a .exe file on Windows).\nA shared library, which is simply a binary library file (e.g.¬†a .so file in Linux or a .dll file on Windows).\nA static library, which is simply a binary library file (e.g.¬†a .a file in Linux or a .lib file on Windows).\nAn unit tests executable, which is an executable file that executes only unit tests.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-build-fun",
    "href": "Chapters/07-build-system.html#sec-build-fun",
    "title": "9¬† Build System",
    "section": "9.2 The build() function",
    "text": "9.2 The build() function\nA build script in Zig always contains a public (and top-level) build() function declared. It is like the main() function on the main Zig module of your project, that we discussed at Section 1.2.3. But instead of creating the entrypoint to your code, this build() function is the entrypoint to the build process.\nThis build() function should accept a pointer to a Build object as input, and it should use this ‚Äúbuild object‚Äù to perform the necessary steps to build your project. The return type of this function is always void, and this Build struct comes directly from the Zig Standard Library (std.Build). So, you can access this struct by just importing the Zig Standard Library into your build.zig module.\nJust as a very simple example, here you can see the source code necessary to build an executable file from the hello.zig Zig module.\n\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_source_file = b.path(\"hello.zig\"),\n        .target = b.host,\n    });\n    b.installArtifact(exe);\n}\n\nYou can define and use other functions and objects in this build script. You can also import other Zig modules as you would normally do in any other module of your project. The only real requirement for this build script, is to have a public and top-level build() function defined, that accepts a pointer to a Build struct as input.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-targets",
    "href": "Chapters/07-build-system.html#sec-targets",
    "title": "9¬† Build System",
    "section": "9.3 Target objects",
    "text": "9.3 Target objects\nAs we described over the previous sections, a build script is composed around target objects. Each target object is normally a binary file (or an output) that you want to get from the build process. You can list multiple target objects in your build script, so that the build process generates multiple binary files for you at once.\nFor example, you may be a developer working in a cross-platform application, and, because this application is cross-platform, you probably need to realease binary files of your software for each OS supported by your application to your end users. You can define a target object in your build script for each OS (Windows, Linux, etc.) where you want to publish your software. This will make the zig compiler to build your project to multiple target OS‚Äôs at once. The Zig Build System official documentation have a great code example that demonstrates this strategy4.\nA target object is created by the following methods of the Build struct that we introduced at Section 9.2:\n\naddExecutable() creates an executable file;\naddSharedLibrary() creates a shared library file;\naddStaticLibrary() creates a static library file;\naddTest() creates an executable file that executes unit tests.\n\nThese functions are methods from the Build struct that you receive as input of the build() function. All of them, create as output a Compile object, which represents a target object to be compiled by the zig compiler. All of these functions accept a similar struct literal as input. This struct literal defines three essential specs about this target object that you are building: name, target and root_source_file.\nWe already saw these three options being used on the previous example, where we used the addExecutable() method to create an executable target object. This example is reproduced below. Notice the use of the path() method from the Build struct, to define a path in the root_source_file option.\n\nexe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n\nThe name option specificy the name that you want to give to the binary file defined by this target object. So, in this example, we are building an executable file named hello. Is traditional to set this name option to the name of your project.\nFurthermore, the target option specify the target computer architecture (or the target operational system) of this binary file. For example, if you want this target object to run on a Windows machine that uses a x86_64 architecture, you can set this target option to x86_64-windows-gnu for example. This will make the zig compiler to compile the project to run on a x86_64 Windows machine. You can see the full list of architectures and OS‚Äôs that the zig compiler supports by running the zig targets command in the terminal.\nNow, if you are building the project to run on the current machine that you are using to run this build script, you can set this target option to the host method of the Build object, like we did in the example above. This host method identifies the current machine where you are currently running the zig compiler.\nAt last, the root_source_file option specifies the root Zig module of your project. That is the Zig module that contains the entrypoint to your application (i.e.¬†the main() function), or, the main API of your library. This also means that, all the Zig modules that compose your project are automatically discovered from the import statements that you have inside this ‚Äúroot source file‚Äù. The zig compiler can detect when a Zig module depends on the other through the import statements, and, as a result, it can discover the entire map of Zig modules used in your project.\nThis is handy, and it is different from what happens in other build systems. In CMake for example, you have to explicitly list the paths to all source files that you want to include in your build process. This is probably a symptom of the ‚Äúlack of conditional compilation‚Äù in C and C++ compilers. Since they lack this feature, you have to explicitly choose which source files are sent to the C/C++ compiler, since not every C/C++ code is portable or supported in every operational system, and, therefore, would cause a compilation error in the C/C++ compiler.\nNow, one important detail about the build process is that, you have to explicitly install the target objects that you create in your build script, by using the installArtifact() method of the Build struct.\nEverytime you invoke the build process of your project, by calling the build command of the zig compiler, a new directory named zig-out is created in the root directory of your project. This new directory contains the output of the build process, that is, the binary files built from your source code.\nWhat the installArtifact() method do is install (or copy) the built target objects that you defined to this zig-out directory. This means that, if you do not install the target objects you define in your build script, these target objects are essentially discarded at the end of the build process.\nFor example, you might be building a project that uses a third party library that is built together with the project. So, when you build your project, you would need first, to build the third party library, and then, you link it with the source code of your project. So, in this case, we have two binary files that are generated in the build process (the executable file of your project, and the third party library). But only one is of interest, which is the executable file of our project. We can discard the binary file of the third party library, by simply not installing it into this zig-out directory.\nSo, is easy to use this installArtifact() method. Just remember to apply it to every target object that you want to save it into the zig-out directory, like in the example below:\n\nexe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n\nb.installArtifact(exe);",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#setting-the-build-mode",
    "href": "Chapters/07-build-system.html#setting-the-build-mode",
    "title": "9¬† Build System",
    "section": "9.4 Setting the build mode",
    "text": "9.4 Setting the build mode\nWe talked about the three essential options that are set when you create a new target object. But there is also a fourth option that you can use to set the build mode of this target object, which is the optimize option. This option is called this way, because the build modes in Zig are treated more of an ‚Äúoptimization vs safety‚Äù problem. So optmization plays an important role here. Don‚Äôt worry, I‚Äôm going back to this question very soon.\nIn Zig, we have the four build modes listed below. Each one of these build modes offer different advantages and characteristics. As we described at Section 5.2.1, the zig compiler uses the Debug build mode by default, when you don‚Äôt explicitly choose a build mode.\n\nDebug, mode that produces and includes debugging information in the output of the build process (i.e.¬†the binary file defined by the target object);\nReleaseSmall, mode that tries to produce a binary file that is small in size;\nReleaseFast, mode that tries to optimize your code, in order to produce a binary file that is as fast as possible;\nReleaseSafe, mode that tries to make your code as safe as possible, by including safeguards when possible.\n\nSo, when you build your project, you can set the build mode of your target object to ReleaseFast for example, which will tell the zig compiler to apply important optimizations in your code. This creates a binary file that simply runs faster on most contexts, because it contains a more optimized version of your code. However, as a result, we normally loose some security funcionalities in our code. Because some safety checks are removed from the final binary file, which makes your code run faster, but in a less safe manner.\nThis choice depends on your current priorities. If you are building a cryptography or banking system, you might prefer to prioritize safety in your code, so, you would choose the ReleaseSafe build mode, which is a little slower to run, but much more secure, because it includes all possible runtime safety checks in the binary file built in the build process. In the other hand, if you are writing a game for example, you might prefer to prioritize performance over safety, by using the ReleaseFast build mode, so that your users can experience faster frame rates in your game.\nIn the example below, we are creating the same target object that we used on previous examples. But this time, we are specifying the build mode of this target object to use the ReleaseSafe mode.\n\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n    .optimize = .ReleaseSafe\n});\nb.installArtifact(exe);",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#setting-the-version-of-your-build",
    "href": "Chapters/07-build-system.html#setting-the-version-of-your-build",
    "title": "9¬† Build System",
    "section": "9.5 Setting the version of your build",
    "text": "9.5 Setting the version of your build\nEverytime you build a target object in your build script, you can assign a version number to this specific build, following a semantic versioning framework. You can find more about semantic versioning by visiting the Semantic Versioning website5. Anyway, in Zig, you can specify the version of your build, by providing a SemanticVersion struct to the version option, like in the example below:\n\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n    .version = .{\n        .major = 2, .minor = 9, .patch = 7\n    }\n});\nb.installArtifact(exe);",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-detect-os",
    "href": "Chapters/07-build-system.html#sec-detect-os",
    "title": "9¬† Build System",
    "section": "9.6 Detecting the OS in your build script",
    "text": "9.6 Detecting the OS in your build script\nIs very commom in Build Systems to use different options, or, to include different modules, or, to link against different libraries depending on the Operational System (OS) that you are targeting in the build process.\nIn Zig, you can detect the target OS of the build process, by looking at the os.tag inside the builtin module from the Zig library. In the example below, we are using an if statement to run some arbitrary code when the target of the build process is a Windows system.\n\nconst builtin = @import(\"builtin\");\nif (builtin.target.os.tag == .windows) {\n    // Code that runs only when the target of\n    // the compilation process is Windows.\n}",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#adding-a-run-step-to-your-build-process",
    "href": "Chapters/07-build-system.html#adding-a-run-step-to-your-build-process",
    "title": "9¬† Build System",
    "section": "9.7 Adding a run step to your build process",
    "text": "9.7 Adding a run step to your build process\nOne thing that is neat in Rust is that you can compile and run your source code with one single command (cargo run) from the Rust compiler. We saw at Section 1.2.5 how can we perform a similar job in Zig, by building and running our Zig source code through the run command from the zig compiler.\nBut how can we, at the same time, build and run the binary file specified by a target object in our build script? The answer is by including a ‚Äúrun artifact‚Äù in our build script. A run artifact is created through the addRunArtifact() method from the Build struct. We simply provide as input to this function the target object that describes the binary file that we want to execute, and the function creates as output, a run artifact capable of executing this binary file.\nIn the example below, we are defining an executable binary file named hello, and we use this addRunArtifact() method to create a run artifact that will execute this hello executable file.\n\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"src/hello.zig\"),\n    .target = b.host\n});\nb.installArtifact(exe);\nconst run_arti = b.addRunArtifact(exe);\n\nNow that we created the run artifact, we need to include it in the build process. We do that by declaring a new step in our build script to call this artifact, through the step() method of the Build struct. We can give any name we want to this step, but, for our context here, I‚Äôm going to name this step as ‚Äúrun‚Äù. Also, I give it a brief description to this step (‚ÄúRun the project‚Äù).\n\nconst run_step = b.step(\n    \"run\", \"Run the project\"\n);\n\nNow that we declared this ‚Äúrun step‚Äù we need to tell Zig that this ‚Äúrun step‚Äù depends on the run artifact. In other words, a run artifact always depends on a ‚Äústep‚Äù to effectively be executed. By creating this dependency we finally stablish the necessary commands to build and run the executable file from the build script.\nWe establish a dependency between the run step and the run artifact by using the dependsOn() method from the run step. So, we first create the run step, and then, we link it with the run artifact, by using this dependsOn() method from the run step.\n\nrun_step.dependOn(&run_arti.step);\n\nThe entire source code of this specific build script that we wrote, piece by piece, in this section, is available in the build_and_run.zig module. You can see this module by visiting the official repository of this book 6.\nWhen you declare a new step in your build script, this step becomes available through the build command in the zig compiler. You can actually see this step by running zig build --help in the terminal, like in the example below, where we can see that this new ‚Äúrun‚Äù step that we declared in the build script appeared in the output.\nzig build --help\nSteps:\n  ...\n  run   Run the project\n  ...\nNow, everything that we need to is to call this ‚Äúrun‚Äù step that we created in our build script. We call it by using the name that we gave to this step after the build command from the zig compiler. This will cause the compiler to build our executable file and execute it at the same time.\nzig build run",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#build-unit-tests-in-your-project",
    "href": "Chapters/07-build-system.html#build-unit-tests-in-your-project",
    "title": "9¬† Build System",
    "section": "9.8 Build unit tests in your project",
    "text": "9.8 Build unit tests in your project\nWe talk at length about writing unit tests in Zig, and we also talk about how to execute these unit tests through the test command of the zig compiler at Chapter 8. However, as we did with the run command on the previous section, we also might want to include some commands in our build script to also build and execute the unit tests in our project.\nSo, once again, we are going to discuss how a specific built-in command from the zig compiler, (in this case, the test command) can be used in a build script in Zig. This means that, we can include a step in our build script to build and run all unit tests in our project at once.\nHere is where a ‚Äútest target object‚Äù comes into play. As was described at Section 9.3, we can create a test target object by using the addTest() method of the Build struct. So the first thing that we need to do is to declare a test target object in our build script.\n\nconst test_exe = b.addTest(.{\n    .name = \"unit_tests\",\n    .root_source_file = b.path(\"src/main.zig\"),\n    .target = b.host,\n});\nb.installArtifact(test_exe);\n\nA test target object essentially filter all test blocks in all Zig modules across your project, and builds only the source code present inside these test blocks in your project. As a result, this target object creates an executable file that contains only the source code present in all of these test blocks (i.e.¬†the unit tests) in your project.\nPerfect! Now that we declared this test target object, an executable file named unit_tests is built by the zig compiler when we trigger the build script with the build command. After the build process is finished, we can simply execute this unit_tests executable in the terminal.\nHowever, if you remember the previous section, we already learned how can we create a run step in our build script, to execute an executable file built by the build script.\nSo, we could simply add a run step in our build script to run these unit tests from a single command in the zig compiler, to make our lifes easier. In the example below, we demonstrate the commands to register a new build step called ‚Äútests‚Äù in our build script to run these unit tests.\n\nconst run_arti = b.addRunArtifact(test_exe);\nconst run_step = b.step(\"tests\", \"Run unit tests\");\nrun_step.dependOn(&run_arti.step);\n\nNow that we registered this new build step, we can trigger it by calling the command below in the terminal. You can also checkout the complete source code for this specific build script at the build_tests.zig module at the official repository of this book 7.\nzig build tests",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#tailoring-your-build-process-with-user-provided-options",
    "href": "Chapters/07-build-system.html#tailoring-your-build-process-with-user-provided-options",
    "title": "9¬† Build System",
    "section": "9.9 Tailoring your build process with user-provided options",
    "text": "9.9 Tailoring your build process with user-provided options\nSometimes, you want to make a build script that is customizable by the user of your project. You can do that by creating user-provided options in your build script. In Zig, we create these options using the option() method from the Build struct.\nWith this method, we create a ‚Äúbuild option‚Äù which can be passed to the build.zig script at the command line. The user have the power of setting this option at the build command from the zig compiler. In other words, each build option that we create becomes a new command line argument accessible in the build command of the compiler.\nThese ‚Äúuser-provided options‚Äù are set by using the prefix -D in the command line. For example, if we declare an option named use_zlib, that receives a boolean value which indicates if we should link our source code to zlib or not, we can set the value of this option in the command line with -Duse_zlib. The code example below demonstrates this idea:\n\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const use_zlib = b.option(\n        bool,\n        \"use_zlib\",\n        \"Should link to zlib?\"\n    ) orelse false;\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_source_file = b.path(\"example.zig\"),\n        .target = b.host,\n    });\n    if (use_zlib) {\n        exe.linkSystemLibrary(\"zlib\");\n    }\n    b.installArtifact(exe);\n}\n\nYou can set this use_zlib option at the command line when you are invoking the build command from the zig compiler. In the example below, we set this option to false, which means that the build script will not link our binary executable to the zlib library.\nzig build -Duse_zlib=false",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#linking-to-external-libraries",
    "href": "Chapters/07-build-system.html#linking-to-external-libraries",
    "title": "9¬† Build System",
    "section": "9.10 Linking to external libraries",
    "text": "9.10 Linking to external libraries\nOne essential part of every build process is the linking stage. This stage is responsible for combining the multiple object files that represent your code, into a single executable file. It also links this executable file to an external libraries, if you use any in your code.\nIn Zig, we have two notions of a ‚Äúlibrary‚Äù, which are: 1) a system‚Äôs library; 2) a local library. A system‚Äôs library is just a library that already is installed in your system. While a local library is a library that belongs to the current project. Is a library that is present in your project directory, and that you are building together with your project source code.\nThe basic difference between the two, is that a system‚Äôs library is already built and installed in your system, supposedly, and all you need to do is to link your source code to this library to start using it. We do that by using the linkSystemLibrary() method from a Compile object. This method accepts the name of the library in a string as input. Remember from Section 9.3 that a Compile object is a target object that you declare in your build script.\nWhen you link a particular target object with a system‚Äôs library, the zig compiler will use pkg-config to find where in your system are the binary files and also the header files of this library that you requested for. When it finds these files, the linker present in the zig compiler will link your object files with the files of this library to produce a single executable file.\nIn the example below, we are creating an executable file named image_filter, and, we are linking this executable file to the C Standard Library with the method linkLibC(), but we also are linking this executable file to the C library libpng that is currently installed in my system.\n\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"image_filter\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.linkLibC();\n    exe.linkSystemLibrary(\"png\");\n    b.installArtifact(exe);\n}\n\nIf you are linking with a C library in your project, is generally a good idea to also link your code with the C Standard Library. Because is very likely that this C library uses some functionality of the C Standard Library at some point. The same goes to C++ libraries. So, if you are linking with C++ libraries, is a good idea to link your project with the C++ Standard Library using the linkLibCpp() method.\nOn the order side, when you want to link with a local library, you should use the linkLibrary() method of a Compile object. This method expects to receive another Compile object as input. That is, another target object defined in your build script, using either the addStaticLibrary() or addSharedLibrary() methods which defines a library to be built.\nBecause as we discussed earlier, a local library is a library that is local to your project, and that is being built together with your project. So, you need to create a target object in your build script to build this local library. Then, you link the target objects of interest in your project, with this target object that identifies this local library.\nTake a look at this example extracted from the build script of the libxev library8. You can see in this snippet that we are declaring a shared library file, from the c_api.zig module. Then later in the build script, we declare an executable file named ‚Äúdynamic-binding-test‚Äù, which links to this shared library that we defined earlier in the script.\n\nconst optimize = b.standardOptimizeOption(.{});\nconst target = b.standardTargetOptions(.{});\n\nconst dynamic_lib = b.addSharedLibrary(.{\n    .name = dynamic_lib_name,\n    .root_source_file = b.path(\"src/c_api.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\nb.installArtifact(dynamic_lib);\n// ... more lines in the script\nconst dynamic_binding_test = b.addExecutable(.{\n    .name = \"dynamic-binding-test\",\n    .target = target,\n    .optimize = optimize,\n});\ndynamic_binding_test.linkLibrary(dynamic_lib);",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-building-c-code",
    "href": "Chapters/07-build-system.html#sec-building-c-code",
    "title": "9¬† Build System",
    "section": "9.11 Building C code",
    "text": "9.11 Building C code\nThe zig compiler comes with a C compiler embedded in it. In other words, you can use the zig compiler to build C projects. This C compiler is available through the cc command of the zig compiler.\nAs an example, let‚Äôs use the famous FreeType library9. FreeType is one of the most widely used pieces of software in the world. It is a C library designed to produce high-quality fonts. But it is also heavily used in the industry to natively render text and fonts in the screen of your computer.\nIn this section, we are going to write a build script, piece by piece, that is capable of building the FreeType project from source. You can find the source code of this build script on the freetype-zig repository10 available at GitHub.\nAfter you download the source code of FreeType from the official website11, you can start writing the build.zig module. We begin by defining the target object that defines the binary file that we want to compile.\nAs an example, I will build the project as a static library file using the addStaticLibrary() method to create the target object. Also, since FreeType is a C library, I will also link the library against libc through the linkLibC() method, to garantee that any use of the C Standard Library is covered in the compilation process.\n\nconst target = b.standardTargetOptions(.{});\nconst opti = b.standardOptimizeOption(.{});\nconst lib = b.addStaticLibrary(.{\n    .name = \"freetype\",\n    .optimize = opti,\n    .target = target,\n});\nlib.linkLibC();\n\n\n9.11.1 Creating C compiler flags\nCompiler flags are also known as ‚Äúcompiler options‚Äù by many programmers, or also, as ‚Äúcommand options‚Äù in the GCC official documentation. It‚Äôs fair to also call them as the ‚Äúcommand-line arguments‚Äù of the C compiler. In general, we use compiler flags to turn on (or turn off) some features from the compiler, or to tweak the compilation process to fit the needs of our project.\nIn build scripts written in Zig, we normally list the C compiler flags to be used in the compilation process in a simple array, like in the example below.\n\nconst c_flags = [_][]const u8{\n    \"-Wall\",\n    \"-Wextra\",\n    \"-Werror\",\n};\n\nIn theory, there is nothing stopping you from using this array to add ‚Äúinclude paths‚Äù (with the -I flag) or ‚Äúlibrary paths‚Äù (with the -L flag) to the compilation process. But there are formal ways in Zig to add these types of paths in the compilation process. Both are discussed at Section 9.11.5 and Section 9.11.4.\nAnyway, in Zig, we add C flags to the build process together with the C files that we want to compile, using the addCSourceFile() and addCSourceFiles() methods. In the example above, we have just declared the C flags that we want to use. But we haven‚Äôt added them to the build process yet. To do that, we also need to list the C files to be compiled.\n\n\n9.11.2 Listing your C files\nThe C files that contains ‚Äúcross-platform‚Äù source code are listed in the c_source_files object below. These are the C files that are included by default in every platform supported by the FreeType library. Now, since the amount of C files in the FreeType library is big, I have omitted the rest of the files in the code example below, for brevity purposes.\n\nconst c_source_files = [_][]const u8{\n    \"src/autofit/autofit.c\",\n    \"src/base/ftbase.c\",\n    // ... and many other C files.\n};\n\nNow, in addition to ‚Äúcross-platform‚Äù source code, we also have some C files in the FreeType project that are platform-specific, meaning that, they contain source code that can obly be compiled in specific platforms, and, as a result, they are only included in the build process on these specific target platforms. The objects that list these C files are exposed in the code example below.\n\nconst windows_c_source_files = [_][]const u8{\n    \"builds/windows/ftdebug.c\",\n    \"builds/windows/ftsystem.c\"\n};\nconst linux_c_source_files = [_][]const u8{\n    \"src/base/ftsystem.c\",\n    \"src/base/ftdebug.c\"\n};\n\nNow that we declared both the files that we want to include and the C compiler flags to be used, we can add them to the target object that describes the FreeType library, by using the addCSourceFile() and addCSourceFiles() methods.\nBoth of these functions are methods from a Compile object (i.e.¬†a target object). The addCSourceFile() method is capable of adding a single C file to the target object, while the addCSourceFiles() method is used to add multiple C files in a single command. You might prefer to use addCSourceFile() when you need to use different compiler flags on specific C files in your project. But, if you can use the same compiler flags across all C files, then, you will probably find addCSourceFiles() a better choice.\nNotice that we are using the addCSourceFiles() method in the example below, to add both the C files and the C compiler flags. Also notice that we are using the os.tag that we learned about at Section 9.6, to add the platform-specific C files.\n\nconst builtin = @import(\"builtin\");\nlib.addCSourceFiles(\n    &c_source_files, &c_flags\n);\n\nswitch (builtin.target.os.tag) {\n    .windows =&gt; {\n        lib.addCSourceFiles(\n            &windows_c_source_files,\n            &c_flags\n        );\n    },\n    .linux =&gt; {\n        lib.addCSourceFiles(\n            &linux_c_source_files,\n            &c_flags\n        );\n    },\n    else =&gt; {},\n}\n\n\n\n9.11.3 Defining C Macros\nC Macros are an essential part of the C programming language, and they are commonly defined through the -D flag from a C compiler. In Zig, you can define a C Macro to be used in your build process by using the defineCMacro() method from the target object that defines the binary file that you are building.\nIn the example below, we are using the lib object that we defined on the previous sections to define some C Macros used by FreeType in the compilation process. These C Macros specify if FreeType should (or should not) include functionalities from different external libraries.\n\nlib.defineCMacro(\"FT_DISABLE_ZLIB\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_PNG\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_HARFBUZZ\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_BZIP2\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_BROTLI\", \"TRUE\");\nlib.defineCMacro(\"FT2_BUILD_LIBRARY\", \"TRUE\");\n\n\n\n9.11.4 Adding library paths\nLibrary paths are paths in your computer where the C compiler will look (or search) for library files to link against your source code. In other words, when you use a library in your C source code, and you ask the C compiler to link your source code against this library, the C compiler will search for the binary files of this library across the paths listed in this ‚Äúlibrary paths‚Äù set.\nThese paths are platform specific, and, by default, the C compiler starts by looking at a pre-defined set of places in your computer. But you can add more paths (or more places) to this list. For example, you may have a library installed in a non-conventional place of your computer, and you can make the C compiler ‚Äúsee‚Äù this ‚Äúnon-conventional place‚Äù by adding this path to this list of pre-defined paths.\nIn Zig, you can add more paths to this set by using the addLibraryPath() method from your target object. First, you defined a LazyPath object, containing the path you want to add, then, you provide this object as input to the addLibraryPath() method, like in the example below:\n\nconst lib_path: std.Build.LazyPath = .{\n    .cwd_relative = \"/usr/local/lib/\"\n};\nlib.addLibraryPath(lib_path);\n\n\n\n9.11.5 Adding include paths\nThe preprocessor search path is a popular concept from the C community, but it is also known by many C programmers as ‚Äúinclude paths‚Äù, because the paths in this ‚Äúsearch path‚Äù relate to the #include statements found in the C files.\nInclude paths are similar to library paths. They are a set of pre-defined places in your computer where the C compiler will look for files during the compilation process. But instead of looking for library files, the include paths are places where the compiler looks for header files included in your C source code. This is why many C programmers prefer to call these paths as the ‚Äúpreprocessor search path‚Äù. Because header files are processed during the preprocessor stage of the compilation process.\nSo, every header file that you include in your C source code, through a #include statements needs to be found somewhere, and the C compiler will search for this header file across the paths listed in this ‚Äúinclude paths‚Äù set. Include paths are added to the compilation process through the -I flag.\nIn Zig, you can add new paths to this pre-defined set of paths, by using the addIncludePath() method from your target object. This method also accepts a LazyPath object as input.\n\nconst inc_path: std.Build.LazyPath = .{\n    .path = \"./include\"\n};\nlib.addIncludePath(inc_path);",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#footnotes",
    "href": "Chapters/07-build-system.html#footnotes",
    "title": "9¬† Build System",
    "section": "",
    "text": "https://ziglang.org/learn/build-system/#user-provided-options‚Ü©Ô∏é\nhttps://zig.news/xq/zig-build-explained-part-1-59lf‚Ü©Ô∏é\nhttps://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html‚Ü©Ô∏é\nhttps://ziglang.org/learn/build-system/#handy-examples‚Ü©Ô∏é\nhttps://semver.org/‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig‚Ü©Ô∏é\nhttps://github.com/mitchellh/libxev/tree/main‚Ü©Ô∏é\nhttps://freetype.org/‚Ü©Ô∏é\nhttps://github.com/pedropark99/freetype-zig/tree/main‚Ü©Ô∏é\nhttps://freetype.org/‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Build System</span>"
    ]
  },
  {
    "objectID": "Chapters/09-error-handling.html",
    "href": "Chapters/09-error-handling.html",
    "title": "10¬† Error handling and unions",
    "section": "",
    "text": "10.1 Learning more about errors in Zig\nBefore we get into how error handling is done, we need to learn more about what errors are in Zig. An error is actually a value in Zig (Zig Software Foundation 2024a). In other words, when an error occurs inside your Zig program, it means that somewhere in your Zig codebase, an error value is being generated. An error value is similar to any integer value that you create in your Zig code. You can take an error value and pass it as input to a function, and you can also cast (or coerce) it into a different type of error value.\nThis have some similarities with exceptions in C++ and Python. Because in C++ and Python, when an exception happens inside a try block, you can use a catch block (in C++) or an except block (in Python) to capture the exception produced in the try block, and pass it to functions as an input.\nAlthough they are normal values as any other, you cannot ignore error values in your Zig code. Meaning that, if an error value appears somewhere in your source code, this error value must be explicitly handled in some way. This also means that you cannot discard error values by assigning them to a underscore, as you could do with normal values and objects.\nTake the source code below as an example. Here we are trying to open a file that does not exist in my computer, and as a result, an obvious error value of FileNotFound is returned from the openFile() function. But because I‚Äôm assigning the result of this function to an underscore, I end up trying to discard an error value.\nThe zig compiler detects this mistake, and raises a compile error telling me that I‚Äôm trying to discard an error value. It also adds a note message that suggests the use of try, catch or an if statement to explicitly handle this error value This note is reinforcing that every possible error value must be explicitly handled in Zig.\nconst dir = std.fs.cwd();\n_ = dir.openFile(\"doesnt_exist.txt\", .{});",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Error handling and unions</span>"
    ]
  },
  {
    "objectID": "Chapters/09-error-handling.html#learning-more-about-errors-in-zig",
    "href": "Chapters/09-error-handling.html#learning-more-about-errors-in-zig",
    "title": "10¬† Error handling and unions",
    "section": "",
    "text": "t.zig:8:17: error: error set is discarded\nt.zig:8:17: note: consider using 'try', 'catch', or 'if'\n\n10.1.1 Returning errors from functions\nAs we described at Section 1.2.3, when we have a function that might return an error value, this function normally includes an exclamation mark (!) in it‚Äôs return type annotation. The presence of this exclamation mark indicates that this function might return an error value as result, and, the zig compiler forces you to always handle explicitly the case of this function returning an error value.\nTake a look at the print_name() function below. This function might return an error in the stdout.print() function call, and, as a consequence, it‚Äôs return type (!void) includes an exclamation mark in it.\n\nfn print_name() !void {\n    const stdout = std.getStdOut().writer();\n    try stdout.print(\"My name is Pedro!\", .{});\n}\n\nIn the example above, we are using the exclamation mark to tell the zig compiler that this function might return some error. But which error exactly is returned from this function? For now, we are not specifying a specific error value. We only known for now that some error value (whatever it is) might be returned.\nBut in fact, you can (if you want to) specify clearly which exact error values might be returned from this function. There are lot of examples of this in the Zig Standard Library. Take this fill() function from the http.Client module as an example. This function returns either a error value of type ReadError, or void.\n\npub fn fill(conn: *Connection) ReadError!void {\n    // The body of this function ...\n}\n\nThis idea of specifying the exact error values that you expect to be returned from the function is interesting. Because they automatically become some sort of documentation of your function, and also, it allows the zig compiler to perform some extra checks over your code. Because it can check if there is any other type of error value that is being generated inside your function, and, that it is not being accounted for in this return type annotation.\nAnyway, you can list the types of errors that can be returned from the function by listing them on the left side of the exclamation mark. While the valid values stay on the right side of the exclamation mark. So the syntax format become:\n&lt;error-value&gt;!&lt;valid-value&gt;\n\n\n10.1.2 Error sets\nBut what about when we have a single function that might return different types of errors? When you have such a function, you can list all of these different types of errors that can be returned from this function, through a structure in Zig that we call of error set.\nAn error set is a special case of an union type. It essentially is an union that contains error values in it. Not all programming languages have a notion of an ‚Äúunion object‚Äù. But in summary, an union is just a list of the options that an object can be. For example, a union of x, y and z, means that an object can be either of type x, or type y or type z.\nWe are going to talk in more depth about unions at Section 10.3. But you can write an error set by writing the keyword error before a pair of curly braces, then you list the error values that can be returned from the function inside this pair of curly braces.\nTake the resolvePath() function below as an example, which comes from the introspect.zig module of the Zig Standard Library. We can see in it‚Äôs return type annotation, that this function return either: 1) a valid slice of u8 values ([]u8); or, 2) one of the three different types of error values listed inside the error set (OutOfMemory, Unexpected, etc.). This is an example of use of an error set.\n\npub fn resolvePath(\n    ally: mem.Allocator,\n    p: []const u8,\n) error{\n    OutOfMemory,\n    CurrentWorkingDirectoryUnlinked,\n    Unexpected,\n}![]u8 {\n    // The body of the function ...\n}\n\nThis is a valid way of annotating the return value of a Zig function. But, if you navigate through the modules that composes the Zig Standard Library, you will notice that, for the majority of cases, the programmers prefer to give a descriptive name to this error set, and then, use this name (or this ‚Äúlabel‚Äù) of the error set in the return type annotation, instead of using the error set directly.\nWe can see that in the ReadError error set that we showed earlier in the fill() function, which is defined in the http.Client module. So yes, I presented the ReadError as if it was just a standard and single error value, but in fact, it is an error set defined in the http.Client module, and therefore, it actually represents a set of different error values that might happen in the fill() and other functions.\nTake a look at the ReadError definition reproduced below. Notice that we are grouping all of these different error values into a single object, and then, we use this object into the return type annotation of the functions. Like the fill() function that we showed earlier, or, the readvDirect() function from the same module, which is reproduced below.\n\npub const ReadError = error{\n    TlsFailure,\n    TlsAlert,\n    ConnectionTimedOut,\n    ConnectionResetByPeer,\n    UnexpectedReadFailure,\n    EndOfStream,\n};\n// Some lines of code\npub fn readvDirect(\n        conn: *Connection,\n        buffers: []std.posix.iovec\n    ) ReadError!usize {\n    // The body of the function ...\n}\n\nSo, an error set is just a convenient way of grouping a set of possible error values into a single object, or a single type of an error value.\n\n\n10.1.3 Casting error values\nLet‚Äôs suppose you have two different error sets, named A and B. If error set A is a superset of error set B, then, you can cast (or coerce) error values from B into error values of A.\nError sets are just a set of error values. So, if the error set A contains all error values from the error set B, then A becomes a superset of B. You could also say that the error set B is a subset of error set A.\nThe example below demonstrates this idea. Because A contains all values from B, A is a superset of B. In math notation, we would say that \\(A \\supset B\\). As a consequence, we can give an error value from B as input to the cast() function, and, implicitly cast this input into the same error value, but from the A set.\n\nconst std = @import(\"std\");\nconst A = error{\n    ConnectionTimeoutError,\n    DatabaseNotFound,\n    OutOfMemory,\n    InvalidToken,\n};\nconst B = error {\n    OutOfMemory,\n};\n\nfn cast(err: B) A {\n    return err;\n}\n\ntest \"coerce error value\" {\n    const error_value = cast(B.OutOfMemory);\n    try std.testing.expect(\n        error_value == A.OutOfMemory\n    );\n}",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Error handling and unions</span>"
    ]
  },
  {
    "objectID": "Chapters/09-error-handling.html#how-to-handle-errors",
    "href": "Chapters/09-error-handling.html#how-to-handle-errors",
    "title": "10¬† Error handling and unions",
    "section": "10.2 How to handle errors",
    "text": "10.2 How to handle errors\nNow that we learned more about what errors are in Zig, let‚Äôs discuss the available strategies to handle these errors, which are:\n\ntry keyword;\ncatch keyword;\nan if statement;\nerrdefer keyword;\n\n\n10.2.1 What try means?\nAs I described over the previous sections, when we say that an expression might return an error, we are basically referring to an expression that have a return type in the format !T. The ! indicates that this expression returns either an error value, or a value of type T.\nAt Section 1.2.3, I presented the try keyword and where to use it. But I did not talked about what exactly this keyword does to your code, or, in other words, I have not explained yet what try means in your code.\nIn essence, when you use the try keyword in an expression, you are telling the zig compiler the following: ‚ÄúHey! Execute this expression for me, and, if this expression return an error, please, return this error for me and stop the execution of my program. But if this expression return a valid value, then, return this value, and move on‚Äù.\nIn other words, the try keyword is essentially, a strategy to enter in panic mode, and stop the execution of your program in case an error occurs. With the try keyword, you are telling the zig compiler, that stopping the execution of your program is the most reasonable strategy to take if an error occurs in that particular expression.\n\n\n10.2.2 The catch keyword\nOk, now that we understand properly what try means, let‚Äôs discuss catch now. One important detail here, is that you can use try or catch to handle your errors, but you cannot use try and catch together. In other words, try and catch are different and completely separate strategies in the Zig language.\nThis is uncommon, and different than what happens in other languages. Most programming languages that adopts the try catch pattern (such as C++, R, Python, Javascript, etc.), normally use these two keywords in conjunction to form the complete logic to properly handle the errors. Anyway, Zig tries a different approach in the try catch pattern.\nSo, we learned already about what try means, and we also known that both try and catch should be used alone, separate from each other. But what exactly catch do in Zig? With catch, we can construct a block of logic to handle the error value, in case it happens in the current expression.\nLook at the code example below. Once again, we go back to the previous example where we were trying to open a file that doesn‚Äôt exist in my computer, but this time, I use catch to actually implement a logic to handle the error, instead of just stopping the execution right away.\nMore specifically, in this example, I‚Äôm using a logger object to record some logs into the system, before I return the error, and stops the execution of the program. For example, this could be some part of the codebase of a complex system that I do not have full control over, and I want to record these logs before the program crashes, so that I can debug it later (e.g.¬†maybe I cannot compile the full program, and properly debug it with a debugger. So, these logs might be a valid strategy to surpass this barrier).\n\nconst dir = std.fs.cwd();\nconst file = dir.openFile(\n    \"doesnt_exist.txt\", .{}\n) catch |err| {\n    logger.record_context();\n    logger.log_error(err);\n    return err;\n};\n\nTherefore, we use catch to create a block of expressions that will handle the error. I can return the error value from this block of expressions, like I did in the above example, which, will make the program enter in panic mode, and, stop the execution. But I could also, return a valid value from this block of code, which would be stored in the file object.\nNotice that, instead of writing the keyword before the expression that might return the error, like we do with try, we write catch after the expression. We can open the pair of pipes (|), which captures the error value returned by the expression, and makes this error value available in the scope of the catch block as the object named err. In other words, because I wrote |err| in the code, I can access the error value returned by the expression, by using the err object.\nAlthough this being the most common use of catch, you can also use this keyword to handle the error in a ‚Äúdefault value‚Äù style. That is, if the expression returns an error, we use the default value instead. Otherwise, we use the valid value returned by the expression.\nThe Zig official language reference, provides a great example of this ‚Äúdefault value‚Äù strategy with catch. This example is reproduced below. Notice that we are trying to parse some unsigned integer from a string object named str. In other words, this function is trying to transform an object of type []const u8 (i.e.¬†an array of characters, a string, etc.) into an object of type u64.\nBut this parsing process done by the function parseU64() may fail, resulting in a runtime error. The catch keyword used in this example provides an alternative value (13) to be used in case this parseU64() function raises an error. So, the expression below essentially means: ‚ÄúHey! Please, parse this string into a u64 for me, and store the results into the object number. But, if an error occurs, then, return the value 13 instead‚Äù.\n\nconst number = parseU64(str, 10) catch 13;\n\nSo, at the end of this process, the object number will contain either a u64 integer that was parsed succesfully from the input string str, or, if an error in the parsing process occurs, it will contain the u64 value 13 that was provided by the catch keyword as the ‚Äúdefault‚Äù, or, the ‚Äúalternative‚Äù value.\n\n\n10.2.3 Using if statements\nNow, you can also use if statements to handle errors in your Zig code. In the example below, I‚Äôm reproducing the previous example, where we try to parse an integer value from an input string with a function named parseU64().\nWe execute the expression inside the ‚Äúif‚Äù. If this expression returns an error value, the ‚Äúif branch‚Äù (or, the ‚Äútrue branch‚Äù) of the if statement is not executed. But if this expression returns a valid value instead, then, this value is unwrapped into the number object.\nThis means that, if the parseU64() expression returns a valid value, this value becomes available inside the scope of this ‚Äúif branch‚Äù (i.e.¬†the ‚Äútrue branch‚Äù) through the object that we listed inside the pair of pipe charactes (|), which is the object number.\nIf an error occurs, we can use an ‚Äúelse branch‚Äù (or the ‚Äúfalse branch‚Äù) of the if statement to handle the error. In the example below, we are using the else in the if statement to unwrap the error value (that was returned by parseU64()) into the err object, and handle the error.\n\nif (parseU64(str, 10)) |number| {\n    // do something with `number` here\n} else |err| {\n    // handle the error value.\n}\n\nNow, if the expression that you are executing returns different types of error values, and you want to take a different action in each of these types of error values, the catch keyword becomes limited.\nFor this type of situation, the official documentation of the language suggests the use of a switch statement with an if statement (Zig Software Foundation 2024b). The basic idea is, to use the if statement to execute the expression, and use the ‚Äúelse branch‚Äù to pass the error value to a switch statement, where you define a different action for each type of error value that might be returned by the expression executed in the if statement.\nThe example below demonstrates this idea. We first try to add (or register) a set of tasks to a queue. If this ‚Äúregistration process‚Äù occurs well, we then try to distribute these tasks across the workers of our system. But if this ‚Äúregistration process‚Äù returns an error value, we then use a switch statement in the ‚Äúelse branch‚Äù to handle each possible error value.\n\nif (add_tasks_to_queue(&queue, tasks)) |_| {\n    distribute_tasks(&queue);\n} else |err| switch (err) {\n    error.InvalidTaskName =&gt; {\n        // do something\n    },\n    error.TimeoutTooBig =&gt; {\n        // do something\n    },\n    error.QueueNotFound =&gt; {\n        // do somethimg\n    },\n    // and all the other error options ...\n}\n\n\n\n10.2.4 The errdefer keyword\nA commom pattern in C programs in general, is to clean resources when an error occurs during the execution of the program. In other words, one commom way to handle errors, is to perform ‚Äúcleanup actions‚Äù before we exit our program. This garantees that a runtime error does not make our program to leak resources of the system.\nThe errdefer keyword is a tool to perform such ‚Äúcleanup actions‚Äù in hostile situations. This keyword is commonly used to clean (or to free) allocated resources, before the execution of our program get‚Äôs stopped because of an error value being generated.\nThe basic idea is to provide an expression to the errdefer keyword. Then, errdefer executes this expression if, and only if, an error occurs during the execution of the current scope. In the example below, we are using an allocator object (that we presented at Section 3.2) to create a new User object. If we are succesfull in creating and registering this new user, this create_user() function will return this new User object as it‚Äôs return value.\nHowever, if for some reason, an error value is generated by some expression that is after the errdefer line, for example, in the db.add(user) expression, the expression registered by errdefer get‚Äôs executed before the error value is returned from the function, and before the program enters in panic mode and stops the current execution.\n\nfn create_user(db: Database, allocator: Allocator) !User {\n    const user = try allocator.create(User);\n    errdefer allocator.destroy(user);\n\n    // Register new user in the Database.\n    _ = try db.register_user(user);\n    return user;\n}\n\nBy using errdefer to destroy the user object that we have just created, we garantee that the memory allocated for this user object get‚Äôs freed, before the execution of the program stops. Because if the expression try db.add(user) returns an error value, the execution of our program stops, and we loose all references and control over the memory that we have allocated for the user object. As a result, if we do not free the memory associated with the user object before the program stops, we cannot free this memory anymore. We simply loose our chance to do the right thing. That is why errdefer is essential in this situation.\nJust to make very clear the differences between defer (which I described at Section 2.1.3) and errdefer, it might be worth to discuss the subject a bit further. You might still have the question ‚Äúwhy use errdefer if we can use defer instead?‚Äù in your mind.\nAlthough being similar, the key difference between errdefer and defer keyword is when the provided expression get‚Äôs executed. The defer keyword always execute the provided expression at the end of the current scope, no matter how your code exits this scope. In contrast, errdefer executes the provided expression only when an error occurs in the current scope.\nThis becomes important if a resource that you allocate in the current scope get‚Äôs freed later in your code, in a different scope. The create_user() functions is an example of this. If you think closely about this function, you will notice that this function returns the user object as the result.\nIn other words, the allocated memory for the user object does not get freed inside the create_user(), if the function returns succesfully. So, if an error does not occur inside this function, the user object is returned from the function, and probably, the code that runs after this create_user() function will be responsible for freeying the memory of the user object.\nBut what if an error do occur inside the create_user()? What happens then? This would mean that the execution of your code would stop in this create_user() function, and, as a consequence, the code that runs after this create_user() function would simply not run, and, as a result, the memory of the user object would not be freed before your program stops.\nThis is the perfect scenario for errdefer. We use this keyword to garantee that our program will free the allocated memory for the user object, even if an error occurs inside the create_user() function.\nIf you allocate and free some memory for an object in the same scope, then, just use defer and be happy, errdefer have no use for you in such situation. But if you allocate some memory in a scope A, but you only free this memory later, in a scope B for example, then, errdefer becomes useful to avoid leaking memory in sketchy situations.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Error handling and unions</span>"
    ]
  },
  {
    "objectID": "Chapters/09-error-handling.html#sec-unions",
    "href": "Chapters/09-error-handling.html#sec-unions",
    "title": "10¬† Error handling and unions",
    "section": "10.3 Union type in Zig",
    "text": "10.3 Union type in Zig\nAn union type defines a set of types that an object can be. It is like a list of options. Each option is a type that an object can assume. Therefore, unions in Zig have the same meaning, or, the same role as unions in C. They are used for the same purpose. You could also say that unions in Zig produces a similar effect to typing.Union in Python1.\nFor example, you might be creating an API that sends data to a data lake, hosted in some private cloud infrastructure. Suppose you created different structs in your codebase, to store the necessary information that you need, in order to connect to the services of each mainstream data lake service (Amazon S3, Azure Blob, etc.).\nNow, suppose you also have a function named send_event() that receives an event as input, and, a target data lake, and it sends the input event to the data lake specified in the target data lake argument. But this target data lake could be any of the three mainstream data lakes services (Amazon S3, Azure Blob, etc.). Here is where an union can help you.\nThe union LakeTarget defined below allows the lake_target argument of send_event() to be either an object of type AzureBlob, or type AmazonS3, or type GoogleGCP. This union allows the send_event() function to receive an object of any of these three types as input in the lake_target argument.\nRemember that each of these three types (AmazonS3, GoogleGCP and AzureBlob) are separate structs that we defined in our source code. So, at first glance, they are separate data types in our source code. But is the union keyword that unifies them into a single data type called LakeTarget.\n\nconst LakeTarget = union {\n    azure: AzureBlob,\n    amazon: AmazonS3,\n    google: GoogleGCP,\n};\n\nfn send_event(\n    event: Event,\n    lake_target: LakeTarget\n) bool {\n    // body of the function ...\n}\n\nAn union definition is composed by a list of data members. Each data member is of a specific data type. In the example above, the LakeTarget union have three data members (azure, amazon, google). When you instantiate an object that uses an union type, you can only use one of it‚Äôs data members in this instantiation.\nYou could also interpret this as: only one data member of an union type can be activated at a time, the other data members remain deactivated and unaccessible. For example, if you create a LakeTarget object that uses the azure data member, you can no longer use or access the data members google or amazon. It is like if these other data members didn‚Äôt exist at all in the LakeTarget type.\nYou can see this logic in the example below. Notice that, we first instantiate the union object using the azure data member. As a result, this target object contains only the azure data member inside of it. Only this data member is active in this object. That is why the last line in this code example is invalid. Because we are trying to instantiate the data member google, which is currently inactive for this target object, and as a result, the program enters in panic mode warning us about this mistake through a loud error message.\n\nvar target = LakeTarget {\n    .azure = AzureBlob.init()\n};\n// Only the `azure` data member exist inside\n// the `target` object, and, as a result, this\n// line below is invalid:\ntarget.google = GoogleGCP.init();\n\nthread 2177312 panic: access of union field 'google' while\n    field 'azure' is active:\n    target.google = GoogleGCP.init();\n          ^\nSo, when you instantiate an union object, you must choose one of the data types (or, one of the data members) listed in the union type. In the example above, I choose to use the azure data member, and, as a result, all other data members were automatically deactivated, and you can no longer use them after you instantiate the object.\nYou can activate another data member by completely redefining the entire enum object. In the example below, I initially use the azure data member. But then, I redefine the target object to use a new LakeTarget object, which uses this time the google data member.\n\nvar target = LakeTarget {\n    .azure = AzureBlob.init()\n};\ntarget = LakeTarget {\n    .google = GoogleGCP.init()\n};\n\nAn curious fact about union types, is that, at first, you cannot use them in switch statements (that we preseted at Section 2.1.2). In other words, if you have an object of type LakeTarget for example, you cannot give this object to a switch statement as input.\nBut what if you really need to do so? What if you actually need to provide an ‚Äúunion object‚Äù to a switch statement? The answer to this question relies on another special type in Zig, which are the tagged unions. To create a tagged union, all you have to do is to add an enum type into your union declaration.\nAs an example of a tagged union in Zig, take the Registry type exposed below. This type comes from the grammar.zig module2 from the Zig repository. This union type lists different types of registries. But notice this time, the use of (enum) after the union keyword. This is what makes this union type a tagged union. Also, by being a tagged union, an object of this Registry type can be used as input in a switch statement. This is all you have to do. Just add (enum) to your union declaration, and you can use it in switch statements.\n\npub const Registry = union(enum) {\n    core: CoreRegistry,\n    extension: ExtensionRegistry,\n};\n\n\n\n\n\nZig Software Foundation. 2024a. ‚ÄúIn-Depth Overview.‚Äù Zig Software Foundation. https://ziglang.org/learn/overview/.\n\n\n‚Äî‚Äî‚Äî. 2024b. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Error handling and unions</span>"
    ]
  },
  {
    "objectID": "Chapters/09-error-handling.html#footnotes",
    "href": "Chapters/09-error-handling.html#footnotes",
    "title": "10¬† Error handling and unions",
    "section": "",
    "text": "https://docs.python.org/3/library/typing.html#typing.Union‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/30b4a87db711c368853b3eff8e214ab681810ef9/tools/spirv/grammar.zig.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Error handling and unions</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html",
    "href": "Chapters/09-data-structures.html",
    "title": "11¬† Data Structures",
    "section": "",
    "text": "11.1 Dynamic Arrays\nIn high level languages, arrays are usually dynamic. They easily grow in size when they have to, and you don‚Äôt need to worry about it. In contrast, arrays in low level languages are usually static by default. This is the reality of C, C++, Rust and also Zig. Static arrays were presented at Section 1.6, but in this section, we are going to talk about dynamic arrays.\nDynamic arrays are simply arrays that can grow in size during the runtime of your program. Most low level languages offer some implementation of a dynamic array in their standard library. C++ have std::vector, Rust have Vec, and Zig have std.ArrayList.\nThe std.ArrayList struct provides a contiguous and growable array for you. It works like any other dinamic array, it allocates a contiguous block of memory, and when this block have no space left, ArrayList allocates another contiguous and bigger block of memory, copies the elements to this new location, and erases (or frees) the previous block of memory.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html#sec-dynamic-array",
    "href": "Chapters/09-data-structures.html#sec-dynamic-array",
    "title": "11¬† Data Structures",
    "section": "",
    "text": "11.1.1 Capacity vs Length\nWhen we talk about dynamic arrays, we have two similar concepts that are very essential to how a dynamic array works behind the hood. These concepts are capacity and length. In some contexts, specially in C++, length is also called of size.\nAlthough they look similar, these concepts represent different things in the context of dynamic arrays. Capacity is the number of items (or elements) that your dynamic array can currently hold without the need to allocate more memory.\nIn contrast, the length refers to how many elements in the array are currently being used, or, in other words, how many elements in this array that you assigned a value to. Every dynamic array works around a block of allocated memory that represents an array with total capacity of \\(n\\) elements, but only a portion of these \\(n\\) elements are being used most of the time. This portion of \\(n\\) is the length of the array. So every time you append a new value to the array, you are incrementing it‚Äôs length by one.\nThis means that a dynamic array usually works with an extra margin, or, an extra space which is currently empty, but it is waiting and ready to be used. This ‚Äúextra space‚Äù is essentially the difference between capacity and length. Capacity represents the total number of elements that the array can hold without the need to re-allocate or re-expand the array, while the length represents how much of this capacity is currently being used to hold/store values.\nFigure¬†11.1 presents this idea visually. Notice that, at first, the capacity of the array is greater than the length of the array. So, the dynamic array have extra space that is currently empty, but it is ready to receive a value to be stored.\n\n\n\n\n\n\nFigure¬†11.1: Difference between capacity and length in a dynamic array\n\n\n\nWe can also see at Figure¬†11.1 that, when length and capacity are equal, it means that the array have no space left. We reached the roof of our capacity, and because of that, if we want to store more values in this array, we need to expand it. We need to get a bigger space that can hold more values that we currently have.\nA dynamic array works by expanding the underlying array, whenever the length becomes equal to the capacity of the array. It basically allocates a new contiguos block of memory that is bigger than the previous one, then, it copies all values that are currently being stored to this new location (i.e.¬†this new block of memory), then, it frees the previous block of memory. At the end of this process, the new underlying array have a bigger capacity, and, therefore, the length becomes once again smaller than the capacity of the array.\nThis is the cycle of an dynamic array. Notice that, throughout this cycle, the capacity is always either equal to or higher than the length of the array. If youh have an ArrayList object, let‚Äôs suppose you named it of buffer, you can check the current capacity of your array by accessing the capacity attribute of your ArrayList object, while the current length of it is available through the items.len attribute of your ArrayList object.\n\n// Check capacity\nbuffer.capacity;\n// Check length\nbuffer.items.len;\n\n\n\n11.1.2 Creating an ArrayList object\nIn order to use ArrayList, you must provide an allocator object to it. Remember, Zig does not have a default memory allocator. And as I described at Section 3.2, all memory allocations must be done by allocator objects that you define, that you have control over. In our example here, I‚Äôm going to use a general purpose allocator, but you can use any other allocator of your preference.\nWhen you initialize an ArrayList object, you must provide the data type of the elements of the array. In other words, this defines the type of data that this array (or container) will store. Therefore, if I provide the u8 type to it, then, I will create a dynamic array of u8 values. However, if I provide a struct that I defined instead, like the struct User from Section 2.3, then, a dynamic array of User values will be created. In the example below, with the expression ArrayList(u8) we are creating a dynamic array of u8 values.\nAfter you provide the data type of the elements of the array, you can initialize an ArrayList object by either using the init() or the initCapacity() method. The former method receives only the allocator object as input, while the latter method receives both the allocator object and a capacity number as inputs. With the latter method, you not only initialize the struct, but you also set the starting capacity of the allocated array.\nUsing the initCapacity() method is the preferred way to initialize your dynamic array. Because reallocations, or, in other words, the process of expanding the capacity of the array, is always a high cost operation. You should take any possible opportunity to avoid reallocations in your array. If you know how much space your array needs to occupy at the beginning, you should always use initCapacity() to create your dynamic array.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nvar buffer = try std.ArrayList(u8)\n    .initCapacity(allocator, 100);\ndefer buffer.deinit();\n\nIn the example above, the buffer object starts as an array of 100 elements. If this buffer object needs to create more space to accomodate more elements during the runtime of your program, the ArrayList internals will perform the necessary actions for you automatically. Also notice the deinit() method being used to destroy the buffer object at the end of the current scope, by freeing all the memory that was allocated for the dynamic array stored in this buffer object.\n\n\n11.1.3 Adding new elements to the array\nNow that we created our dynamic array, we can start to use it. You can append (a.k.a ‚Äúadd‚Äù) new values to this array by using the append() method. This method works the same way as the append() method from a Python list, or, the emplace_back() method from std::vector of C++. You provide a single value to this method, and the method appends this value to the array.\nYou can also use the appendSlice() method to append multiple values at once. You provide a slice (slices were described at Section 1.6) to this method, and the method adds all values present in this slice to your dynamic array.\n\ntry buffer.append('H');\ntry buffer.append('e');\ntry buffer.append('l');\ntry buffer.append('l');\ntry buffer.append('o');\ntry buffer.appendSlice(\" World!\");\n\n\n\n11.1.4 Removing elements from the array\nYou can use the pop() method to ‚Äúpop‚Äù or remove the last element in the array. Is worth noting that this method do not change the capacity of the array. It just deletes or erases the last value stored in the array.\nAlso, this method returns as result the value that got deleted. That is, you can use this method to both get the last value in the array, and also, remove it from the array. It is a ‚Äúget and remove value‚Äù type of method.\n\nconst exclamation_mark = buffer.pop();\n\nNow, if you want to remove specific elements from specific positions of your array, you can use the orderedRemove() method from your ArrayList object. With this method, you can provide an index as input, then, the method will delete the value that is at this index in the array. This effectively reduces the length of the array everytime you execute an orderedRemove() operation.\nIn the example below, we first create an ArrayList object, and we fill it with numbers. Then, we use orderedRemove() to remove the value at index 3 in the array, two consecutive times.\nAlso, notice that we are assigning the result of orderedRemove() to the underscore character. So we are discarding the result value of this method. As the result value, the orderedRemove() method returns the value that got deleted, in a similar style to the pop() method.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nvar buffer = try std.ArrayList(u8)\n    .initCapacity(allocator, 100);\ndefer buffer.deinit();\n\nfor (0..10) |i| {\n    const index: u8 = @intCast(i);\n    try buffer.append(index);\n}\n\nstd.debug.print(\n    \"{any}\\n\", .{buffer.items}\n);\n_ = buffer.orderedRemove(3);\n_ = buffer.orderedRemove(3);\n\nstd.debug.print(\n    \"{any}\\n\", .{buffer.items}\n);\nstd.debug.print(\n    \"{any}\\n\", .{buffer.items.len}\n);\n\n{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n{ 0, 1, 2, 5, 6, 7, 8, 9 }\n8\nOne key characteristic about orderedRemove() is that it preserves the order of the values in the array. So, it deletes the value that you asked it to remove, but it also makes sure that the order of the values that remain in the array stay the same as before.\nNow, if you don‚Äôt care about the order of the values, for example, maybe you want to treat your dynamic array as a set of values, like the std::unordered_set structure from C++, you can use the swapRemove() method instead. This method works similarly to the orderedRemove() method. You give an index to this method, then, it deletes the value that is at this index in the array. But this method does not preserve the original order of the values that remain in the array. As a result, swapRemove() is, in general, faster than orderedRemove().\n\n\n11.1.5 Inserting elements at specific indexes\nWhen you need to insert values in the middle of your array, instead of just appending them to the end of the array, you need to use the insert() and insertSlice() methods, instead of the append() and appendSlice() methods.\nThese two methods work very similarly to insert() and insert_range() from the C++ vector class. You provide an index to these methods, and they insert the values that you provide at that index in the array.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nvar buffer = try std.ArrayList(u8)\n    .initCapacity(allocator, 10);\ndefer buffer.deinit();\n\ntry buffer.appendSlice(\"My Pedro\");\ntry buffer.insert(4, '3');\ntry buffer.insertSlice(2, \" name\");\nfor (buffer.items) |char| {\n    try stdout.print(\"{c}\", .{char});\n}\n\nMy name P3edro\n\n\n11.1.6 Conclusion\nIf you feel the lack of some other method, I recommend you to read the official documentation for the ArrayListAligned1 struct, which describes most of the methods available through the ArrayList object.\nYou will notice that there is a lot other methods in this page that I did not described here, and I recommend you to explore these methods, and understand how they work.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html#maps-or-hashtables",
    "href": "Chapters/09-data-structures.html#maps-or-hashtables",
    "title": "11¬† Data Structures",
    "section": "11.2 Maps or HashTables",
    "text": "11.2 Maps or HashTables\nSome professionals know this type of data structure by different terms, like ‚Äúmap‚Äù, ‚Äúhashmap‚Äù or ‚Äúassociative arrays‚Äù. But most professionals know this structure by the name hashtable. Every programming language normally have some implementation of a hashtable in their stardard libraries. Python have dict(), C++ have std::map and std::unordered_map, Rust have HashMap, Javascript have Object() and Map(), C# have Hashtable(), etc.\n\n11.2.1 What is a hashtable?\nA hashtable is a data structure based on key-value pairs. You provide a key and a value to this structure, then, the hashtable will store the input value at a location that can be identified by the input key that you provided. It does that by using an underlying array and a hash function. These two components are essential to how a hashtable works.\nUnder the hood, the hashtable contains an array. This array is where the values are stored, and the elements of this array are usually called of buckets. So the values that you provide to the hashtable are stored inside buckets, and you access each bucket by using an index.\nWhen you provide a key to a hashtable, it passes this key to the hash function. This hash function uses some sort of hashing algorithm to transform this key into an index. This index is actually an array index. It is a position in the underlying array of the hashtable. This is how a key identifies a specific position (or location) inside the hashtable structure.\nSo you provide a key to the hashtable, and this key identifies an specific location inside the hastable, then, the hashtable takes the input value that you provided, and stores this value in the location identified by the input key that you provided. You could say that the key maps to the value stored in the hashtable. You find the value, by using the key that identifies the location where the value is stored. The Figure¬†11.2 presents this process visually.\n\n\n\n\n\n\nFigure¬†11.2: A diagram of a Hashtable. Source: Wikipedia, the free encyclopedia.\n\n\n\nThe operation described in the previous paragraph is normally called an insertion operation. Because you are inserting new values into the hashtable. But there are other types of operations in hashtables such as delete and lookup. Delete is self describing, it is when you delete (or remove) a value from the hashtable. While lookup corresponds to when you retrieve (or look at) a value that is stored in the hashtable, by using the key that identifies the location where this value is stored.\nSometimes, instead of storing the values directly, the underlying array of the hashtable might be an array of pointers, i.e.¬†the buckets of the array stores pointers that points to the value, or also, may be an array of linked lists. These cases are commom on hashtables that allows duplicate keys, or, in other words, on hashtables that effectively handle ‚Äúcollisions‚Äù that may arise from the hash function.\nDuplicate keys, or this ‚Äúcollision‚Äù thing that I‚Äôm talking about, is when you have two different keys that points to the same location (i.e.¬†to the same index) in the underlying array of the hashtable. This might happen depending on the characteristics of the hash function that is being used in the hashtable. Some implementations of the hashtable will actively deal with collisions, meaning that, they will handle this case in some way. For example, the hashtable might transform all buckets into linked lists. Because with a liked list you can store multiple values into a single bucket.\nThere are different techniques to handle collisions in hashtables, which I will not describe in this book, because it is not our main scope here. But you can find a good description of some of the most commom techniques at the Wikipedia page of hashtables (Wikipedia 2024).\n\n\n11.2.2 Hashtables in Zig\nThe Zig Standard Library provides different implementations of a hashtable, like the struct HashMap. Each implementation have it‚Äôs own cons and pros, which we will discuss later on, and all of them are available through the std.hash_map module.\nThe HashMap struct is a general-purpose hashtable, which have very fast operations (lookup, insertion, delete), and also, quite high load factors for low memory usage. You can create and provide a context object to the HashMap constructor. This context object allows you to tailor the behaviour of the hashtable itself, because you can provide a hash function implementation to be used by the hashtable through this context object.\nBut let‚Äôs not worry about this context object now, because it is meant to be used by ‚Äúexperts in the field of hashtables‚Äù. Since we are most likely not experts in this field, we are going to take the easy way to create a hashtable. Which is by using the AutoHashMap() function.\nThis AutoHashMap() function is essentially a ‚Äúcreate a hashtable object that uses the default settings‚Äù type of function. It chooses a context object, and, therefore, a hash function implementation, automatically for you. This function receives two data types as input, the first data type is the data type of the keys that will be used in this hashtable, while the second data type is the data type of that data that will be stored inside the hashtable, that is, the data type of the values to be stored.\nIn the example below, we are providing the data type u32 in the first argument, and u16 in the second argument of this function. It means that we are going to use u32 values as keys in this hashtable, while u16 values are the actual values that are going to be stored into this hashtable. At the end of this process, the hash_table object contains a HashMap object as output that uses the default context, and the default load factor.\n\nconst std = @import(\"std\");\nconst AutoHashMap = std.hash_map.AutoHashMap;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var hash_table = AutoHashMap(u32, u16).init(allocator);\n    defer hash_table.deinit();\n\n    try hash_table.put(54321, 89);\n    try hash_table.put(50050, 55);\n    try hash_table.put(57709, 41);\n    std.debug.print(\n        \"N of values stored: {d}\\n\",\n        .{hash_table.count()}\n    );\n    std.debug.print(\n        \"Value at key 50050: {d}\\n\",\n        .{hash_table.get(50050).?}\n    );\n\n    if (hash_table.remove(57709)) {\n        std.debug.print(\n            \"Value at key 57709 succesfully removed!\\n\",\n            .{}\n        );\n    }\n    std.debug.print(\n        \"N of values stored: {d}\\n\",\n        .{hash_table.count()}\n    );\n}\n\nN of values stored: 3\nValue at key 50050: 55\nValue at key 57709 succesfully removed!\nN of values stored: 2\nYou can add/put new values into the hashtable by using the put() method. The first argument is the key to be used, and the second argument is the actual value that you want to store inside the hashtable. In the example below, we first add the value 89 using the key 54321, next, we add the value 55 using the key 50050, etc.\nNotice that we used the method count() to see how many values are currently stored in the hashtable. After that, we also used the get() method to access (or look) at the value stored in the position identified by the key 500050. The output of this get() method is an optional value, and that is why we use the ? method at the end to get access to the actual value.\nAlso notice that we can remove (or delete) values from a hashtables by using the remove() method. You provide the key that identifies the value that you want to delete, then, the method will delete this value and return a true value as output. This true value essentially tells us that the method succesfully deleted the value.\nBut this delete operation might not be always successful. For example, you might provide the wrong key to this method. I mean, maybe you provide (either intentionally or unintentionally) a key that points to an empty bucket, i.e.¬†a bucket that still doesn‚Äôt have a value in it. In this case, the remove() method would return a false value.\n\n\n11.2.3 Iterating through the hashtable\nIterating through the keys and values that are currently being stored in the hashtable is a very commom need. You can do that in Zig by using an iterator object that can iterate through the elements of you hashtable object.\nThis iterator object works like any other iterator object that you would find in languages such as C++ and Rust. It is basically a pointer object that points to some value in the container, and has a next() method that you can use to navigate (or iterate) through the next values in the container.\nYou can create such iterator object by using the iterator() method of the hashtable object. This method returns an iterator object, from which you can use the next() method in conjunction with a while loop to iterate through the elements of your hashtable. The next() method returns an optional Entry value, and therefore, you must unwrap this optional value to get the actual Entry value from which you can access the key and also the value identified by this key.\nWith this Entry value at hand, you can access the key of this current entry by using the key_ptr attribute and dereferencing the pointer that lives inside of it, while the value identified by this key is accessed through the value_ptr attribute instead, which is also a pointer to be dereferenced. The code example below demonstrates the use of these elements:\n\nconst std = @import(\"std\");\nconst AutoHashMap = std.hash_map.AutoHashMap;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var hash_table = AutoHashMap(u32, u16).init(allocator);\n    defer hash_table.deinit();\n\n    try hash_table.put(54321, 89);\n    try hash_table.put(50050, 55);\n    try hash_table.put(57709, 41);\n\n    var it = hash_table.iterator();\n    while (it.next()) |kv| {\n        // Access the current key\n        std.debug.print(\"Key: {d} | \", .{kv.key_ptr.*});\n        // Access the current value\n        std.debug.print(\"Value: {d}\\n\", .{kv.value_ptr.*});\n    }\n}\n\nKey: 54321 | Value: 89\nKey: 50050 | Value: 55\nKey: 57709 | Value: 41\nIf you want to iterate through only the values or the keys of your hashtable, you can create a key iterator or a value iterator object. These are also iterator objects, which have the same next() method that you can use to iterate through the sequence of values.\nKey iterators are created from the keyIterator() method of your hashtable object, while value iterators are created from the valueIterator() method. All you have to do is to unwrap the value from the next() method and deference it directly to access the key or value that you iterating over. The code example below demonstrates what would this be for a key iterator, but you can replicate the same logic to a value iterator.\n\nvar kit = hash_table.keyIterator();\nwhile (kit.next()) |key| {\n    std.debug.print(\"Key: {d}\\n\", .{key.*});\n}\n\nKey: 54321\nKey: 50050\nKey: 57709\n\n\n11.2.4 The ArrayHashMap hashtable\nIf you need to iterate through the elements of your hashtable constantly, you might want to use the ArrayHashMap struct for your specific case, instead of going with the usual and general-purpose HashMap struct.\nThe ArrayHashMap struct creates a hashtable that is faster to iterate over. That is why this specific type of hashtable might be valuable to you. Some other properties of a ArrayHashMap hashtable are:\n\nthe order of insertion is preserved. So the order of the values you find while iterating through this hashtable are actually the order in which these values were inserted in the hashtable.\nthe key-value pairs are stored sequentially, one after another.\n\nYou can create an ArrayHashMap object by using, once again, a helper function that chooses automatically for you a hash function implementation. This is the AutoArrayHashMap() function, which works very similarly to the AutoHashMap() function that we presented at Section 11.2.2.\nYou provide two data types to this function. The data type of the keys that will be used in this hashtable, and the data type of the values that will be stored in this hashtable.\nAn ArrayHashMap object have essentially the exact same methods from the HashMap struct. So you can insert new values into the hashtable by using the put() method, you can look (or get) a value from the hashtable by using the get() method. But the remove() method is not available in this specific type of hashtable.\nIn order to delete values from the hashtable, you would use the same methods that you find in an ArrayList object, i.e.¬†a dynamic array. I presented these methods at Section 11.1.4, which are the swapRemove() and orderedRemove() methods. These methods have here the same meaning, or, the same effect that they have in an ArrayList object.\nThis means that, with swapRemove() you remove the value from the hashtable, but you do not preserve the order in which the values were inserted into the structure. While orderedRemove() is capable of retaining the insertion order of these values.\nBut instead of providing an index as input to swapRemove() or orderedRemove(), like I described at Section 11.1.4, these methods here in an ArrayHashMap take a key as input, like the remove() method from a HashMap object. If you want to provide an index as input, instead of a key, you should use the swapRemoveAt() and orderedRemoveAt() methods.\n\nvar hash_table = AutoArrayHashMap(u32, u16)\n    .init(allocator);\ndefer hash_table.deinit();\n\n\n\n11.2.5 The StringHashMap hashtable\nOne thing that you will notice in the other two types of hashtables that I presented in the last sections, is that neither of them accepts a slice data type in their keys. What this means is that you cannot use a slice value to represent a key in these types of hashtable.\nThe most obvious consequence of this, is that you cannot use strings as keys in these hashtables. But is extremely commom to use string values as keys in hashtables.\nTake this very simple Javascript code snippet as an example. We are creating a simple hashtable object named people. Then, we add a new entry to this hashtable, which is identified by the string 'Pedro'. This string is the key in this case, while the object containing different personal information such as age, height and city, is the value to be stored in the hashtable.\nvar people = new Object();\npeople['Pedro'] = {\n    'age': 25,\n    'height': 1.67,\n    'city': 'Belo Horizonte'\n};\nThis pattern of using strings as keys is very commom in all sorts of situations. That is why the Zig Standard Library offers a specific type of hashtable for this purpose, which is created through the StringHashMap() function. This function creates a hashtable that uses strings as keys. The only input of this function is the data type of the values that will be stored into this hashtable.\nIn the example below, I‚Äôm creating a hashtable to store the ages of different people. The keys to be used in this hashtable are the names of each person, while the value stored in the hashtable is the age of the person identified by the key.\nThat is why I provide the u8 data type (which is the data type used by the age values) as input to this StringHashMap() function. As the result, it creates a hashtable that uses string values as keys, and, that stores u8 values in it. Notice that an allocator object is provided at the init() method of the resulting object from the StringHashMap() function.\n\nconst std = @import(\"std\");\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var ages = std.StringHashMap(u8).init(allocator);\n    defer ages.deinit();\n\n    try ages.put(\"Pedro\", 25);\n    try ages.put(\"Matheus\", 21);\n    try ages.put(\"Abgail\", 42);\n\n    var it = ages.iterator();\n    while (it.next()) |kv| {\n        std.debug.print(\"Key: {s} | \", .{kv.key_ptr.*});\n        std.debug.print(\"Age: {d}\\n\", .{kv.value_ptr.*});\n    }\n}\n\nKey: Pedro | Age: 25\nKey: Abgail | Age: 42\nKey: Matheus | Age: 21\n\n\n11.2.6 The StringArrayHashMap hashtable\nThe Zig Standard Library also provides a type of hashtable that mix the cons and pros of the types of hashtables that were presented on the previous two sections. That is, a hashtable that uses strings as keys, but also have the advantages from the ArrayHashMap struct. In other words, you can have a hashtable that is fast to iterate over, that preserves insertion order, and also, that uses strings as keys.\nYou can create such type of hashtable by using the StringArrayHashMap() function. This function accepts a data type as input, which is the data type of the values that are going to be stored inside this hashtable, in the same style as the function presented at Section 11.2.5.\nYou can insert new values into this hashtable by using the same put() method that I presented at Section 11.2.5. And you can also get values from the hashtable by using the same get() method that I exposed on previous sections. Like it‚Äôs ArrayHashMap brother, to delete values from this specific type of hashtable, we also use the orderedRemove() and swapRemove() methods, with the same effects that I described at Section 11.2.4.\nIf we take the code example that was exposed at Section 11.2.5, we can achieve the exact same result with StringArrayHashMap(). All we have to do is to change the use of StringHashMap() to StringArrayHashMap() at the fifth line in this code example. It would change to this:\n\nvar ages = std.StringArrayHashMap(u8).init(allocator);",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html#linked-lists",
    "href": "Chapters/09-data-structures.html#linked-lists",
    "title": "11¬† Data Structures",
    "section": "11.3 Linked lists",
    "text": "11.3 Linked lists\nThe Zig Standard Library provides implementation for both single and doubly linked lists. A linked list is a linear data structure that looks like a chain, or, a rope. The main advantage of this data structure is that you normally have fast insertion and deletion operations. But, as a disadvantage, iterating through this data structure is usually not so fast as iterating through an array.\nThe idea behind a linked list is basically build a structure that concists of a series of nodes connected to each other by pointers. This means that linked lists are usually not contiguos in memory, because each node might be south in memory, but the next node might be north in memory, then the next node might be left in memory, anyway, you get it, they can be anywhere.\nAt Figure¬†11.3 we can see a diagram of a singly linked list. Notice that we begin with a first node. This first node is usually called ‚Äúthe head of the linked list‚Äù. Then, from this first node we uncover the remaining nodes in the structure, by following the locations pointed by the pointers.\nEvery node have two things in it. It have the value that is stored in the current node , and also have a pointer. This pointer points to the next node in the list. If this pointer is null, then, it means that we reached the end of our linked list.\n\n\n\n\n\n\nFigure¬†11.3: A diagram of a singly linked list.\n\n\n\nAt Figure¬†11.4 we can see a diagram of a doubly linked list. The only thing that really changes is that every node in the linked list have both a pointer to the previous node, and, a pointer to the next node. So every node have now two pointers in it. These are usually called the prev (for ‚Äúprevious‚Äù) and next (for ‚Äúnext‚Äù) pointers of the node.\nIn the singly linked list example, we had only one single pointer in each node, and this singular pointer was always pointing to the next node in the sequence. In other words, singly linked lists normally have only the next pointer in them.\n\n\n\n\n\n\nFigure¬†11.4: A diagram of a doubly linked list.\n\n\n\nLinked lists are available in Zig through the functions SinglyLinkedList() and DoublyLinkedList(), for ‚Äúsingly linked lists‚Äù and ‚Äúdoubly linked lists‚Äù, respectively. These functions are actually generic functions, which we are going to talk more about at Section 12.2.1.\nFor now, just understand that, in order to create a linked list object, we begin by providing a data type to these functions. This data type defines the type of data that this linked list will store. In the example below, we are creating a singly linked list capable of storing u32 values. So each node in this linked list will store a u32 value.\nBoth the SinglyLinkedList() and DoublyLinkedList() functions returns a type, i.e.¬†a struct definition, as result. This means that the object Lu32 is actually a type definition, or a struct definition. It defines the type ‚Äúsingly linked list of u32 values‚Äù.\nSo now that we have the definition of the struct, we have to instantiate a Lu32 object. We normally instantiate struct objects in Zig by using an init() method. But in this case, we are instantiating the struct directly, by using an empty struct literal, in the expression Lu32{}.\nIn this example, we first create multiple node objects, and after we create them, we start to insert and connect these nodes to build the linked list, using the prepend() and insertAfter() methods. Notice that the prepend() method is a method from the linked list object, while the insertAfter() is a method present in the node objects.\nIn essence, the prepend() method inserts a node at the beginning of the linked list. In other words, the node that you provide to this method, becomes the new ‚Äúhead node‚Äù of the linked list. It becomes the first node in the list (see Figure¬†11.3).\nOn the other side, the insertAfter() method is used to basically connect two nodes together. When you provide a node to this method, it creates a pointer to this input node, and stores this pointer in the current node, from which the method was called from. In other words, this method creates the pointer that connects these two nodes together and stores it in the next attribute of the current node.\nSince doubly linked list have both a next and a prev pointers in each node, referring to the next and previous nodes in the sequence, respectively, as I described at Figure¬†11.4, a node object created from a DoublyLinkedList() object would have both a insertBefore() (for prev) and a insertAfter() (for next) methods available.\nThis means that, if we used a doubly linked list, we could use the insertBefore() method to store the pointer to the input node in the prev attribute. This would put the input node as the ‚Äúprevious node‚Äù, or, the node before the current node. The insertAfter() method have ‚Äúafter‚Äù in it‚Äôs name to indicate that this method puts the pointer created to the input node in the next attribute of the current node, and as the result, the input node becomes the ‚Äúnext node‚Äù of the current node.\nSince we are using a singly linked list in this example, we have only the insertAfter() method available in the node objects that we create from our Lu32 type.\n\nconst std = @import(\"std\");\nconst SinglyLinkedList = std.SinglyLinkedList;\nconst Lu32 = SinglyLinkedList(u32);\n\npub fn main() !void {\n    var list = Lu32{};\n    var one = Lu32.Node{ .data = 1 };\n    var two = Lu32.Node{ .data = 2 };\n    var three = Lu32.Node{ .data = 3 };\n    var four = Lu32.Node{ .data = 4 };\n    var five = Lu32.Node{ .data = 5 };\n\n    list.prepend(&two); // {2}\n    two.insertAfter(&five); // {2, 5}\n    list.prepend(&one); // {1, 2, 5}\n    two.insertAfter(&three); // {1, 2, 3, 5}\n    three.insertAfter(&four); // {1, 2, 3, 4, 5}\n}\n\nThere are other methods available from the linked list object, depending if this object is a singly linked list or a doubly linked list, that might be very useful for you, like:\n\nremove() to remove a specific node from the linked list.\npopFirst() to remove the first node from the linked list.\nif singly linked list, len() to count how many nodes there is in the linked list.\nif doubly linked list, checkout the len attribute to see how many nodes there is in the linked list.\nif singly linked list, popFirst() to remove the first node from the linked list.\nif doubly linked list, pop() and popFirst() to remove the last and first nodes from the linked list, respectively.\nif doubly linked list, append() to add a new node to end of the linked list (i.e.¬†inverse of prepend()).",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html#multi-array-structure",
    "href": "Chapters/09-data-structures.html#multi-array-structure",
    "title": "11¬† Data Structures",
    "section": "11.4 Multi array structure",
    "text": "11.4 Multi array structure\nZig introduces a new data structure called MultiArrayList(). It is a different version of the dynamic array that we have introduced at Section 11.1. The difference between this structure and the ArrayList() that we know from Section 11.1, is that MultiArrayList() creates a separate dynamic array for each field of the struct that you provide as input.\nConsider the following code example. We create a new custom struct called Person. This struct contains three different data members, or, three different fields. As consequence, when we provide this Person data type as input to MultiArrayList(), this creates a ‚Äústruct of three different arrays‚Äù called PersonArray. In other words, this PersonArray is a struct that contains three internal dynamic arrays in it. One array for each field found in the Person struct definition.\n\nconst std = @import(\"std\");\nconst Person = struct {\n    name: []const u8,\n    age: u8,\n    height: f32,\n};\nconst PersonArray = std.MultiArrayList(Person);\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var people = PersonArray{};\n    defer people.deinit(allocator);\n\n    try people.append(allocator, .{\n        .name = \"Auguste\", .age = 15, .height = 1.54\n    });\n    try people.append(allocator, .{\n        .name = \"Elena\", .age = 26, .height = 1.65\n    });\n    try people.append(allocator, .{\n        .name = \"Michael\", .age = 64, .height = 1.87\n    });\n}\n\nIn other words, instead of creating an array of ‚Äúpersons‚Äù, the MultiArrayList() function creates a ‚Äústruct of arrays‚Äù. Each data member of this struct is a different array that stores the values of a specific field from the Person struct values that were added (or, appended) to this ‚Äústruct of arrays‚Äù. One important detail is that each of these separate internal arrays stored inside PersonArray are dynamic arrays. This means that these arrays can grow in capacity automatically as needed, to accomodate more values.\nThe Figure¬†11.5 exposed below presents a diagram that describes the PersonArray struct that we have created in the previous code example. Notice that the values of the data members present in each of the three Person values that we have appended into the PersonArray object that we have instantiated, are scattered across three different internal arrays of the PersonArray object.\n\n\n\n\n\n\nFigure¬†11.5: A diagram of the PersonArray struct.\n\n\n\nYou can easily access each of these arrays separately, and iterate over the values of each array. For that, you will need to call the items() method from the PersonArray object, and provide as input to this method, the name of the field that you want to iterate over. If you want to iterate through the .age array for example, then, you need to call items(.age) from the PersonArray object, like in the example below:\n\nfor (people.items(.age)) |*age| {\n    try stdout.print(\"Age: {d}\\n\", .{age.*});\n}\n\nAge: 15\nAge: 26\nAge: 64\nIn the above example, we are iterating over the values of the .age array, or, the internal array of the PersonArray object that contains the values of the age data member from the Person values that were added to the multi array struct.\nIn this example we are calling the items() method directly from the PersonArray object. However, it is recommended on most situations to call this items() method from a ‚Äúslice object‚Äù, which you can create from the slice() method. The reason for this is that calling items() multiple times have better performance if you use a slice object.\nIn other words, if you are planning to access only one of the internal arrays from your ‚Äúmulti array struct‚Äù, it is fine to call items() directly from the multi array object. But if you need to access many of the internal arrays from your ‚Äúmulti array struct‚Äù, then, you will likely need to call items() more than once, and, in such circustance, is better to call items() through a slice object. The example below demonstrates the use of such object:\n\nvar slice = people.slice();\nfor (slice.items(.age)) |*age| {\n    age.* += 10;\n}\nfor (slice.items(.name), slice.items(.age)) |*n,*a| {\n    try stdout.print(\n        \"Name: {s}, Age: {d}\\n\", .{n.*, a.*}\n    );\n}\n\nName: Auguste, Age: 25\nName: Elena, Age: 36\nName: Michael, Age: 74",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html#conclusion-1",
    "href": "Chapters/09-data-structures.html#conclusion-1",
    "title": "11¬† Data Structures",
    "section": "11.5 Conclusion",
    "text": "11.5 Conclusion\nThere are many other data structures that I did not presented here. But you can check them out at the offical Zig Standard Library documentation page. Actually, when you get into the homepage of the documentation2, the first thing that appears to you in this page, is a list of types and data structures.\nIn this section you can see a list of the many different data structures available in the Zig Standard Library. There are some very specific structures in this list, like a BoundedArray struct3 , but there is also some more general structures, such as a PriorityQueue struct4.\n\n\n\n\nWikipedia. 2024. ‚ÄúHash Tables.‚Äù Wikipedia. https://en.wikipedia.org/wiki/Hash_table.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/09-data-structures.html#footnotes",
    "href": "Chapters/09-data-structures.html#footnotes",
    "title": "11¬† Data Structures",
    "section": "",
    "text": "https://ziglang.org/documentation/master/std/#std.array_list.ArrayListAligned‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.priority_queue.PriorityQueue.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html",
    "href": "Chapters/10-stack-project.html",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "",
    "text": "12.1 Understanding comptime in Zig\nOne of the key features of Zig is comptime. This keyword introduces a whole new concept and paradigm, that is tightly connected with the compilation process. At Section 3.1.1 we described the importance and the role that ‚Äúcompile-time vs runtime‚Äù plays into Zig. At that section, we learned that the rules applied to a value/object change a lot depending on whether this value is known at compile-time, or just at runtime.\nThe comptime keyword is strongly related to these two spaces of time in the compilation process, i.e.¬†the compile-time and the runtime. Let‚Äôs quickly recap the differences. Compile-time is the period of time when your Zig source code is being compiled by the zig compiler, while the runtime is the period of time when your Zig program is being executed, i.e.¬†when we execute the binary files outputted by the zig compiler.\nThere are three ways in which you can apply the comptime keyword, which are:",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#sec-comptime",
    "href": "Chapters/10-stack-project.html#sec-comptime",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "",
    "text": "apply comptime on a function argument.\napply comptime on an object.\napply comptime on a block of expressions.\n\n\n12.1.1 Applying over a function argument\nWhen you apply the comptime on a function argument you are saying to the zig compiler that the value assigned to that particular argument of the function must be known at compile-time. We explained in details at Section 3.1.1 what exactly ‚Äúvalue known at compile-time‚Äù means, so, in case you have doubts about this idea, comeback to that section.\nNow let‚Äôs think about the consequences of this idea. First of all, we are imposing a limit, or, a requirement to that particular function argument. If the programmer accidentally tries to give a value to this function argument that is not known at compile time, the zig compiler will notice this problem, and as a consequence, it will raise a compilation error saying that it cannot compile your program. Because you are providing a value that is ‚Äúruntime known‚Äù to a function argument that must be ‚Äúcompile-time known‚Äù.\nTake a look at this very simple example below, where we define a double() function, that simply doubles the input value named num. Notice that, we use the comptime keyword before the name of the function argument. This keyword is marking the function argument num as a ‚Äúcomptime argument‚Äù.\nThat is a function argument whose value must be compile-time known. This is why the expression double(5678) is valid, and no compilation errors are raised. Because the value 5678 is compile-time known, so this is the expected behaviour for this function.\n\nfn double(comptime num: u32) u32 {\n    return num * 2;\n}\ntest \"test comptime\" {\n    _ = double(5678);\n}\n\nBut what if we provide a number that is not compile-time known to this function? For example, we might provide a different input value to this function depending on the target OS of our compilation process. The code example delow demonstrates such case.\nBecause the value of the object n is determined at runtime, we cannot provide this object as input to the double() function. The zig compiler will not allow it, because we marked the num argument as a ‚Äúcomptime argument‚Äù. That is why the zig compiler raises the compile-time error exposed below:\n\nconst builtin = @import(\"builtin\");\nfn double(comptime num: u32) u32 {\n    return num * 2;\n}\ntest \"test comptime\" {\n    var n: u32 = undefined;\n    if (builtin.target.os.tag == .windows) {\n        n = 1234;\n    } else {\n        n = 5678;\n    }\n    _ = double(n);\n}\n\nt.zig:12:16: error: runtime-known argument passed to comptime parameter \nComptime arguments are frequently used on functions that return some sort of generic structure. In fact, comptime is the essence (or the basis) to make generics in Zig. We are going to talk more about generics at Section 12.2.\nFor now, let‚Äôs take a look at this code example from Seguin (2024). You can see that this IntArray() function have one argument named length. This argument is marked as comptime, and receives a value of type usize as input. So the value given to this argument must be compile-time known. We can also see that this function returns an array of i64 values as output.\n\nfn IntArray(comptime length: usize) type {\n    return [length]i64;\n}\n\nNow, the key component of this function is the length argument. This argument is used to determine the size of the array that is produced by the function. Let‚Äôs think about the consequences of that. If the size of the array is dependent on the value assigned to the length argument, this means that the data type of the output of the function depends on the value of this length argument.\nLet this statement sink for a bit in your mind. As I described at Section 1.2.2, Zig is a strongly-typed language, specially on function declarations. So every time we write a function in Zig, we have to annotate the data type of the value returned by the function. But how can we do that, if this data type depends on the value given to the argument of the function?\nThink about this for a second. If length is equal to 3 for example, then, the return type of the function is [3]i64. But if length is equal to 40, then, the return type becomes [40]i64. At this point the zig compiler would be confused, and raise a compilation error, saying something like this:\n\nHey! You have annotated that this function should return a [3]i64 value, but I got a [40]i64 value instead! This doesn‚Äôt look right!\n\nSo how can you solve this problem? How do we overcome this barrier? This is when the type keyword comes in. This type keyword is basically saying to the zig compiler that this function will return some type, but it doesn‚Äôt know yet what exactly type that is. We will talk more about this at Section 12.2.\n\n\n12.1.2 Applying over an expression\nWhen you apply the comptime keyword over an expression, then, it is garanteed that the zig compiler will execute this expression at compile-time. If for some reason, this expression cannot be executed at compile-time (e.g.¬†for example, maybe this expression depends on a value that is only known at runtime), then, the zig compiler will raise a compilation error.\nTake this example from the official documentation of Zig (Zig Software Foundation 2024). We are executing the same fibonacci() function both at runtime, and, at compile-time. The function is by default executed at runtime, but because we use the comptime keyword at the second ‚Äútry expression‚Äù, this expression is executed at compile-time.\nThis might be a bit confusing for some people. Yes! When I say that this expression is executed at compile-time, I mean that this expression is compiled and executed while the zig compiler is compiling your Zig source code.\nIf you think hard enough about how the C and C++ macros work, you can reach the conclusion that they are also executed at compile-time. Because C and C++ macros are just simple text replacements operations, that are performed at compile-time to form the final version of the C or C++ source code that get‚Äôs sent to the compiler.\n\nconst expect = @import(\"std\").testing.expect;\nfn fibonacci(index: u32) u32 {\n    if (index &lt; 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    // test fibonacci at run-time\n    try expect(fibonacci(7) == 13);\n    // test fibonacci at compile-time\n    try comptime expect(fibonacci(7) == 13);\n}\n\nA lot of your Zig source code might be potentially executed at compile-time, because the zig compiler can figure it out the result value of some types of expressions. Specially if these expressions involves only compile-time known values. We have talked about this at Section 3.1.1.\nBut when you use the comptime keyword on an expression, there is no ‚Äúit might be executed at compile-time‚Äù anymore. With the comptime keyword you are ordering the zig compiler to execute this expression at compile-time. You are imposing this rule, it is garanteed that the compiler will always execute it at compile-time. Or it at least, the compiler will try to execute it. If the compiler cannot execute the expression for whatever reason, the compiler will raise a compilation error.\n\n\n12.1.3 Applying over a block\nBlocks were described at Section 1.7. When you apply the comptime keyword over a block of expressions, you get essentially the same effect when you apply this keyword to a single expression. That is, the entire block of expressions is executed at compile-time by the zig compiler.\nIn the example below, we mark the block labeled of blk as a comptime block, and, therefore, the expressions inside this block are executed at compile-time.\n\nconst expect = @import(\"std\").testing.expect;\nfn fibonacci(index: u32) u32 {\n    if (index &lt; 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci in a block\" {\n    const x = comptime blk: {\n        const n1 = 5;\n        const n2 = 2;\n        const n3 = n1 + n2;\n        try expect(fibonacci(n3) == 13);\n        break :blk n3;\n    };\n    _ = x;\n}",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#sec-generics",
    "href": "Chapters/10-stack-project.html#sec-generics",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "12.2 Introducing Generics",
    "text": "12.2 Introducing Generics\nFirst of all, what is a generic? Generic is the idea to allow a type (f64, u8, u32, bool, and also, user-defined types, like the User struct that we defined at Section 2.3) to be a parameter to methods, classes and interfaces (Geeks for Geeks 2024). In other words, a ‚Äúgeneric‚Äù is a class (or a method) that can work with multiple data types.\nFor example, in Java, generics are created through the operator &lt;&gt;. With this operator, a Java class is capable of receiving a data type as input, and therefore, the class can fit it‚Äôs features according to this input data type. As another example, generics in C++ are supported through the concept of templates. Class templates in C++ are generics.\nIn Zig, generics are implemented through comptime. The comptime keyword allows us to collect a data type at compile time, and pass this data type as input to a piece of code.\n\n12.2.1 A generic function\nTake the max() function exposed below as a first example. This function is essentially a ‚Äúgeneric function‚Äù. In this function, we have a comptime function argument named T. Notice that this T argument have a data type of type. Weird right? This type keyword is the ‚Äúfather of all types‚Äù, or, ‚Äúthe type of types‚Äù in Zig. Because we used this type keyword in the T argument, we are telling the zig compiler that this T argument will receive some data type as input.\nAlso notice the use of the comptime keyword in this argument. As I described at Section 12.1, every time you use this keyword in a function argument, this means that the value of this argument must be known at compile-time. This makes sense, right? Because there is no data type that you can make that is known only at runtime.\nThink about this. Every data type that you will ever write is always known at compile-time. Specially because data types are an essential information for the compiler to actually compile your source code. Having this in mind, makes sense to mark this argument as a comptime argument.\n\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a &gt; b) a else b;\n}\n\nAlso notice that the value of the T argument is actually used to define the data type of the other arguments of the function, a and b, and also at the return type annotation of the function. That is, the data type of these arguments (a and b), and, the return data type of the function itself, are determined by the input value given to the T argument.\nAs a result, we have a generic function that works with different data types. For example, I can provide u8 values to this max() function, and it will work as expected. But if I provide f64 values instead, it will also work as expected. If I did not use a generic function, I would have to write a max() for each one of the data types that I wanted to use. This generic function provides a very useful shortcut for us.\n\nconst std = @import(\"std\");\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a &gt; b) a else b;\n}\ntest \"test max\" {\n    const n1 = max(u8, 4, 10);\n    std.debug.print(\"Max n1: {d}\\n\", .{n1});\n    const n2 = max(f64, 89.24, 64.001);\n    std.debug.print(\"Max n2: {d}\\n\", .{n2});\n}\n\nMax n1: 10\nMax n2: 89.24\n\n\n12.2.2 A generic data structure\nEvery data structure that you find in the Zig Standard Library (e.g.¬†ArrayList, HashMap, etc.) is essentially a generic data structure. These data structures are generic in the sense that they work with any data type you want. You just say which is the data type of the values that are going to be stored in this data structure, and they just work as expected.\nA generic data structure in Zig is the way to replicate a generic class from Java, or, a class template from C++. But you may quest yourself: how do we build a generic data structure in Zig?\nThe basic idea is to write a generic function that creates the data structure definition for the specific type we want. In other words, this generic function behaves as a ‚Äúconstructor‚Äù. The function outputs the struct definition that defines this data structure for a specific data type.\nTo create such function, we need to add a comptime argument to this function that receives a data type as input. We already learned how to do this at the previous section (Section 12.2.1).\nI think the best way to demonstrate how to create a generic data structure is to actually write one. This where we go to our next small project in this book. This one is a very small project, which is to write a stack data structure.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#sec-what-stack",
    "href": "Chapters/10-stack-project.html#sec-what-stack",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "12.3 What is a stack?",
    "text": "12.3 What is a stack?\nA stack data structure is a structure that follows a LIFO (last in first out) principle. Only two operations are normally supported in a stack data structure, which are push and pop. The push operation is used to add new values to the stack, while pop is used to remove values from the stack.\nWhen people try to explain how the stack data structure works, the most common analogy that people use is a stack of plates. Imagine that you have a stack of plates, for example, a stack of 10 plates in your table. Each plate represents a value that is currently stored in this stack.\nCurrently we have a stack with 10 different values, or 10 different plates. Now, imagine that you want to add a new plate (or a new value) to this stack, which translates to the push operation. You would add this plate (or this value) by just putting the new plate on the top of the stack. Then, you would increase the stack to 11 plates.\nBut how would you remove plates (or remove values) from this stack (a.k.a. the pop operation) ? To do that, we would have to remove the plate on the top of the stack, and, as a result, we would have, once again, 10 plates in the stack.\nThis demonstrates the LIFO concept, because the first plate in the stack, which is the plate in the bottom of the stack is the last plate to get out of the stack. Think about it. In order to remove this specific plate from the stack, we have to remove all plates in the stack. So every operation in the stack, either insertion or deletion, is always made at the top of the stack. The Figure¬†12.1 below exposes this logic visually:\n\n\n\n\n\n\nFigure¬†12.1: A diagram of a stack structure. Source: Wikipedia, the free encyclopedia.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#writing-the-stack-data-structure",
    "href": "Chapters/10-stack-project.html#writing-the-stack-data-structure",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "12.4 Writing the stack data structure",
    "text": "12.4 Writing the stack data structure\nWe are going to write the stack data structure in two steps. First, we are going to implement a stack that can only store u32 values. Then, after that, we are going to extend our implementation to make it generic, so that it works with any data type we want.\nFirst, we need to decide how the values will be stored inside the stack. There are multiple ways to implement the storage behind a stack structure. Some people prefer to use a doubly linked list, some others prefer to use a dynamic array, etc. In this example we are going to use an array behind the hood, to store the values in the stack, which is the items data member of our Stack struct definition.\nAlso notice in our Stack struct that we have three other data members: capacity, length and allocator. The capacity member contains the capacity of the underlying array that stores the values in the stack. The length contains the number of values that are currently being stored in the stack. And the allocator contains the allocator object which will be used by the stack structure whenever it needs to allocate more space for the values that are being stored.\nWe begin by defining an init() method of this struct, which is going to be responsible for instantiating a Stack object. Notice that, inside this init() method, we start by allocating an array with the capacity specified in the capacity argument. Then, we use the built-in function @memset() to set all elements of this new array that we have allocated to zero.\nIn other words, this @memset() function is basically equivalent to the memset() function from C Standard Library1. In this example, we are using this function to essentially assign the value 0 to all elements of this array. We do that to initialize this memory that was allocated. Uninitialized memory is a commom source of undefined behaviour, so, this step is made for safety reasons.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Stack = struct {\n    items: []u32,\n    capacity: usize,\n    length: usize,\n    allocator: Allocator,\n\n    pub fn init(allocator: Allocator, capacity: usize) !Stack {\n        var buf = try allocator.alloc(u32, capacity);\n        @memset(buf[0..], 0);\n        return .{\n            .items = buf[0..],\n            .capacity = capacity,\n            .length = 0,\n            .allocator = allocator,\n        };\n    }\n};\n\n\n12.4.1 Implementing the push operation\nNow that we have written the basic logic to create a new Stack object, we can start writing the logic responsible for performing a push operation. Remember, a push operation in a stack data structure is the operation responsible for adding a new value to the stack.\nSo how can we add a new value to the Stack object that we have? The push() function exposed below is an answer to this question. Remember from what we discussed at Section 12.3 that values are always added to the top of the stack. This means that this push() function must always find the element in the underlying array of the stack, that currently represents the top position of the stack, and add this value there.\nFirst, we have an if statement in this function. This if statement is checking whether we need to expand the underlying array to store this new value that we are adding to the stack. In other words, maybe the underlying array does not have enough capacity to store this new value, and, in this case, we need to expand our array to get the capacity that we need.\nSo, if the logic test in this if statement returns true, it means that the array does not have enough capacity, and we need to expand it before we store this new value. So inside this if statement we are executing the necessary expressions to expand the underlying array.\nNotice that we use the allocator object to allocate a new array that is twice as bigger than the current array (self.capacity * 2). Then, we use memset() once again to set all fields in this array to zero, making sure that all memory is properly initialized.\nAfter that, we use a different built-in function named @memcpy(). This built-in function is equivalent to the memcpy() function from the C Standard Library2. It is used to copy the values from one block of memory to another block of memory. In other words, you can use this function to copy the values from one array into another array.\nWe are using this @memcpy() built-in function to copy the values that are currently in the underlying array of the stack object (self.items) into our new and bigger array that we have allocated (new_buf). After we execute this function, the new_buf contains a copy of the values that are present at self.items.\nNow that we have secured a copy of our current values in the new_buf object, we can now free the memory currently allocated at self.items. After that, we just need to assign our new and bigger array to self.items. This is the sequence of steps necessary to expand our array.\n\npub fn push(self: *Stack, val: u32) !void {\n    if ((self.length + 1) &gt; self.capacity) {\n        var new_buf = try self.allocator.alloc(\n            u32, self.capacity * 2\n        );\n        @memset(new_buf[0..], 0);\n        @memcpy(\n            new_buf[0..self.capacity], self.items\n        );\n        self.allocator.free(self.items);\n        self.items = new_buf;\n    }\n\n    self.items[self.length] = val;\n    self.length += 1;\n}\n\nAfter we make sure that we have enough room to store this new value that we are adding to the stack, all we have to do is to assign this value to the top element in this stack, and, increase the value of the length attribute by one. We find the top element in the stack by using the length attribute.\n\n\n12.4.2 Implementing the pop operation\nNow, we can implement the pop operation of our stack object. This is a much easier operation to implement, and the pop method below summarises all the logic that is needed.\nWe just have to find the element in the underlying array that currently represents the top of the stack, and set this element to zero, to indicate that this element is ‚Äúempty‚Äù. After that, we also need to decrease the length attribute of the stack by one.\nIf the current length of the stack is zero, it means that there is no values being stored in the stack currently. So, in this case, we could just return from the function and do nothing really. This is what the if statement inside this function is checking for.\n\npub fn pop(self: *Stack) void {\n    if (self.length == 0) return;\n\n    self.items[self.length - 1] = 0;\n    self.length -= 1;\n}\n\n\n\n12.4.3 Implementing the deinit method\nWe have implemented the methods responsible for the two main operations associated with the stack data structure, which is pop() and push(), and we also have implemented the method responsible for instantiating a new Stack object, which is the init() method.\nBut now, we need to implement also the method responsible for destroying a Stack object. In Zig, this task is commonly associated with the method named deinit(). Most struct objects in Zig have such method, and it is commonly nicknamed of ‚Äúthe destructor method‚Äù.\nIn theory, all we have to do to destroy the Stack object is to make sure that we free the allocated memory for the underlying array, using the allocator object that is stored inside the Stack object. This is what the deinit() method below is doing.\n\npub fn deinit(self: *Stack) void {\n    self.allocator.free(self.items);\n}",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#making-it-generic",
    "href": "Chapters/10-stack-project.html#making-it-generic",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "12.5 Making it generic",
    "text": "12.5 Making it generic\nNow that we have implemented the basic skeleton of our stack data structure, we can now focus on discussing how can we make it generic. How can we make this basic skeleton to work not only with u32 values, but also, with any other data type we want? For example, we might need to create a stack object to store User values in it. How can we make this possible? The answer lies on the use of generics and comptime.\nAs I described at Section 12.2.2, the basic idea is to write a generic function that returns as result a struct definition as output. In theory, we do not need much to transform our Stack struct into a generic data structure. All that we need to do, to make our Stack struct generic, is to transform the underlying array in the stack structure into a generic array.\nIn other words, this underlying array needs to be a ‚Äúchameleon‚Äù. It needs to adapt, and transform it into an array of the data type that we give it to. For example, if we need to create a stack that will store u8 values, then, this underlying array needs to be a u8 array (i.e.¬†[]u8). But if we need to store User values instead, then, this array needs to be a User array (i.e.¬†[]User). Etc.\nWe do that by using a generic function. Because a generic function can receive a data type as input, and we can pass this data type to the struct definition of our Stack object. Therefore, we can use the generic function to create a Stack object that can store the data type we want. If we want to create a stack structure that stores User values, we pass the User data type to this generic function, and it will create for us the struct definition that describes a Stack object that can store User values in it.\nTake the code example below as an example. I truncated some parts of the Stack struct for brevity reasons. But if a specific part of our Stack struct is not exposed here in this example, is because this part did not changed from the previous example. It remains the same.\n\nfn Stack(comptime T: type) type {\n    return struct {\n        items: []T,\n        capacity: usize,\n        length: usize,\n        allocator: Allocator,\n        const Self = @This();\n\n        pub fn init(allocator: Allocator, capacity: usize) !Stack(T) {\n            var buf = try allocator.alloc(T, capacity);\n            @memset(buf[0..], 0);\n            return .{\n                .items = buf[0..],\n                .capacity = capacity,\n                .length = 0,\n                .allocator = allocator,\n            };\n        }\n\n        pub fn push(self: *Self, val: T) !void {\n        // Truncate the rest of the struct\n    };\n}\n\nNotice that we have created a function in this example named Stack(). This function takes a type as input, and passes this type to the struct definition of our Stack object. The data member items is now, an array of type T, which is the data type that we passed as input to the function. The function argument val in the push() function is now a value of type T too.\nNow we have finally a stack data structure that is generic. I mean, we probably still need to adjust the @memset() calls, to trully make it generic for any data type. But this version is good enough, and it really works well with any of the primitive data types of Zig.\nWe can just provide a data type to this function, and it will create a definition of a Stack object that can store values of the data type that we provided. In the example below, we are creating the definition of a Stack object that can store u8 values in it. This definition is stored at the Stacku8 object. This Stacku8 object becomes our new struct, it is the struct that we are going to use to create our Stack object.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nconst Stacku8 = Stack(u8);\nvar stack = try Stacku8.init(allocator, 10);\ndefer stack.deinit();\ntry stack.push(1);\ntry stack.push(2);\ntry stack.push(3);\ntry stack.push(4);\ntry stack.push(5);\ntry stack.push(6);\n\nstd.debug.print(\"Stack len: {d}\\n\", .{stack.length});\nstd.debug.print(\"Stack capacity: {d}\\n\", .{stack.capacity});\n\nstack.pop();\nstd.debug.print(\"Stack len: {d}\\n\", .{stack.length});\nstack.pop();\nstd.debug.print(\"Stack len: {d}\\n\", .{stack.length});\nstd.debug.print(\"Stack state: {any}\\n\", .{stack.items});\n\nStack len: 6\nStack capacity: 10\nStack len: 5\nStack len: 4\nStack state: { 1, 2, 3, 4, 0, 0, 0, 0, 0, 0 }\nEvery generic data structure in the Zig Standard Library (ArrayList, HashMap, SinlyLinkedList, etc.) is implemented through this logic, of using a generic function to create the struct definition that can work with the data type that you provided as input.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#conclusion",
    "href": "Chapters/10-stack-project.html#conclusion",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "12.6 Conclusion",
    "text": "12.6 Conclusion\nThe full source code of the stack structure discussed in this chapter is freely available at the official repository for this book. Just checkout the stack.zig3 for the u32 version of our stack, and the generic_stack.zig4 for the generic version, available inside the ZigExamples folder of the repository.\n\n\n\n\nGeeks for Geeks. 2024. ‚ÄúGenerics in c++.‚Äù Geeks for Geeks. https://www.geeksforgeeks.org/generics-in-c/.\n\n\nSeguin, Karl. 2024. ‚ÄúGenerics.‚Äù https://www.openmymind.net/learning_zig/generics/.\n\n\nZig Software Foundation. 2024. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/10-stack-project.html#footnotes",
    "href": "Chapters/10-stack-project.html#footnotes",
    "title": "12¬† Project 3 - Building a stack data structure",
    "section": "",
    "text": "https://www.tutorialspoint.com/c_standard_library/c_function_memset.htm‚Ü©Ô∏é\nhttps://www.tutorialspoint.com/c_standard_library/c_function_memcpy.htm‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/tree/main/ZigExamples/data-structures/stack.zig‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/tree/main/ZigExamples/data-structures/generic_stack.zig‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Project 3 - Building a stack data structure</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html",
    "href": "Chapters/12-file-op.html",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "",
    "text": "13.1 Input/Output basics\nIf you have programming experience in a high-level language, you certainly have used before the input and output functionalities of this language. In other words, you certainly have been in a situation where you needed to sent some output to the user, or, to receive an input from the user.\nFor example, in Python we can receive some input from the user by using the input() built-in function. But we can also print (or ‚Äúshow‚Äù) some output to the user by using the print() built-in function. So yes, if you have programmed before in Python, you certainly have used these functions once before.\nBut do you know how these functions relate back to your operating system (OS)? How exactly they are interacting with the resources of your OS to receive or sent input/output. In essence, these input/output functions from high-level languages are just abstractions over the standard output and standard input channels of your operating system.\nThis means that we receive an input, or send some output, through the operating system. It is the OS that makes the bridge between the user and your program. Your program does not have a direct access to the user. It is the OS that intermediates every message exchanged between your program and the user.\nThe standard output and standard input channels of your OS are commonly known as the stdout and stdin channels of your OS, respectively. In some contexts, they are also called of the standard output device and standard input device. As the name suggests, the standard output is the channel through which output flows, while the standard input is the channel in which input flows.\nFurthermore, OS‚Äôs also normally create a dedicated channel for exchanging error messages, known as the standard error channel, or, the stderr channel. This is the channel to which error and warning messages are usually sent to. These are the messages that are normally displayed in red-like or orange-like colors into your terminal.\nNormally, every OS (e.g.¬†Windows, MacOS, Linux, etc.) creates a dedicated and separate pair of standard output, standard error and standard input channels for every single program (or process) that runs in your computer. This means that every program you write have a dedicated stdin, stderr and stdout that are separate from the stdin, stderr and stdout of other programs and processes that are currently running.\nThis is a behaviour from your OS. This does not come from the programming language that you are using. Because as I sad earlier, input and output in programming languages, specially in high-level ones, are just a simple abstraction over the stdin, stderr and stdout from your current OS. That is, your OS is the intermediary between every input/output operation made in your program, regardless of the programming language that you are using.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#sec-io-basics",
    "href": "Chapters/12-file-op.html#sec-io-basics",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "",
    "text": "13.1.1 The writer and reader pattern\nIn Zig, there is a pattern around input/output (IO). I (the author of this book) don‚Äôt know if there is an official name for this pattern. But here, in this book, I will call it the ‚Äúwriter and reader pattern‚Äù. In essence, every IO operation in Zig is made through either a GenericReader or a GenericWriter object1.\nThese two data types come from the std.io module of the Zig Standard Library. As their names suggests, a GenericReader is an object that offers tools to read data from ‚Äúsomething‚Äù (or ‚Äúsomewhere‚Äù), while a GenericWriter offers tools to write data into this ‚Äúsomething‚Äù. This ‚Äúsomething‚Äù might be different things: like a file that exists in your filesystem; or, it might be a network socket of your system2; or, a continuous stream of data, like a standard input device from your system, that might be constantly receiving new data from users, or, as another example, a live chat in a game that is constantly receiving and displaying new messages from the players of the game.\nSo, if you want to read data from something, or somewhere, it means that you need to use a GenericReader object. But if you need instead, to write data into this ‚Äúsomething‚Äù, then, you need to use a GenericWriter object instead. Both of these objects are normally created from a file descriptor object. More specifically, through the writer() and reader() methods of this file descriptor object. If you are not familiar with this type of object, go to the next section.\nEvery GenericWriter object have methods like print(), which allows you to write/send a formatted string (i.e.¬†this formatted string is like a f string in Python, or, similar to the printf() C function) into the ‚Äúsomething‚Äù (file, socket, stream, etc.) that you are using. It also have a writeAll() method, which allows you to write a string, or, an array of bytes into the ‚Äúsomething‚Äù.\nLikewise, every GenericReader object have methods like readAll(), which allows you to read the data from the ‚Äúsomething‚Äù (file, socket, stream, etc.) until it fills a particular array (i.e.¬†a ‚Äúbuffer‚Äù) object. In other words, if you provide an array object of 300 u8 values to readAll(), then, this method attempts to read 300 bytes of data from the ‚Äúsomething‚Äù, and it stores them into the array object that you have provided.\nWe also have other methods, like the readAtLeast() method, which allows you to specify how many bytes exactly you want to read from the ‚Äúsomething‚Äù. In more details, if you give the number \\(n\\) as input to this method, then, it will attempt to read at least \\(n\\) bytes of data from the ‚Äúsomething‚Äù. The ‚Äúsomething‚Äù might have less than \\(n\\) bytes of data available for you to read, so, it is not garanteed that you will get precisely \\(n\\) bytes as result.\nAnother useful method is readUntilDelimiterOrEof(). In this method, you specify a ‚Äúdelimiter character‚Äù. The idea is that this function will attempt to read as many bytes of data as possible from the ‚Äúsomething‚Äù, until it encounters the end of the stream, or, it encounters the ‚Äúdelimiter character‚Äù that you have specified.\nIf you don‚Äôt know exactly how many bytes will come from the ‚Äúsomething‚Äù, you may find the readAllAlloc() method useful. In essence, you provide an allocator object to this method, so that it can allocate more space if needed. As consequence, this method will try to read all bytes of the ‚Äúsomething‚Äù, and, if it runs out of space at some point during the ‚Äúreading process‚Äù, it uses the allocator object to allocate more space to continue reading the bytes. As result, this method returns a slice to the array object containing all the bytes read.\nThis is just a quick description of the methods present in these types of objects. But I recommend you to read the official docs, both for GenericWriter3 and GenericReader4. I also think it is a good idea to read the source code of the modules in the Zig Standard Library that defines the methods present in these objects, which are the Reader.zig5 and Writer.zig6.\n\n\n13.1.2 Introducing file descriptors\nA ‚Äúfile descriptor‚Äù object is a core component behind every I/O operation that is made in any operating system (OS). Such object is an identifier for a particular input/output (IO) resource from your OS (Wikipedia 2024). It describes and identifies this particular resource. An IO resource might be:\n\nan existing file in your filesystem.\nan existing network socket.\nother types of stream channels.\na pipeline (or just ‚Äúpipe‚Äù) in your terminal7.\n\nFrom the bulletpoints listed aboved, we know that although the term ‚Äúfile‚Äù is present, a ‚Äúfile descriptor‚Äù might describe something more than just a file. This concept of a ‚Äúfile descriptor‚Äù comes from the Portable Operating System Interface (POSIX) API, which is a set of standards that guide how operating systems across the world should be implemented, to maintain compatibility between them.\nA file descriptor not only identifies the input/output resource that you are using to receive or send some data, but it also describes where this resource is, and also, which IO mode this resource is currently using. For example, this IO resource might be using only the ‚Äúread‚Äù IO mode, which means that this resource is open to ‚Äúread operations‚Äù, while ‚Äúwrite operations‚Äù are closed and not authorized. These IO modes are essentially, the modes that you provide to the argument mode from the fopen() C function, and also, from the open() Python built-in function.\nIn C, a ‚Äúfile descriptor‚Äù is a FILE pointer, but, in Zig, a file descriptor is a File object. This data type (File) is described in the std.fs module of the Zig Standard Library. We normally don‚Äôt create a File object directly in our Zig code. Instead, we normally get such object as result when we open an IO resource. In other words, we normally ask to our OS to open and use a particular IO resource, and, if the OS do open succesfully this IO resource, the OS normally handles back to us a file descriptor to this particular IO resource.\nSo you usually get a File object by using functions and methods from the Zig Standard Library that asks the OS to open some IO resources, like the openFile() method that opens a file in the filesystem. The net.Stream object that we have created at Section 7.4.1 is also a type of file descriptor object.\n\n\n13.1.3 The standard output\nYou already saw across this book, how can we access and use specifically the stdout in Zig to send some output to the user. For that, we use the getStdOut() function from the std.io module. This function returns a file descriptor that describes the stdout channel of your current OS. Through this file descriptor object, we can read from or write stuff to the stdout of our program.\nAlthough we can read stuff recorded into the stdout channel, we normally only write to (or ‚Äúprint‚Äù) stuff into this channel. The reason is very similar to what we discussed at Section 7.4.3, when we were discussing what ‚Äúreading from‚Äù versus ‚Äúwriting to‚Äù the connection object from our small HTTP Server project would mean.\nWhen we write stuff into a channel, we are essentially sending data to the other end of this channel. In contrast, when we read stuff from this channel, we are essentially reading the data that was sent through this channel. Since the stdout is a channel to send output to the user, the key verb here is send. We want to send something to someone, and, as consequence, we want to write something into some channel.\nThat is why, when we use getStdOut(), most of the times, we also use the writer() method from the stdout file descriptor, to get access to a writer object that we can use to write stuff into this stdout channel. More specifically, this writer() method returns a GenericWriter object. One of the main methods of this GenericWriter object is the print() method that we have used before to write (or ‚Äúprint‚Äù) a formatted string into the stdout channel.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    try stdout.writeAll(\n        \"This message was written into stdout.\\n\"\n    );\n}\n\nThis message was written into stdout.\nThis GenericWriter object is like any other generic writer object that you would normally get from a file descriptor object. So, the same methods from a generic writer object that you would use while writing files to the filesystem for example, you could also use them here, from the file descriptor object of stdout, and vice-versa.\n\n\n13.1.4 The standard input\nYou can access the standard input (i.e.¬†stdin) in Zig by using the getStdIn() function from the std.io module. Like it‚Äôs sister (getStdOut()), this function also returns a file descriptor object that describes the stdin channel of your OS.\nSince now, we want to receive some input from the user, the key verb here becomes receive, and, as consequence, we usually want to read data from the stdin channel, instead of writing data into it. So, we normally use the reader() method of the file descriptor object returned by getStdIn(), to get access to a GenericReader object that we can use to read data from stdin.\nIn the example below, we are creating a small buffer capable of holding 20 characters. Then, we try to read the data from the stdin with the readUntilDelimiterOrEof() method, and save this data into the buffer object. Also notice that we are reading the data from the stdin until we hit a new line character ('\\n').\nIf you execute this program, you will notice that this program stops the execution, and start to wait indefinetly for some input from the user. In other words, you need to type your name into the terminal, and then, you press Enter to send your name to stdin. After you send your name to stdin, the program reads this input, and continues with the execution, by printing the given name to stdout. In the example below, I typed my name (Pedro) into the terminal, and then, pressed Enter.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst stdin = std.io.getStdIn().reader();\npub fn main() !void {\n    try stdout.writeAll(\"Type your name\\n\");\n    var buffer: [20]u8 = undefined;\n    @memset(buffer[0..], 0);\n    _ = try stdin.readUntilDelimiterOrEof(buffer[0..], '\\n');\n    try stdout.print(\"Your name is: {s}\\n\", .{buffer});\n}\n\nType your name\nYour name is: Pedro\n\n\n\n13.1.5 The standard error\nThe standard error (a.k.a. the stderr) works exactly the same as the stdout. You just call the getStdErr() function from the std.io module, and you get the file descriptor to stderr. Ideally, you should write only error or warning messages to stderr, because this is the purpose of this channel.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#buffered-io",
    "href": "Chapters/12-file-op.html#buffered-io",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.2 Buffered IO",
    "text": "13.2 Buffered IO\nAs we described at Section 13.1, input/output (IO) operations are made directly by the operating system. It is the OS that manages the IO resource that you want to use for your IO operations. The consequence of this fact is that IO operations are heavilly based on system calls (i.e.¬†calling the operating system directly).\nJust to be clear, there is nothing particularly wrong with system calls. We use them all the time on any serious codebase written in any low-level programming language. However, system calls are always orders of magnitude slower than many different types of operations.\nSo is perfectly fine to use a system call once in a while. But when these system calls start to be used often, you can clearly notice most of the times the lost of performance in your application. So, the good rule of thumbs is to use a system call only when it is needed, and also, only in infrequent situations, to reduce the number of system calls performed to a minimum.\n\n13.2.1 Understanding how buffered IO works\nBuffered IO is a strategy to achieve better performance. It is used to reduce the number of system calls made by IO operations, and, as consequence, achieve a much higher performance. At Figure¬†13.1 you can find two different diagrams which presents the differences between read operations performed in an unbuferred IO environment versus a buffered IO environemnt.\nTo give a better context to these diagrams, let‚Äôs suppose that we have a text file that contains the famous Lorem ipsum text8 in our filesystem. Let‚Äôs also suppose that these diagrams at Figure¬†13.1 are showing the read operations that we are performing to read the Lorem ipsum text from this text file. The first thing you notice when looking at the diagrams, is that in an unbuffered environment the read operations leads to many system calls. More precisely, in the diagram exposed at Figure¬†13.1 (a) we get one system call per each byte that we read from the text file. On the other hand, at Figure¬†13.1 (b) we have only one system call at the very beginning.\nWhen we use a buffered IO system, at the first read operation we perform, instead of sending one single byte directly to our program, the OS first sends a chunk of bytes from the file to a buffer object (i.e.¬†an array). This chunk of bytes are cached/stored inside this buffer object, and when this operation is done, then your program receives the byte that it actually asked for.\nFrom now on, for every new read operation that you perform, instead of making a new system call to ask for the next byte in the file to the OS, this read operation is redirected to the buffer object, that have this next byte already cached and ready to go.\n\n\n\n\n\n\n\n\n\n\n\n(a) Unbuffered IO\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Buffered IO\n\n\n\n\n\n\n\nFigure¬†13.1: Diagrams of read operations performed in buffered IO and unbuffered IO environments.\n\n\n\nThis is the basic logic behind buffered IO systems. The size of the buffer object depends, but most of the times, it is equal to a full page of memory (4096 bytes). If we follow this logic, then, the OS reads the first 4096 bytes of the file and caches it into the buffer object. As long as your program does not consume all of the 4096 bytes from the buffer, not a single system call is created.\nHowever, as soon as you consume all of the 4096 bytes from the buffer, it means that there is no bytes left in the buffer. In this situation, a new system call is made to ask the OS to send the next 4096 bytes in the file, and once again, these bytes are cached into the buffer object, and the cycle starts once again.\n\n\n13.2.2 Buffered IO across different languages\nIO operations made through a FILE pointer in C are buffered by default, so, at least in C, you don‚Äôt need to worry about this subject. But in contrast, IO operations in both Rust and Zig are not buffered depending on which functions from the standard libraries that you are using.\nFor example, in Rust, buffered IO is implemented through the BufReader and BufWriter structs, while in Zig, it is implemented through the BufferedReader and BufferedWriter structs. So any IO operation that you perform through the GenericWriter and GenericReader objects that I presented at Section 13.1.1 are not buffered, which means that these objects might create a lot of system calls depending on the situation.\n\n\n13.2.3 Using buffered IO in Zig\nUsing buffered IO in Zig is actually very easy. All you have to do is to just give the GenericWriter object to the bufferedWriter() function, or, to give the GenericReader object to the bufferedReader() function. These functions come from the std.io module, and they will construct the BufferedWriter or BufferedReader object for you.\nAfter you create this new BufferedWriter or BufferedReader object, you can call the writer() or reader() method of this new object, to get access to a new (and buffered) generic reader or generic writer.\nLet‚Äôs describe the process once again. Every time that you have a file descriptor object, you first get the generic writer or generic reader object from it, by calling the writer() or reader() methods of this file descriptor object. Then, you provide this generic writer or generic reader to the bufferedWriter() or bufferedReader() function, which creates a new BufferedWriter or BufferedReader object. Then, you call the writer() or reader() methods of this buffered writer or buffered reader object, which gives you access to a generic writer or generic reader object that is buffered.\nTake this program as an example. This program is essentially demonstrating the process exposed at Figure¬†13.1 (b). We are simply opening a text file that contains the Lorem ipsum text, and then, we create a buffered IO reader object at bufreader, and we use this bufreader object to read the contents of this file into a buffer object, then, we end the program by printing this buffer to stdout.\n\nvar file = try std.fs.cwd().openFile(\n    \"ZigExamples/file-io/lorem.txt\", .{}\n);\ndefer file.close();\nvar buffered = std.io.bufferedReader(file.reader());\nvar bufreader = buffered.reader();\n\nvar buffer: [1000]u8 = undefined;\n@memset(buffer[0..], 0);\n\n_ = try bufreader.readUntilDelimiterOrEof(\n    buffer[0..], '\\n'\n);\ntry stdout.print(\"{s}\\n\", .{buffer});\n\nLorem ipsum dolor sit amet, consectetur\nadipiscing elit. Sed tincidunt erat sed nulla ornare, nec\naliquet ex laoreet. Ut nec rhoncus nunc. Integer magna metus,\nultrices eleifend porttitor ut, finibus ut tortor. Maecenas\nsapien justo, finibus tincidunt dictum ac, semper et lectus.\nVivamus molestie egestas orci ac viverra. Pellentesque nec\narcu facilisis, euismod eros eu, sodales nisl. Ut egestas\nsagittis arcu, in accumsan sapien rhoncus sit amet. Aenean\nneque lectus, imperdiet ac lobortis a, ullamcorper sed massa.\nNullam porttitor porttitor erat nec dapibus. Ut vel dui nec\nnulla vulputate molestie eget non nunc. Ut commodo luctus ipsum,\nin finibus libero feugiat eget. Etiam vel ante at urna tincidunt\nposuere sit amet ut felis. Maecenas finibus suscipit tristique.\nDonec viverra non sapien id suscipit.\nDespite being a buffered IO reader, this bufreader object is similar to any other GenericReader object, and have the exact same methods. So, although these two types of objects perform very different IO operations, they have the same interface, so, you the programmer, can interchangeably use them without the need to change anything in your source code. So a buffered IO reader or a buffered IO writer objects have the same methods than it‚Äôs generic and unbuffered brothers, i.e.¬†the generic reader and generic writer objects that I presented at Section 13.1.1.\n\n\n\n\n\n\nTip\n\n\n\nIn general, you should always use a buffered IO reader or a buffered IO writer object to perform IO operations in Zig. Because they deliver better performance to your IO operations.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#filesystem-basics",
    "href": "Chapters/12-file-op.html#filesystem-basics",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.3 Filesystem basics",
    "text": "13.3 Filesystem basics\nNow that we have discussed the basics around Input/Output operations in Zig, we need to talk about the basics around filesystems, which is another core part of any operating system. Also, filesystems are related to input/output, because the files that we store and create in our computer are considered an IO resource, as we described at Section 13.1.2.\nLikewise when we were talking about input/output, if you have ever programmed in your life, you probably know some basics about filesystems and file operations, etc. But, since I don‚Äôt know you, I don‚Äôt know what is your background. As a result, these concepts that I will describe might be clear in your mind, but they also maybe be not as clear as you think. Just bare with me, while I‚Äôm trying to put everyone on the same basis.\n\n13.3.1 The concept of current working directory (CWD)\nThe working directory is the folder on your computer where you are currently rooted at, or in other words, it is the folder that your program is currently looking at. Therefore, whenever you are executing a program, this program is always working with a specific folder on your computer. It is always in this folder that the program will initially look for the files you require, and it is also in this folder that the program will initially save all the files you ask it to save.\nThe working directory is determined by the folder from which you invoke your program in the terminal. In other words, if you are in the terminal of your OS, and you execute a binary file (i.e.¬†a program) from this terminal, the folder to which your terminal is pointing at is the current working directory of your program that is being executed.\nAt Figure¬†13.2 we have an example of me executing a program from the terminal. We are executing the program outputted by the zig compiler by compiling the Zig module named hello.zig. The CWD in this case is the zig-book folder. In other words, while the hello.zig program is executing, it will be looking at the zig-book folder, and any file operation that we perform inside this program, will be using this zig-book folder as the ‚Äústarting point‚Äù, or, as the ‚Äúcentral focus‚Äù.\n\n\n\n\n\n\nFigure¬†13.2: An example of executing a program from the terminal\n\n\n\nJust because we are rooted inside a particular folder (in the case of Figure¬†13.2, the zig-book folder) of our computer, it doesn‚Äôt mean that we cannot access or write resources in other locations of our computer. The current working directory (CWD) mechanism just defines where your program will look first for the files you ask for. This does not prevent you from accessing files that are located elsewhere on your computer. However, to access any file that is in a folder other than your current working directory, you must provide a path to that file or folder.\n\n\n13.3.2 The concept of paths\nA path is essentially a location. It points to a location in your filesystem. We use paths to describe the location of files and folders in our computer. One important aspect is that paths are always written inside strings, i.e.¬†they are always provided as text values.\nThere are two types of paths that you can provide to any program in any OS: a relative path, or an absolute path. Absolute paths are paths that start at the root of your filesystem, and go all the way to the file name or the specfic folder that you are referring to. This type of path is called absolute, because it points to a unique, absolute location on your computer. That is, there is no other existing location on your computer that corresponds to this path. It is an unique identifier.\nIn Windows, an absolute path is a path that starts with a hard disk identifier (e.g.¬†C:/Users/pedro). On the other hand, absolute paths in Linux and MacOS, are paths that start with a forward slash character (e.g.¬†/usr/local/bin). Notice that a path is composed by ‚Äúsegments‚Äù. Each segment is connected to each other by a slash character (\\ or /). On Windows, the backward slash (\\) is normally used to connect the path segments. While on Linux and MacOS, the forward slash (/) is the character used to connect path segments.\nIn contrast, a relative path is a path that start at the CWD. In other words, a relative path is ‚Äúrelative to the CWD‚Äù. The path used to access the hello.zig file at Figure¬†13.2 is an example of relative path. This path is reproduced below. This path begins at the CWD, which in the context of Figure¬†13.2, is the zig-book folder, then, it goes to the ZigExamples folder, then, into zig-basics, then, to the hello.zig file.\nZigExamples/zig-basics/hello_world.zig\n\n\n13.3.3 Path wildcards\nWhen providing paths, specially relative paths, you have the option of using a wildcard. There are two commonly used wildcards in paths, which are ‚Äúone period‚Äù (.) and ‚Äútwo periods‚Äù (..). In other words, these two specific characters have special meanings when used in paths, and can be used on any operating system (Mac, Windows, Linux, etc.). That is, they are ‚Äúcross platform‚Äù.\nThe ‚Äúone period‚Äù represents an alias for your current working directory. This means that the relative paths \"./Course/Data/covid.csv\" and \"Course/Data/covid.csv\" are equivalent. On the other hand, the ‚Äútwo periods‚Äù refers to the previous directory. For example, the path \"Course/..\" is equivalent to the path \".\", that is, the current working directory.\nTherefore, the path \"Course/..\" refers to the folder before the Course folder. As another example, the path \"src/writexml/../xml.cpp\" refers to the file xml.cpp that is inside the folder before the writexml folder, which in this example is the src folder. Therefore, this path is equivalent to \"src/xml.cpp\".",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#the-cwd-handler",
    "href": "Chapters/12-file-op.html#the-cwd-handler",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.4 The CWD handler",
    "text": "13.4 The CWD handler\nIn Zig, filesystem operations are usually made through a directory handler object. A directory handler in Zig is an object of type Dir, which is an object that describes a particular folder in the filesystem of our computer. You normally create a Dir object, by calling the std.fs.cwd() function. This function returns a Dir object that points to (or, that describes) the current working directory (CWD).\nThrough this Dir object, you can create new files, or modify, or read existing ones that are inside your CWD. In other words, a Dir object is the main entrypoint in Zig to perform multiple types of filesystem operations. In the example below, we are creating this Dir object, and storing it inside the cwd object. Although we are not using this object at this code example, we are going to use it a lot over the next examples.\n\nconst cwd = std.fs.cwd();\n_ = cwd;",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#file-operations",
    "href": "Chapters/12-file-op.html#file-operations",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.5 File operations",
    "text": "13.5 File operations\n\n13.5.1 Creating files\nWe create new files by using the createFile() method from the Dir object. Just provide the name of the file that you want to create, and this function will do the necessary steps to create such file. You can also provide a relative path to this function, and it will create the file by following this path, which is relative to the CWD.\nThis function might return an error, so, you should use try, catch, or any of the other methods presented at Chapter 10 to handle the possible error. But if everything goes well, this createFile() method returns a file descriptor object (i.e.¬†a File object) as result, through which you can add content to the file with the IO operations that I presented before.\nTake this code example below. In this example, we are creating a new text file named foo.txt. If the function createFile() succeeds, the object named file will contain a file descriptor object, which we can use to write (or add) new content to the file, like we do in this example, by using a buffered writer object to write a new line of text to the file.\nNow, a quick note, when we create a file descriptor object in C, by using a C function like fopen(), we must always close the file at the end of our program, or, as soon as we complete all operations that we wanted to perform on the file. In Zig, this is no different. So everytime we create a new file, this file remains ‚Äúopen‚Äù, waiting for some operation to be performed. As soon as we are done with it, we always have to close this file, to free the resources associated with it. In Zig, we do this by calling the method close() from the file descriptor object.\n\nconst cwd = std.fs.cwd();\nconst file = try cwd.createFile(\"foo.txt\", .{});\n// Don't forget to close the file at the end.\ndefer file.close();\n// Do things with the file ...\nvar fw = file.writer();\n_ = try fw.writeAll(\n    \"Writing this line to the file\\n\"\n);\n\nSo, in this example we not only have created a file into the filesystem, but we also wrote some data into this file, using the file descriptor object returned by createFile(). If the file that you are trying to create already exists in your filesystem, this createFile() call will overwrite the contents of the file, or, in other words, it will in practice erase all the contents of the existing file.\nIf you don‚Äôt want this to happen, meaning, that you don‚Äôt want to overwrite the contents of the existing file, but you want to write data to this file anyway (i.e.¬†you want to append data to the file), you should use the openFile() method from the Dir object.\nAnother important aspect about createFile() is that this method creates a file that is not opened to read operations by default. It means that you cannot read this file. You are not allowed to. So for example, you might want to write some stuff into this file at the beginning of the execution of your program. Then, at a future point in your program you might need to read what you have wroted into this file. If you try to read data from this file, you will likely get a NotOpenForReading error as result.\nBut how can you overcome this barrier? How can you create a file that is open to read operations? All you have to do, is to set the read flag to true in the second argument of createFile(). When you set this flag to true, then the file get‚Äôs create with ‚Äúread permissions‚Äù, and, as consequence, a program like this one below becomes valid:\n\nconst cwd = std.fs.cwd();\nconst file = try cwd.createFile(\"foo.txt\", .{ .read = true });\ndefer file.close();\n\nvar fw = file.writer();\n_ = try fw.writeAll(\"We are going to read this line\\n\");\n\nvar buffer: [300]u8 = undefined;\n@memset(buffer[0..], 0);\ntry file.seekTo(0);\nvar fr = file.reader();\n_ = try fr.readAll(buffer[0..]);\ntry stdout.print(\"{s}\\n\", .{buffer});\n\nWe are going to read this line\nIf you are not familiar with position indicators, you may not recognize what the method seekTo() is, or, what does it do. If that is your case, do not worry, we are going to talk more about this method at Section 13.6. But essentially this method is moving the position indicator back to the beginning of the file, so that we can read the contents of the file from the beginning.\n\n\n13.5.2 Opening files and appending data to it\nOpening files is easy. Just use the openFile() method instead of createFile(). In the first argument of openFile() you provide the path to the file that you want to open. Then, on the second argument you provide the flags (or, the options) that dictates how the file is opened.\nYou can see the full list of options for openFile() by visiting the documentation for OpenFlags9. But the main flag that you will most certainly be worried about is the mode flag. This flag specifies the IO mode that the file will be using when it get‚Äôs opened. There are three IO modes, or, three values that you can provide to this flag, which are:\n\nread_only, allows only read operations on the file. All write operations are blocked.\nwrite_only, allows only write operations on the file. All read operations are blocked.\nread_write, allows both write and read operations on the file.\n\nThese modes are similar to the modes that you provide to the mode argument of the open() Python built-in function10, or, the mode argument of the fopen() C function11. In the code example below, we are opening the foo.txt text file with a write_only mode, and appending a new line of text to the end of the file. We use seekFromEnd() this time to garantee that we are going to append the text to the end of the file. Once again, methods such as seekFromEnd() are described in more depth at Section 13.6.\n\nconst cwd = std.fs.cwd();\nconst file = try cwd.openFile(\"foo.txt\", .{ .mode = .write_only });\ndefer file.close();\ntry file.seekFromEnd(0);\nvar fw = file.writer();\n_ = try fw.writeAll(\"Some random text to write\\n\");\n\n\n\n13.5.3 Deleting files\nSometimes, we just need to delete/remove the files that we have. To do that, we use the deleteFile() method. You just provide the path of the file that you want to delete, and this method will try to delete the file located at this path.\n\nconst cwd = std.fs.cwd();\ntry cwd.deleteFile(\"foo.txt\");\n\n\n\n13.5.4 Copying files\nTo copy existing files, we use the copyFile() method. The first argument in this method is the path to the file that you want to copy. The second argument is a Dir object, i.e.¬†a directory handler, more specifically, a Dir object that points to the folder in your computer where you want to copy the file to. The third argument is the new path of the file, or, in other words, the new location of the file. The fourth argument is the options (or flags) to be used in the copy operation.\nThe Dir object that you provide as input to this method will be used to copy the file to the new location. You may create this Dir object before calling the copyFile() method. Maybe you are planning to copy the file to a completly different location in your computer, so it might be worth to create a directory handler to that location. But if you copying the file to a subfolder of your CWD, then, you can just simply pass the CWD handler to this argument.\n\nconst cwd = std.fs.cwd();\ntry cwd.copyFile(\n    \"foo.txt\",\n    cwd,\n    \"ZigExamples/file-io/foo.txt\",\n    .{}\n);\n\n\n\n13.5.5 Read the docs!\nThere are some other useful methods for file operations available at Dir objects, such as the writeFile() method, but I recommend you to read the docs for the Dir type12 to explore the other available methods, since I already talked too much about them.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#sec-indicators",
    "href": "Chapters/12-file-op.html#sec-indicators",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.6 Position indicators",
    "text": "13.6 Position indicators\nA position indicator is like a type of cursor, or, an index. This ‚Äúindex‚Äù identifies the current location in the file (or, in the data stream) that the file descriptor object that you have is currently looking at. When you create a file descriptor, the position indicator starts at the beginning of the file, or, at the beginning of the stream. When you read or write data into the file (or socket, or data stream, etc.) described by this file descriptor object, you end up moving the position indicator.\nIn other words, any IO operation have a common side effect, which is moving the position indicator. For example, suppose that we have a file of 300 bytes total in size. If you read 100 bytes from the file, the position indicator moves 100 bytes forward. If you try to write 50 bytes into this same file, these 50 bytes will be written from the current position indicated by the position indicator. Since the indicator is at a 100 bytes forward from the beginning of the file, these 50 bytes would be written in the middle of the file.\nThis is why we have used the seekTo() method at the last code example presented at Section 13.5.1. We have used this method to move the position indicator back to the beginning of the file, which would make sure that we would write the text that we wanted to write from the beginning of the file, instead of writing it from the middle of the file. Because before the write operation, we already had performed a read operation, which means that the position indicator was moved in this read operation.\nThe position indicators of a file descriptor object can be changed (or altered) by using the ‚Äúseek‚Äù methods from this file descriptor, which are: seekTo(), seekFromEnd() and seekBy(). These methods have the same effect, or, the same resposibility that the fseek()13 C function.\nConsidering that offset refers to the index that you provide as input to these ‚Äúseek‚Äù methods, the bulletpoints below summarises what is the effect of each of these methods. A quick note, in the case of seekFromEnd() and seekBy(), the offset provided can be either a positive or negative index.\n\nseekTo() will move the position indicator to the location that is offset bytes from the beginning of the file.\nseekFromEnd() will move the position indicator to the location that is offset bytes from the end of the file.\nseekBy() will move the position indicator to the location that is offset bytes from the current position in the file.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#directory-operations",
    "href": "Chapters/12-file-op.html#directory-operations",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.7 Directory operations",
    "text": "13.7 Directory operations\n\n13.7.1 Iterating through the files in a directory\nOne of the most classic tasks related to filesystem is to be able to iterate through the existing files in a directory. Iteration over a directory is made in Zig through a iterator pattern. In other words, we need to create a iterator object, and use this object to iterate through the files.\nYou can produce such directory object by using either the iterate() or walk() methods of a Dir object. Both methods return a iterator object as result, which you can advance by using next(). The difference between these methods, is that iterate() returns a non-recursive iterator, while walk() does. It means that the iterator returned by walk() will not only iterate through the files available in the current directory, but also, through the files from any subdirectory found inside the current directory.\nIn the example below, we are displaying the names of the files stored inside the directory ZigExamples/file-io. Notice that we had to open this directory through the openDir() function. Also notice that we provided the flag iterate in the second argument of openDir(). This flag is important, because without this flag, we would not be allowed to iterate through the files in this directory.\n\nconst cwd = std.fs.cwd();\nconst dir = try cwd.openDir(\n    \"ZigExamples/file-io/\",\n    .{ .iterate = true }\n);\nvar it = dir.iterate();\nwhile (try it.next()) |entry| {\n    try stdout.print(\n        \"File name: {s}\\n\",\n        .{entry.name}\n    );\n}\n\nFile name: create_file_and_write_toit.zig\nFile name: create_file.zig\nFile name: lorem.txt\nFile name: iterate.zig\nFile name: delete_file.zig\nFile name: append_to_file.zig\nFile name: user_input.zig\nFile name: foo.txt\nFile name: create_file_and_read.zig\nFile name: buff_io.zig\nFile name: copy_file.zig\n\n\n13.7.2 Creating new directories\nThere are two methods that are important when it comes to creating directories, which are makeDir() and makePath(). The difference between these two methods is that makeDir() can only create one single directory in the current directory in each call, while makePath() is capable of recursively create subdirectories in the same call.\nThis is why the name of this method is ‚Äúmake path‚Äù. It will create as many subdirectories as necessary to create the path that you provided as input. So, if you provide the path \"sub1/sub2/sub3\" as input to this method, it will create three different subdirectories, sub1, sub2 and sub3, within the same function call. In contrast, if you provided such path as input to makeDir(), you would likely get an error as result, since this method can only create a single subdirectory.\n\nconst cwd = std.fs.cwd();\ntry cwd.makeDir(\"src\");\ntry cwd.makePath(\"src/decoders/jpg/\");\n\n\n\n13.7.3 Deleting directories\nTo delete a directory, just provide the path to the directory that you want to delete as input to the deleteDir() method from a Dir object. In the example below, we are deleting the src directory that we have just created in the previous example.\n\nconst cwd = std.fs.cwd();\ntry cwd.deleteDir(\"src\");",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#conclusion",
    "href": "Chapters/12-file-op.html#conclusion",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "13.8 Conclusion",
    "text": "13.8 Conclusion\nIn this chapter, I have described how to perform in Zig the most common filesystem and IO operations. But you might feel the lack of some other, less common, operation in this chapter, such as: how to rename files, or how to open a directory, or how to create symbolic links, or how to use access() to test if a particular path exists in your computer. But for all of these less common tasks, I recommend you to read the docs of the Dir type14 , since you can find a good description of these cases there.\n\n\n\n\nWikipedia. 2024. ‚ÄúFile Descriptor.‚Äù Wikipedia. https://en.wikipedia.org/wiki/File_descriptor.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#footnotes",
    "href": "Chapters/12-file-op.html#footnotes",
    "title": "13¬† Filesystem and Input/Output (IO)",
    "section": "",
    "text": "Previously, these objects were known as the Reader and Writer objects.‚Ü©Ô∏é\nThe socket objects that we have created at Section 7.4.1, are examples of network sockets.‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.io.GenericWriter.‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.io.GenericReader.‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig.‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/io/Writer.zig.‚Ü©Ô∏é\nA pipeline is a mechanism for inter-process communication, or, inter-process IO. You could also interpret a pipeline as a ‚Äúset of processes that are chained together, through the standard input/output devices of the system‚Äù. At Linux for example, a pipeline is created inside a terminal, by connecting two or more terminal commands with the ‚Äúpipe‚Äù character (|).‚Ü©Ô∏é\nhttps://www.lipsum.com/.‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags‚Ü©Ô∏é\nhttps://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files‚Ü©Ô∏é\nhttps://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.fs.Dir‚Ü©Ô∏é\nhttps://en.cppreference.com/w/c/io/fseek‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/std/#std.fs.Dir‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html",
    "href": "Chapters/14-zig-c-interop.html",
    "title": "14¬† Zig interoperability with C",
    "section": "",
    "text": "14.1 How to call C code from Zig\nInterop with C is not something new. Most high-level programming languages have FFI (foreign function interfaces), which can be used to call C code. For example, Python have Cython, R have .Call(), Javascript have ccall(), etc. But Zig integrates with C in a deeper level, which affects not only the way that C code get‚Äôs called, but also, how this C code is compiled and incorporated into your Zig project.\nIn summary, Zig have great interoperability with C. But if you want to call C code from Zig you will have to perform the following steps:\nIn more details, you should begin by importing into your Zig code the C header file that describes the C functions that you want to call. Which is pretty much the same thing that you would do in C, by including the header files into your C module. After you import the C header file, you can start calling and using the C functions described in this header file directly in your Zig code.\nEverytime you use a C library in your Zig code, you introduce a dependency in your build process. This should come as no surprise to anyone that have any experience with C and C++. Because this is no different in C. Everytime you use a C library in your C code, you also have to build and link your C code with this C library that you are using.\nWhen we use a C library in our Zig code, the zig compiler needs to access the definition of the C functions that are being called in your Zig code. The C header file that we have imported into our Zig code provides the declarations of these C functions, but not their definitions. So, in order to access these definitions, the zig compiler needs to build your Zig code and link it with the C library in the build process.\nAs we discussed across the Chapter 9, there are different strategies to link something with a library. This might involve building the C library first, and then, linking it with the Zig code. Or, it could also involve just the linking step, if this C library is already built and installed in your system. Anyway, if you have doubts about this, comeback to Chapter 9.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html#how-to-call-c-code-from-zig",
    "href": "Chapters/14-zig-c-interop.html#how-to-call-c-code-from-zig",
    "title": "14¬† Zig interoperability with C",
    "section": "",
    "text": "import a C header file into your Zig code.\nlink your Zig code with the C library.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html#sec-import-c-header",
    "href": "Chapters/14-zig-c-interop.html#sec-import-c-header",
    "title": "14¬† Zig interoperability with C",
    "section": "14.2 Importing C header files",
    "text": "14.2 Importing C header files\nTo import a C header file into our Zig code, we use the built-in functions @cInclude() and @cImport(). Inside the @cImport() function, we open a block (with a pair of curly braces). Inside this block we can (if we need to) include multiple @cDefine() calls to define C macros when including this specific C header file. But for the most part, you will probably need to use just a single call inside this block at @cImport(), which is a call to @cInclude().\nThis @cInclude() function is equivalent to the #include statement in C. You provide the name of the C header that you want to include as input to this @cInclude() function, then, in conjunction with @cImport(), it will perform the necessary steps to include this C header file into your Zig code.\nYou should bind the result of @cImport() to a constant object, pretty much like you would do with @import(). You just assign the result to a constant object in your Zig code, and, as consequence, all C functions, C structs, C macros, etc. that are defined inside the C header file will be available through this constant object.\nLook at the code example below, where we are importing the Standard I/O C Library (stdio.h), and calling the printf()1 C function. Notice that we have also used in this example the C function powf()2, which comes from the C Math Library (math.h). In order to compile this example, you have to link this Zig code with both the C Standard Library and the C Math Library, by passing the flags -lc and -lm to the zig compiler.\n\nconst cmath = @cImport({\n    @cInclude(\"math.h\");\n});\nconst stdio = @cImport({\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\n\npub fn main() !void {\n    const x: f32 = 15.2;\n    const y = cmath.powf(x, @as(f32, 2.6));\n    _ = stdio.printf(\"%.3f\\n\", y);\n}\n\n1182.478",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html#sec-zig-obj-to-c",
    "href": "Chapters/14-zig-c-interop.html#sec-zig-obj-to-c",
    "title": "14¬† Zig interoperability with C",
    "section": "14.3 About passing Zig values to C functions",
    "text": "14.3 About passing Zig values to C functions\nZig objects have some intrinsic differences between their C equivalents. Probably the most noticeable one is the difference between C strings and Zig strings, which I described at Section 1.8. Zig strings are objects that contains both an array of arbitrary bytes and a length value. On the other hand, a C string is usually just a pointer to a null-terminated array of arbitrary bytes.\nBecause of these intrinsic differences, in some specific cases, you cannot pass Zig objects directly as inputs to C functions before you convert them into C compatible values. However, in some other cases, you are allowed to pass Zig objects and Zig literal values directly as inputs to C functions, and everything will work just fine, because the zig compiler will handle everything for you.\nSo we have two different scenarios being described here. Let‚Äôs call them ‚Äúauto-conversion‚Äù and ‚Äúneed-conversion‚Äù. The ‚Äúauto-conversion‚Äù scenario is when the zig compiler handles everything for you, and automatically convert your Zig objects/values into C compatible values. In contrast, the ‚Äúneed-conversion‚Äù scenario is when you, the programmer, have the responsibility of converting that Zig object into a C compatible value, before passing it to C code.\nThere is also a third scenario that is not being described here, which is when you create a C object, or, a C struct, or a C compatible value in your Zig code, and you pass this C object/value as input to a C function in your Zig code. This scenario will be described later at Section 14.4. In this section, we are focused on the scenarios where we are passing Zig objects/values to C code, instead of C objects/values being passed to C code.\n\n14.3.1 The ‚Äúauto-conversion‚Äù scenario\nAn ‚Äúauto-conversion‚Äù scenario is when the zig compiler automatically converts our Zig objects into C compatible values for us. This specific scenario happens mostly in two instances:\n\nwith string literal values;\nwith any of the primitive data types that were introduced at Section 1.5.\n\nWhen we think about the second instance described above, the zig compiler does automatically convert any of the primitive data types into their C equivalents, because the compiler knows how to properly convert a i16 into a signed short, or, a u8 into a unsigned char, etc. Now, when we think about string literal values, they can be automatically converted into C strings as well, specially because the zig compiler does not forces a specific Zig data type into a string literal at first glance, unless you store this string literal into a Zig object, and explicitly annotate the data type of this object.\nThus, with string literal values, the zig compiler have more freedom to infer which is the appropriate data type to be used in each situation. You could say that the string literal value ‚Äúinherits it‚Äôs data type‚Äù depending on the context that it is used. Most of the times, this data type is going to be the type that we commonly associate with Zig strings ([]const u8). But it might be a different type depending on the situation. When the zig compiler detects that you are providing a string literal value as input to some C function, the compiler automatically interprets this string literal as a C string value.\nAs an example, look at the code exposed below. Here we are using the fopen() C function to simply open and close a file. If you do not know how this fopen() function works in C, it takes two C strings as input. But in this code example below, we are passing some string literals written in our Zig code directly as inputs to this fopen() C function.\nIn other words, we are not doing any type of conversion from a Zig string to a C string. We are just passing the Zig string literals directly as inputs to the C function. And it works just fine! Because the compiler inteprets the string \"foo.txt\" as a C string, as a result of the current context that this string literal is being used.\n\nconst c = @cImport({\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\n\npub fn main() !void {\n    const file = c.fopen(\"foo.txt\", \"rb\");\n    if (file == null) {\n        @panic(\"Could not open file!\");\n    }\n    if (c.fclose(file) != 0) {\n        return error.CouldNotCloseFileDescriptor;\n    }\n}\n\nLet‚Äôs make some experiments, by writing the same code in different manners, and we see how this affects the program. As a starting point, let‚Äôs store the \"foo.txt\" string inside a Zig object, like the path object below, and then, we pass this Zig object as input to the fopen() C function.\nIf we do this, the program still compiles and runs successfully. Notice that I have ommitted most of the code in this example below. This is just for brevitty reasons, because the remainder of the program is still the same. The only difference between this example and the previous example is just these two lines exposed below.\n\n    const path = \"foo.txt\";\n    const file = c.fopen(path, \"rb\");\n    // Remainder of the program\n\nNow, what happens if you give an explicit data type to the path object? Well, if I force the zig compiler to interpret this path object as a Zig string object, by annotating the path object with the data type []const u8, then, I actually get a compile error as demonstrated below. We get this compile error because now I‚Äôm forcing the zig compiler to interpret path as a Zig string object.\nAccording to the error message, the fopen() C function was expecting to receive an input value of type [*c]const u8 (C string) instead of a value of type []const u8 (Zig string). In more details, the type [*c]const u8 is actually the Zig type representation of a C string. The [*c] portion of this type identifies a C pointer. So, this Zig type essentially means: a C pointer to an array ([*c]) of constant bytes (const u8).\n\n    const path: []const u8 = \"foo.txt\";\n    const file = c.fopen(path, \"rb\");\n    // Remainder of the program\n\nt.zig:10:26: error: expected type '[*c]const u8', found '[]const u8'\n    const file = c.fopen(path, \"rb\");\n                         ^~~~\nTherefore, when we talk exclusively about string literal values, as long as you don‚Äôt give an explicit data type to these string literal values, the zig compiler should be capable of automatically converting them into C strings as needed.\nBut what about using one of the primitive data types that were introduced at Section 1.5? Let‚Äôs take code exposed below as an example of that. Here, we are giving some float literal values as input to the C function powf(). Notice that this code example compiles and runs succesfully.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst cmath = @cImport({\n    @cInclude(\"math.h\");\n});\n\npub fn main() !void {\n    const y = cmath.powf(15.68, 2.32);\n    try stdout.print(\"{d}\\n\", .{y});\n}\n\n593.2023\nOnce again, because the zig compiler does not associate a specific data type with the literal values 15.68 and 2.32 at first glance, the compiler can automatically convert these values into their C float (or double) equivalents, before it passes to the powf() C function. Now, even if I give an explicit Zig data type to these literal values, by storing them into a Zig object, and explicit annotating the type of these objects, the code still compiles and runs succesfully.\n\n    const x: f32 = 15.68;\n    const y = cmath.powf(x, 2.32);\n    // The remainder of the program\n\n593.2023\n\n\n14.3.2 The ‚Äúneed-conversion‚Äù scenario\nA ‚Äúneed-conversion‚Äù scenario is when we need to manually convert our Zig objects into C compatible values before passing them as input to C functions. You will fall in this scenario, when passing Zig string objects to C functions.\nWe already saw this specific circumstance on the last fopen() example, which is reproduced below. You can see in this example, that we have given an explicit Zig data type ([]const u8) to our path object, and, as a consequence of that, we have forced the zig compiler to see this path object, as a Zig string object. Because of that, we need now to manually convert this path object into a C string before we pass it to fopen().\n\n    const path: []const u8 = \"foo.txt\";\n    const file = c.fopen(path, \"rb\");\n    // Remainder of the program\n\nt.zig:10:26: error: expected type '[*c]const u8', found '[]const u8'\n    const file = c.fopen(path, \"rb\");\n                         ^~~~\nThere are different ways to convert a Zig string object into a C string. One way to solve this problem is to provide the pointer to the underlying array of bytes, instead of providing the Zig object directly as input. You can access this pointer by using the ptr property of the Zig string object.\nThe code example below demonstrates this strategy. Notice that, by giving the pointer to the underlying array in path through the ptr property, we get no compile errors as result while using the fopen() C function.\n\n    const path: []const u8 = \"foo.txt\";\n    const file = c.fopen(path.ptr, \"rb\");\n    // Remainder of the program\n\nThis strategy works because this pointer to the underlying array found in the ptr property, is semantically identical to a C pointer to a null-terminated array of bytes, i.e.¬†a C object of type *unsigned char. This is why this option also solves the problem of converting the Zig string into a C string.\nAnother option is to explicitly convert the Zig string object into a C pointer by using the built-in function @ptrCast(). With this function we can convert an object of type []const u8 into an object of type [*c]const u8. As I described at the previous section, the [*c] portion of the type means that it is a C pointer. This strategy is not-recommended. But it is useful to demonstrate the use of @ptrCast().\nYou may recall of the @as() built-in function, which is used to explicit convert (or cast) a Zig value from a type x to a type y, etc. That is, this @as() Zig function is equivalent to the as keyword in Rust, and the C type casting syntax (e.g.¬†(int) x). But in our case here, we are not converting any type of object. More specifically, we are converting something into a pointer, or, a C pointer more specifically. Everytime a pointer is involved in some ‚Äútype casting operation‚Äù in Zig, the @ptrCast() function is involved. This @ptrCast() function is responsible for converting a pointer of one type to a pointer of another type.\nIn the example below, we are using this function to cast our path object into a C pointer to an array of bytes. Then, we pass this C pointer as input to the fopen() function. Notice that this code example compiles succesfully with no errors.\n\n    const path: []const u8 = \"foo.txt\";\n    const c_path: [*c]const u8 = @ptrCast(path);\n    const file = c.fopen(c_path, \"rb\");\n    // Remainder of the program",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html#sec-c-inputs",
    "href": "Chapters/14-zig-c-interop.html#sec-c-inputs",
    "title": "14¬† Zig interoperability with C",
    "section": "14.4 Creating C objects in Zig",
    "text": "14.4 Creating C objects in Zig\nCreating C objects, or, in other words, creating instances of C structs in your Zig code is actually something quite easy to do. You first need to import the C header file (like I described at Section 14.2) that describes the C struct that you are trying to instantiate in your Zig code. After that, you can just create a new object in your Zig code, and annotate it with the C type of the struct.\nFor example, suppose we have a C header file called user.h, and that this header file is declaring a new struct named User. This C header file is exposed below:\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    uint64_t id;\n    char* name;\n} User;\nThis User C struct have two distinct fields, or two struct members, named id and name. The field id is a unsigned 64-bit integer value, while the field name is just a standard C string. Now, suppose that I want to create an instance of this User struct in my Zig code. I can do that by importing this user.h header file into my Zig code, and creating a new object with type User. These steps are reproduced in the code example below.\nNotice that I have used the keyword undefined in this example. This allows me to create the new_user object without the need to provide an initial value to the object. As consequence, the underlying memory associated with this new_user is unintialized, i.e.¬†the memory is currently populated with ‚Äúgarbage‚Äù values. Thus, this expression have the exact same effect of the expression User new_user; in C, which means ‚Äúdeclare a new object named new_user of type User‚Äù.\nIs our responsibility to properly initialize this memory associated with this new_user object, by assigining valid values to the members (or the fields) of the C struct. In the example below, I am assigning the integer 1 to the member id. I am also saving the string \"pedropark99\" into the member name. Notice in this example that I manually add the null character (zero byte) to the end of the allocated array for this string. This null character marks the end of the array in C.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst c = @cImport({\n    @cInclude(\"user.h\");\n});\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    var new_user: c.User = undefined;\n    new_user.id = 1;\n    var user_name = try allocator.alloc(u8, 12);\n    defer allocator.free(user_name);\n    @memcpy(user_name[0..(user_name.len - 1)], \"pedropark99\");\n    user_name[user_name.len - 1] = 0;\n    new_user.name = user_name.ptr;\n}\n\nSo, in this example above, we are manually initializing each field of the C struct. We could say that, in this instance, we are ‚Äúmanually instantiating the C struct object‚Äù. However, when we use C libraries in our Zig code, we rarely need to manually instantiate the C structs like in the above example. Only because C libraries usually provide ‚Äúconstructor functions‚Äù in their public APIs. As consequence, we normally rely on these constructor functions to properly initialize the C structs, and the struct fields for us.\nFor example, consider the Harfbuzz C library. This a text shaping C library, and it works around a ‚Äúbuffer object‚Äù, or, more specifically, an instance of the C struct hb_buffer_t. Therefore, we need to create an instance of this C struct if we want to use this C library. Luckily, this library offers the function hb_buffer_create(), which we can use to create such object. So the Zig code necessary to create such object would probably look something like this:\nconst c = @cImport({\n    @cInclude(\"hb.h\");\n});\nvar buf: c.hb_buffer_t = c.hb_buffer_create();\n// Do stuff with the \"buffer object\"\nTherefore, we do not need to manually create an instance of the C struct hb_buffer_t here, and manually assign valid values to each field in this C struct. Because the constructor function hb_buffer_create() is doing this heavy job for us.\nSince this buf object (and also the new_user object) is an instance of a C struct, this object is, in itself, a C compatible value. It is a C object defined in our Zig code. As consequence, you can freely pass this object as input to any C function that expects to receive this type of C struct as input. You do not need to use any special syntax, or, to convert this object in any special manner to use it in C code. This is how we create and use C objects in our Zig code.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html#sec-pass-c-structs",
    "href": "Chapters/14-zig-c-interop.html#sec-pass-c-structs",
    "title": "14¬† Zig interoperability with C",
    "section": "14.5 Passing C structs across Zig functions",
    "text": "14.5 Passing C structs across Zig functions\nNow that we have learned how to create/declare C objects in our Zig code, we need to learn how to pass these C objects as inputs to Zig functions. As I described at Section 14.4, we can freely pass these C objects as inputs to C code that we call from our Zig code. But what about passing these C objects as inputs to Zig functions?\nIn essence, this specific case requires one small adjustment in the Zig function declaration. All you need to do, is to make sure that you pass your C object by reference to the function, instead of passing it by value. To do that, you have to annotate the data type of the function argument that is receiving this C object as ‚Äúa pointer to the C struct‚Äù, instead of annotating it as ‚Äúan instance of the C struct‚Äù.\nLet‚Äôs consider the C struct User from the user.h C header file that we have used at Section 14.4. Now, consider that we want to create a Zig function that sets the value of the id field in this C struct, like the set_user_id() function declared below. Notice that the user argument in this function is annotated as a pointer (*) to a c.User object.\nTherefore, essentially, all you have to do when passing C objects to Zig functions, is to add * to the data type of the function argument that is receiving the C object. This will make sure that the C object is passed by reference to the function.\nNow, because we have transformed the function argument into a pointer, everytime that you have to access the value pointed by the input pointer inside the function body, for whatever reason (e.g.¬†you want to read, update, or delete this value), you have to dereference the pointer with the .* syntax that we learned from Chapter 6. Notice that the set_user_id() function is using this syntax to alter the value in the id field of the User struct pointed by the input pointer.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst c = @cImport({\n    @cInclude(\"user.h\");\n});\nfn set_user_id(id: u64, user: *c.User) void {\n    user.*.id = id;\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    var new_user: c.User = undefined;\n    new_user.id = 1;\n    var user_name = try allocator.alloc(u8, 12);\n    defer allocator.free(user_name);\n    @memcpy(user_name[0..(user_name.len - 1)], \"pedropark99\");\n    user_name[user_name.len - 1] = 0;\n    new_user.name = user_name.ptr;\n\n    set_user_id(25, &new_user);\n    try stdout.print(\"New ID: {any}\\n\", .{new_user.id});\n}\n\nNew ID: 25",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/14-zig-c-interop.html#footnotes",
    "href": "Chapters/14-zig-c-interop.html#footnotes",
    "title": "14¬† Zig interoperability with C",
    "section": "",
    "text": "https://cplusplus.com/reference/cstdio/printf/‚Ü©Ô∏é\nhttps://en.cppreference.com/w/c/numeric/math/pow‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Zig interoperability with C</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html",
    "href": "Chapters/13-image-filter.html",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "",
    "text": "15.1 How we see things?\nIn this section, I want to briefly describe to you how we (humans) actually see things with our own eyes. I mean, how our eyes work? If you do have a very basic understanding of how our eyes work, you will understand more easily how digital images are made. Because the techniques used to produce a digital image were developed by taking a lot of inspiration from how our human eyes work.\nYou can interpret a human eye as a light sensor, or, a light receptor. The eye receives some amount of light as input, and it interprets the colors that are present in this ‚Äúamount of light‚Äù. If no amount of light hits the eye, then, the eye cannot extract color from it, and as result, we end up seeing nothing, or, more precisely, we see complete blackness.\nSo everything depends on light. What we actually see are the colors (blue, red, orange, green, purple, yellow, etc.) that are being reflected from the light that is hitting our eyes. Light is the source of all colors! This is what Isaac Newton discovered on his famous prism experiment2 in the 1660s.\nInside our eyes, we have a specific type of cell called the ‚Äúcone cell‚Äù. Our eye have three different types, or, three different versions of these ‚Äúcone cells‚Äù. Each of these three types of cone cell is very sensitive to a specific spectrum of the light, which are the spectrums that define the colors red, green and blue. So, in summary, our eyes have specific types of cells that are highly sensitive to these three colors (red, green and blue).\nThese are the cells responsible for perceiving the color present in the light that hits our eyes. As a result, our eyes perceives color as a mixture of these three colors (red, green and blue). By having an amount of each one of these three colors, and mixing them together, we can get any other visible color that we want. So every color that we see is perceived as a specific mixture of blues, greens and reds, like 30% of red, plus 20% of green, plus 50% of blue.\nWhen these cone cells perceive (or, detect) the colors that are found in the light that is hitting our eyes, these cells produce electrical signals and sent them to the brain. Our brain interprets these electrical signals, and use them to form the image that we are seeing inside our head.\nBased on what we have discussed here, the items below describes the sequence of events that composes this very simplified version of how our human eyes work:",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#sec-eyes",
    "href": "Chapters/13-image-filter.html#sec-eyes",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "",
    "text": "Light hits our eyes.\nThe cone cells perceive the colors that are present in this light.\nCone cells produce electrical signals that describes the colors that were perceived in the light.\nThe electrical signals are sent to the brain.\nBrain interprets these signals, and form the image based on the colors identified by these electrical signals.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#sec-digital-img",
    "href": "Chapters/13-image-filter.html#sec-digital-img",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "15.2 How digital images work?",
    "text": "15.2 How digital images work?\nA digital image is a ‚Äúdigital representation‚Äù of an image that we see with our eyes. In other words, a digital image is a ‚Äúdigital representation‚Äù of the colors that we see and perceive through the light. In the digital world, we have two types of images, which are: vector image and raster image. Vector images are not described here. So just remember that every single aspect that we discuss here in this chapter about digital images are related solely to raster images, and not vector images.\nRaster images are digital images that are represented as a 2D (two dimensional) matrix of pixels. In other words, every raster image is basically a rectangle of pixels. Each pixel have a particular color. So, a raster image is just a rectangle of pixels, and each of these pixels are displayed in the screen of your computer (or the screen of any other device, e.g.¬†laptop, tablet, smartphone, etc.) as a color.\nFigure¬†15.3 demonstrates this idea. If you take any raster image, and you zoom into it very hard, you will see the actual pixels of the image. Although JPEG and PNG are file formats to store raster images, when you zoom into JPEG, PNG, and some other types of raster image files, you usually do not quite see the pixels. That is because most of these file formats implement techniques that affect how the pixels are displayed, with the objective of increasing the details in the image. The most famous of these techniques is anti-aliasing, which you probably know from video-games. But nevertheless, the pixels are still there! They are just displayed differently in JPEG/PNG files.\n\n\n\n\n\n\nFigure¬†15.3: Zooming over a raster image to see the pixels. Source: Google Images.\n\n\n\nThe more pixels the image has, the more information and detail we can include in the image. The more precise, sharp and pretty will look the image. That is why photographic cameras usually produces big raster images, with several megapixels of resolution, to include as much detail as possible into the final image. As an example, a digital image with dimensions of 1920 pixels of width and 1080 pixels of height, would be a image that contains \\(1920 \\times 1080 = 2073600\\) pixels in total. You could also say that the ‚Äútotal area‚Äù of the image is of 2073600 pixels, although the concept of ‚Äúarea‚Äù is not very used here in computer graphics.\nMost digital images we see in our modern world uses the RGB color model. RGB stands for (red, green and blue) if you did not detected that yet. So the color of each pixel in these raster images are usually represented as a mixture of red, green and blue, just like in our eyes. That is, the color of each pixel is identified by a set of three different integer values. Each integer value identifies the ‚Äúamount‚Äù of each color (red, green and blue). For example, the set (199, 78, 70) identifies a color that is close to red. We have 199 of red, 78 of green, and 70 of blue. In contrast, the set (129, 77, 250) describes a color that is more close to purple. Et cetera.\n\n15.2.1 Images are displayed from top to bottom\nThis is not a rule written in stone, but the big majority of digital images are displayed from top to bottom and left to right. Most computers screens also follow this pattern. So, the first pixels in the image are the ones that are at the top and left corner of the image. You can find a visual representation of this logic at Figure¬†15.4.\nAlso notice in Figure¬†15.4 that, since a digital image is essentially a 2D matrix of pixels, the image is organized into rows and columns of pixels. The columns are defined by the horizontal x axis, while the rows are defined by the vertical y axis.\nEach pixel (i.e.¬†the gray rectangles) exposed at Figure¬†15.4 contains a number inside of it. These numbers are the indexes of the pixels. You can notice that the first pixels are in the top and left corner, and also, that the indexes of these pixels ‚Äúgrow to the sides‚Äù, or, in other words, they grow in the direction of the horizontal x axis. This means that most digital images are usually organized as rows of pixels. So when these digital images are displayed, the screen display the first row of pixels, then, the second row, then, the third row, etc.\n\n\n\n\n\n\nFigure¬†15.4: How the pixels of raster images are displayed.\n\n\n\n\n\n15.2.2 Representing the matrix of pixels in code\nOk, we know already that digital images are represented as a 2D matrix of pixels. But we do not have a notion of a 2D matrix in Zig. Most low-level languages in general (Zig, C, Rust, etc.) do not have such notion. So how do we represent such matrix of pixels in Zig, or any other low-level language. The strategy that most programmers choose is to just use a normal 1D array to store the values of this 2D matrix. In other words, you just create an normal 1D array, and store all values from both dimensions into this 1D array.\nNow, remember, a digital image is represented as a 2D matrix of pixels, and each pixel is represented by 3 unsigned 8bit-integer values. So, if we have for example a very small image of dimensions 4x3, then, we have 12 pixels in total in this image. As a result, we need to create a normal array that can store \\(3 \\times 12 = 36\\) integer values, more precisely, an array of 36 u8 values.\nThe reason why unsigned 8-bit integer (u8) values are used to represent the amounts of each color, instead of any other integer type, is because they take the minimum amount of space as possible, or, the minimum amount of bits as possible. Which helps to reduces the binary size of the image, i.e.¬†of the 2D matrix. Also, they convey a good amount of precision and detail about the colors, even though they can represent a relatively small range (from 0 to 255) of ‚Äúcolor amounts‚Äù.\nComing back to our initial example of a 4x3 image, the matrix object exposed below could be an example of an 1D array that stores the data that represents this 4x3 image.\nconst matrix = [_]u8{\n    201, 10, 25, 185, 65, 70,\n    65, 120, 110, 65, 120, 117,\n    98, 95, 12, 213, 26, 88,\n    143, 112, 65, 97, 99, 205,\n    234, 105, 56, 43, 44, 216,\n    45, 59, 243, 211, 209, 54,\n};\nThe first three integer values in this array are the color amounts of the first pixel in the image. While the next three integer are the colors amounts for the second pixel. And the sequence goes on in this pattern. So the size of the array that stores the values of the pixels from a raster image is usually a multiple of 3. In this case, the array have a size of 36.\nI mean, the size of the array is usually a multiple of 3, because in specific circumstances, it can also be a multiple of 4. This happens when a transparency amount is also included into the raster image. In other words, there are some types of raster images that follow a different color model, which is the RGBA (red, green, blue and alpha) color model. The ‚Äúalpha‚Äù corresponds to an amount of transparency in the pixel. So every pixel in a RGBA image is represented by a red, green, blue and alpha values.\nMost raster images uses the standard RGB model, so, for the most part, you will see arrays sizes that are multiples of 3. But some images, specially the ones that are stored in PNG files, might be using the RGBA model, and, therefore, are represented by an array whose size is a multiple of 4.\nIn our case here, the example image of our project (Figure¬†15.1) is a raster image stored in a PNG file, and this specific image is using the RGBA color model. So each pixel in the image is represented by 4 different integer values, and, as consequence, to store this image in our Zig code, we need to create an array whose size is a multiple of 4.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#the-png-library-we-are-going-to-use",
    "href": "Chapters/13-image-filter.html#the-png-library-we-are-going-to-use",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "15.3 The PNG library we are going to use",
    "text": "15.3 The PNG library we are going to use\nLet‚Äôs begin our project by focusing on writing the necessary Zig code to read the data from the PNG file. In other words, we want to read the PNG file exposed at Figure¬†15.1, and parse it‚Äôs data to extract the 2D matrix of pixels that represents the image.\nAs we have discussed at Section 15.2.2, the image that we are using as example here is a PNG file that uses the RGBA color model, and, threfore, each pixel of the image is represented by 4 integer values. You can download this image by visiting the ZigExamples/image_filter folder at the official repository of this book3. You can also find in this folder the complete source code of this small project that we are developing here.\nThere are some C libraries available that we can use to read and parse PNG files. The most famous and used of all is the libpng, which is the ‚Äúofficial library‚Äù for reading and writing PNG files. This C library is available in most operating system. But this C library is very known for being a little complex and hard to use.\nThat is why, I‚Äôm going to use a more modern alternative here in this project, which is the libspng library. I have choose to use this C library here, because it is much, much simpler to use than libpng, and also, offers very good performance for all operations. You can checkout the official website of the library4 to know more about it. You will also find there, some documentation that might help you to understand and follow the code examples exposed here.\nFirst of all, remember to build and install this libspng into your system. Because if you don‚Äôt do this step, the zig compiler will not find the files and resources of this library in your computer, and link them with the Zig code that we are going to write here together. There is good information about how to build and install the library at the build section of the library documentation at the official website5.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#reading-the-png-file",
    "href": "Chapters/13-image-filter.html#reading-the-png-file",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "15.4 Reading the PNG file",
    "text": "15.4 Reading the PNG file\nIn order to extract the pixel data from the PNG file, we need to read and decode the file. A PNG file is just a binary file written in the ‚ÄúPNG format‚Äù. We need to decode the file in order to extract the pixel data from it. Luckily, the libspng library offers a function called spng_decode_image() that does all this heavy work for us.\nNow, since libspng is a C library, most of the file and I/O operations in this library are made by using a FILE C pointer. Because of that, is probably a better idea to use the fopen() C function to open our PNG file, instead of using the openFile() method that I introduced at Chapter 13. That is why I‚Äôm importing the stdio.h header in this project, and using the fopen() C function to open the file.\nIf you look at the snippet below, you can see that we are:\n\nopening the PNG file with fopen().\ncreating the libspng context with spng_ctx_new().\nusing spng_set_png_file() to specify the FILE object that reads the PNG file that we are going to use.\n\nEvery operation in libspng is made through a ‚Äúcontext object‚Äù. In our snippet below, this object is ctx. Also, to perform an operation over a PNG file, we need to specify which PNG file we are referring to. This is the job of spng_set_png_file(). We are using this function to specify the file descriptor object that reads the PNG file that we want to use.\nconst c = @cImport({\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\nconst png = @cImport({\n    @cInclude(\"spng.h\");\n});\n\nconst path = \"pedro_pascal.png\";\nconst file_descriptor = c.fopen(path, \"rb\");\nif (file_descriptor == null) {\n    @panic(\"Could not open file!\");\n}\nconst ctx = png.spng_ctx_new(0) orelse unreachable;\n_ = png.spng_set_png_file(\n    ctx, @ptrCast(file_descriptor)\n);\nBefore we continue, is important to emphasize the following: since we have opened the file with fopen(), we have to remember to close the file at the end of the program, with fclose(). In other words, after we have done everything that we wanted to do with the PNG file pedro_pascal.png, we need to close the file, by applying fclose() over the file descriptor object. We could use also the defer keyword to help us in this task, if we want to. This code snippet below demonstrates this step:\nif (c.fclose(file_descriptor) != 0) {\n    return error.CouldNotCloseFileDescriptor;\n}\n\n15.4.1 Reading the image header section\nNow, the context object ctx is aware of our PNG file pedro_pascal.png, and it has access to a file descriptor object to this file, and we can start doing operations in this file. The first thing that we are going to do is to read the ‚Äúimage header section‚Äù of the PNG file. This ‚Äúimage header section‚Äù is the section of the file that contains some basic information about the PNG file, like, the bit depth of the pixel data of the image, the color model used in the file, the dimensions of the image (height and width in number of pixels), etc.\nTo make things easier, I will encapsulate this ‚Äúread image header‚Äù operation into a nice small function called get_image_header(). All that this function needs to do is to call the spng_get_ihdr() function. This function from libspng is responsible for reading the image header data, and storing it into a C struct named spng_ihdr. Thus, an object of type spng_ihdr is a C struct that contains the data from the image header section of the PNG file.\nSince this Zig function is receiving a C object (the libspng context object) as input, I marked the function argument ctx as ‚Äúa pointer to the context object‚Äù (*png.spng_ctx), following the recommendations that we have discussed at Section 14.5.\nfn get_image_header(ctx: *png.spng_ctx) !png.spng_ihdr {\n    var image_header: png.spng_ihdr = undefined;\n    if (png.spng_get_ihdr(ctx, &image_header) != 0) {\n        return error.CouldNotGetImageHeader;\n    }\n\n    return image_header;\n}\n\nvar image_header = try get_image_header(ctx);\nAlso notice in this function, that I‚Äôm checking if the spng_get_ihdr() function call have returned or not an integer value that is different than zero. Most functions from the libspng library return a code status as result, and the code status zero means ‚Äúsuccess‚Äù. So any code status that is different than zero means that an error occurred while running spng_get_ihdr(). This is why I‚Äôm returning an error value from the function in case the code status returned by the function is different than zero.\n\n\n15.4.2 Allocating space for the pixel data\nBefore we read the pixel data from the PNG file, we need to allocate enough space to hold this data. But in order to allocate such space, we first need to know how much space we need to allocate. The image dimension is obviously needed to calculate the size of this space. But there are other elements that also affect this number, such as the color model used in the image, the bit depth, and others.\nAnyway, all of this means that calculating the size of the space that we need, is not a simple task. That is why the libspng library offers a utility function named spng_decoded_image_size() to calculate this size for us. Once again, I‚Äôm going to encapsulate the logic around this function into a nice small Zig function named calc_output_size(). You can see that this function returns a nice integer value as result, informing the size of the space that we need to allocate.\nfn calc_output_size(ctx: *png.spng_ctx) !u64 {\n    var output_size: u64 = 0;\n    const status = png.spng_decoded_image_size(\n        ctx, png.SPNG_FMT_RGBA8, &output_size\n    );\n    if (status != 0) {\n        return error.CouldNotCalcOutputSize;\n    }\n    return output_size;\n}\nYou might quest yourself what the value SPNG_FMT_RGBA8 means. This value is actually an enum value defined in the spng.h header file. This enum is used to identify a ‚ÄúPNG format‚Äù. More precisely, it identifies a PNG file that uses the RGBA color model and 8 bit depth. So by providing this enum value as input to the spng_decoded_image_size() function, we are saying to this function to calculate the size of the decoded pixel data considering a PNG file that follows this ‚ÄúRGBA color model with 8 bit depth format‚Äù.\nHaving this function, we can use it in conjunction with an allocator object, to allocate an array of bytes (u8 values) that is big enough to store the decoded pixel data of the image. Notice that I‚Äôm using @memset() to properly initialize the entire array to zero.\nconst output_size = try calc_output_size(ctx);\nvar buffer = try allocator.alloc(u8, output_size);\n@memset(buffer[0..], 0);\n\n\n15.4.3 Decoding the image data\nNow that we have the necessary space to store the decoded pixel data of the image, we can start to actually decode and extract this pixel data from the image, by using the spng_decode_image() function.\nThe read_data_to_buffer() function exposed below summarises the necessary steps to read this decoded pixel data, and store it into an input buffer. Notice that this function is encapsulating the logic around the spng_decode_image() function. Also, we are using the SPNG_FMT_RGBA8 enum value once again to inform the corresponding function, that the PNG image being decoded, uses the RGBA color model and 8 bit depth.\nfn read_data_to_buffer(ctx: *png.spng_ctx, buffer: []u8) !void {\n    const status = png.spng_decode_image(\n        ctx,\n        buffer.ptr,\n        buffer.len,\n        png.SPNG_FMT_RGBA8,\n        0\n    );\n\n    if (status != 0) {\n        return error.CouldNotDecodeImage;\n    }\n}\nHaving this function at hand, we can apply it over our context object, and also, over the buffer object that we have created in the previous section to hold the decoded pixel data of the image:\ntry read_data_to_buffer(ctx, buffer[0..]);\n\n\n15.4.4 Looking at the pixel data\nNow that we have the pixel data stored in our ‚Äúbuffer object‚Äù, we can take just a quick look at the bytes. In the example below, we are looking at the first 12 bytes in the decoded pixel data.\nIf you take a close look at these values, you might notice that every 4 bytes in the sequence is 255. Which, coincidentally is the maximum possible integer value to be represented by a u8 value. So, if the range from 0 to 255, which is the range of integer values that can be represented by an u8 value, can be represented as a scale from 0% to 100%, these 255 values are essentially 100% in that scale.\nIf you recall from Section 15.2.2, I have described in that section that our pedro_pascal.png PNG file uses the RGBA color model, which adds an alpha (or transparency) byte to each pixel in the image. As consequence, each pixel in the image is represented by 4 bytes. Since we are looking here are the first 12 bytes in the image, it means that we are looking at the data of the first \\(12 / 4 = 3\\) pixels in the image.\nSo, based on how these first 12 bytes (or these 3 pixels) look, with these 255 values at every 4 bytes, we can say that is likely that every pixel in the image have alpha (or transparency) setted to 100%. This might not be true, but, is the most likely possibility. Also, if we look at the image itself, which if your recall is exposed at Figure¬†15.1, we can see that the transparency of the image does not change across the image, which enforces this theory.\ntry stdout.print(\n    \"{any}\\n\", .{buffer[0..12]}\n);\n{\n    200, 194, 216, 255, 203, 197,\n    219, 255, 206, 200, 223, 255\n}\nWe can see in the above result that the first pixel in this image have 200 of red, 194 of green, and 216 of blue. How do I know the order in which the colors appears in the sequence? If you have not guessed that yet, is because of the acronym RGB. First RED, then GREEN, then BLUE. If we scale these integer values according to our scale of 0% to 100% (0 to 255), we get 78% of red, 76% of green and 85% of blue.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#applying-the-image-filter",
    "href": "Chapters/13-image-filter.html#applying-the-image-filter",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "15.5 Applying the image filter",
    "text": "15.5 Applying the image filter\nNow that we have the data of each pixel in the image, we can focus on applying our image filter over these pixels. Remember, our objective here is to apply a grayscale filter over the image. A grayscale filter is a filter that transforms a colored image into a grayscale image.\nThere are different formulas and strategies to transform a colored image into a grayscale image. But all of these different strategies involve applying some math over the colors of each pixel. In this project, we are going to use the most general formula, which is exposed below. This formula considers \\(r\\) as the red of the pixel, \\(g\\) as the green, \\(b\\) as the blue, and \\(p'\\) as the linear luminance of the pixel.\n\\[\n    p' = (0.2126 \\times r) + (0.7152 \\times g) + (0.0722 \\times b)\n\\tag{15.1}\\]\nThis Equation¬†15.1 is the formula to calculate the linear luminance of a pixel. Is worth noting that this formula works only for images whose pixels are using the sRGB color space, which is the standard color space for the web. This means that, ideally, all images on the web should use this color space. Luckily, this is our case here, i.e.¬†the pedro_pascal.png image is using this sRGB color space, and, as consequence, we can use the Equation¬†15.1. You can read more about this at the Wikipedia page for grayscale (Wikipedia 2024).\nThe apply_image_filter() function exposed below summarises the necessary steps to apply Equation¬†15.1 over the pixels in the image. We just apply this function over our buffer object that contains our pixel data, and, as result, the pixel data stored in this buffer object should now represent the grayscale version of our image.\nfn apply_image_filter(buffer:[]u8) !void {\n    const len = buffer.len;\n    const red_factor: f16 = 0.2126;\n    const green_factor: f16 = 0.7152;\n    const blue_factor: f16 = 0.0722;\n    var index: u64 = 0;\n    while (index &lt; (len - 4)) : (index += 4) {\n        const rf: f16 = @floatFromInt(buffer[index]);\n        const gf: f16 = @floatFromInt(buffer[index + 1]);\n        const bf: f16 = @floatFromInt(buffer[index + 2]);\n        const y_linear: f16 = (\n            (rf * red_factor) + (gf * green_factor)\n            + (bf * blue_factor)\n        );\n        buffer[index] = @intFromFloat(y_linear);\n        buffer[index + 1] = @intFromFloat(y_linear);\n        buffer[index + 2] = @intFromFloat(y_linear);\n    }\n}\n\ntry apply_image_filter(buffer[0..]);",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#saving-the-grayscale-version-of-the-image",
    "href": "Chapters/13-image-filter.html#saving-the-grayscale-version-of-the-image",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "15.6 Saving the grayscale version of the image",
    "text": "15.6 Saving the grayscale version of the image\nSince we have now the grayscale version of our image stored in our buffer object, we need to encode this buffer object back into the ‚ÄúPNG format‚Äù, and save the encoded data into a new PNG file in our filesystem, so that we can access and see the grayscale version of our image that was produced by our small program.\nTo do that, the libspng library help us once again by offering an ‚Äúencode data to PNG‚Äù type of function, which is the spng_encode_image() function. But in order to ‚Äúencode data to PNG‚Äù with libspng, we need to create a new context object. This new context object must use a ‚Äúencoder context‚Äù, which is identified by the enum value SPNG_CTX_ENCODER.\nThe save_png() function exposed below, summarises all the necessary steps to save the grayscale version of our image into a new PNG file in the filesystem. By default, this function will save the grayscale image into a file named pedro_pascal_filter.png in the CWD.\nNotice in this code example that we are using the same image header object (image_header) that we have collected previously with the get_image_header() function. Remember, this image header object is a C struct (spng_ihdr) that contains basic information about our PNG file, specially the dimensions of the image, the color model used, etc.\nIf we wanted to save a very different image in this new PNG file, e.g.¬†an image with different dimensions, or, an image that uses a different color model, a different bit depth, etc. we would need to create a new image header (spng_ihdr) object that describes the properties of this new image.\nBut we are essentially saving the same image that we have begin with here (the dimensions of the image, the color model, etc. are all still the same). The only difference between the two images are the colors of the pixels, which are now shades of gray. As consequence, we can safely use the exact same image header data in this new PNG file.\nfn save_png(image_header: *png.spng_ihdr, buffer: []u8) !void {\n    const path = \"pedro_pascal_filter.png\";\n    const file_descriptor = c.fopen(path.ptr, \"wb\");\n    if (file_descriptor == null) {\n        return error.CouldNotOpenFile;\n    }\n    const ctx = (\n        png.spng_ctx_new(png.SPNG_CTX_ENCODER)\n        orelse unreachable\n    );\n    defer png.spng_ctx_free(ctx);\n    _ = png.spng_set_png_file(ctx, @ptrCast(file_descriptor));\n    _ = png.spng_set_ihdr(ctx, image_header);\n\n    const encode_status = png.spng_encode_image(\n        ctx,\n        buffer.ptr,\n        buffer.len,\n        png.SPNG_FMT_PNG,\n        png.SPNG_ENCODE_FINALIZE\n    );\n    if (encode_status != 0) {\n        return error.CouldNotEncodeImage;\n    }\n    if (c.fclose(file_descriptor) != 0) {\n        return error.CouldNotCloseFileDescriptor;\n    }\n}\n\ntry save_png(&image_header, buffer[0..]);\nAfter we execute this save_png() function, we should have a new PNG file inside our CWD, named pedro_pascal_filter.png. If we open this PNG file, we will see the same image exposed at Figure¬†15.2.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#building-our-project",
    "href": "Chapters/13-image-filter.html#building-our-project",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "15.7 Building our project",
    "text": "15.7 Building our project\nNow that we have written the code, let‚Äôs discuss how can we build/compile this project. To do that, I‚Äôm going to create a build.zig file in the root directory of our project, and start writing the necessary code to compile the project, using the knowledge that we have acquired from Chapter 9.\nWe first create the build target for our executable file, that executes our Zig code. Let‚Äôs suppose that all of our Zig code was written into a Zig module named image_filter.zig, then, the exe object described in the build script below describes the build target for our executable file.\nSince we have used C code from the libspng library in our Zig code, we need to link our Zig code (which is in the exe build target) to both the C Standard Library, and, to the libspng library. We do that, by calling the linkLibC() and linkSystemLibrary() methods from our exe build target.\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n    const exe = b.addExecutable(.{\n        .name = \"image_filter\",\n        .root_source_file = b.path(\"src/image_filter.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.linkLibC();\n    // Link to spng library:\n    exe.linkSystemLibrary(\"spng\");\n    b.installArtifact(exe);\n}\nBecause we are using the linkSystemLibrary() method, it means that the library files for libspng are searched in your system to be linked with the exe build target. If you have not yet built and installed the libspng library into your system, this linkage step will likely not work. Because it will not find the library files.\nSo, just remember to install libspng in your system, if you want to build this project. Having this build script above written, we can finally build our project by running the zig build command in the terminal.\n\n\n\n\nWikipedia. 2024. ‚ÄúGrayscale.‚Äù Wikipedia. https://en.wikipedia.org/wiki/Grayscale.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/13-image-filter.html#footnotes",
    "href": "Chapters/13-image-filter.html#footnotes",
    "title": "15¬† Project 4 - Developing an image filter",
    "section": "",
    "text": "https://github.com/pedropark99/zig-book/tree/main/ZigExamples/image_filter‚Ü©Ô∏é\nhttps://library.si.edu/exhibition/color-in-a-new-light/science‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/tree/main/ZigExamples/image_filter‚Ü©Ô∏é\nhttps://libspng.org/‚Ü©Ô∏é\nhttps://libspng.org/docs/build/‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Project 4 - Developing an image filter</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html",
    "href": "Chapters/14-threads.html",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "",
    "text": "16.1 What are threads?\nA thread is basically a separate context of execution. We use threads to introduce parallelism into our program, which in most cases, makes the program runs faster, because we have multiple tasks being performed at the same time, parallel to each other.\nPrograms are normally single-threaded by default. Which means that each program usually runs on a single thread, or, a single context of execution. When we have only one thread running, we have no parallelism. And when we don‚Äôt have parallelism, the commands are executed sequentially, that is, only one command is executed at a time, one after another. By creating multiple threads inside our program, we start to execute multiple commands at the same time.\nPrograms that create multiple threads are very commom on the wild. Because many different types of applications are well suited for parallelism. Good examples are video and photo-editing applications (e.g.¬†Adobe Photoshop or DaVinci Resolve) , games (e.g.¬†The Witcher 3), and also web browsers (e.g.¬†Google Chrome, Firefox, Microsoft Edge, etc). For example, in web browsers, threads are normally used to implement tabs. In other words, the tabs in a web browsers usually run as separate threads in the main process of the web browser. That is, each new tab that you open in your web browser, usually runs on a separate thread of execution.\nBy running each tab in a separate thread, we allow all open tabs in the browser to run at the same time, and independently from each other. For example, you might have YouTube, or Spotify, currently opened in a tab, and you are listening to some podcast in that tab, while, at the same time, you are working in another tab, writing an essay on Google Docs. Even if you are not looking into the YouTube tab, you can still hear the podcast only because this YouTube tab is running in parallel with the other tab where Google Docs is running.\nWithout threads, the other alternative would be to run each tab as a completely separate running process in your computer. But that would be a bad choice, because just a few tabs would already consume too much power and resources from your computer. In other words, is very expensive to create a completely new process, compared to creating a new thread of execution. Also, the chances of you experiencing lag and overhead while using the browser would be significant. Threads are faster to create, and they also consume much, much less resources from the computer, specially because they share some resources with the main process.\nTherefore, is the use of threads in modern web browsers that allows you to hear the podcast at the same time while you are writing something on Google Docs. Without threads, a web browser would probably be limited to just one single tab.\nThreads are also well-suited for anything that involves serving requests or orders. Because serving a request takes time, and usually involves a lot of ‚Äúwaiting time‚Äù. In other words, we spend a lot of time in idle, waiting for something to complete. For example, consider a restaurant. Serving orders in a restaurant usually involves the following steps:\nIf you think about the bulletpoints above, you will notice that one big moment of waiting is present in this hole process, which is while the food is being prepared and cooked inside the kitchen. Because while the food is being prepped, both the waiter and the client itself are waiting for the food to be ready and delivered.\nIf we write a program to represent this restaurant, more specifically, a single-threaded program, then, this program would be very inefficient. Because the program would stay in idle, waiting for a considerable amount of time on the ‚Äúcheck if food is ready‚Äù step. Consider the code snippet exposed below that could potentially represent such program.\nThe problem with this program is the while loop. This program will spend a lot of time waiting on the while loop, doing nothing more than just checking if the food is ready. This is a waste of time. Instead of waiting for something to happen, the waiter could just send the order to the kitchen, and just move on, and continue with receiving more orders from other clients, and sending more orders to the kitchen, insteading of doing nothing and waiting for the food to be ready.\nThis is why threads would be a great fit for this program. We could use threads to free the waiters from their ‚Äúwaiting duties‚Äù, so they can go on with their other tasks, and receive more orders. Take a look at the next example, where I have re-written the above program into a different program that uses threads to cook and deliver the orders.\nYou can see in this program that when a waiter receives a new order from a client, this waiter executes the send_order() function. The only thing that this function does is: it creates a new thread and detaches it. Since creating a thread is a very fast operation, this send_order() function returns almost immediatly, so the waiter spends almost no time worring about the order, and just move on and tries to get the next order from the clients.\nInside the new thread created, the order get‚Äôs cooked by a chef, and when the food is ready, it is delivered to the client‚Äôs table.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#sec-what-thread",
    "href": "Chapters/14-threads.html#sec-what-thread",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "",
    "text": "receive order from the client.\npass the order to the kitchen, and wait for the food to be cooked.\nstart cooking the food in the kitchen.\nwhen the food is fully cooked deliver this food to the client.\n\n\n\n\nconst order = Order.init(\"Pizza Margherita\", n = 1);\nconst waiter = Waiter.init();\nwaiter.receive_order(order);\nwaiter.ask_kitchen_to_cook();\nvar food_not_ready = false;\nwhile (food_not_ready) {\n    food_not_ready = waiter.is_food_ready();\n}\nconst food = waiter.get_food_from_kitchen();\nwaiter.send_food_to_client(food);\n\n\n\nfn cook_and_deliver_order(order: *Order) void {\n    const chef = Chef.init();\n    const food = chef.cook(order.*);\n    chef.deliver_food(food);\n}\nfn send_order(order: Order) void {\n    const cook_thread = Thread.spawn(\n        .{}, cook_and_deliver_order, .{&order}\n    );\n    cook_thread.detach();\n}\n\nconst waiter = Waiter.init();\nwhile (true) {\n    const order = waiter.get_new_order();\n    if (order) {\n        send_order(order);\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#threads-versus-processes",
    "href": "Chapters/14-threads.html#threads-versus-processes",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.2 Threads versus processes",
    "text": "16.2 Threads versus processes\nWhen we run a program, this program is executed as a process in the operating system. This is a one to one relationship, each program or application that you execute is a separate process in the operating system. But each program, or each process, can create and contain multiple threads inside of it. Therefore, processes and threads have a one to many relationship.\nThis also means that every thread that we create is always associated with a particular process in our computer. In other words, a thread is always a subset (or a children) of an existing process. All threads share some of the resources associated with the process from which they were created. And because threads share resources with the process, they are very good for making communication between tasks easier.\nFor example, suppose that you were developing a big and complex application that would be much simpler if you could split it in two, and make these two separate pieces talk with each other. Some programmers opt to effectively write these two pieces of the codebase as two completely separate programs, and then, they use IPC (inter-process communication) to make these two separate programs/processes talk to each other, and make them work together.\nHowever, some programmers find IPC hard to deal with, and, as consequence, they prefer to write one piece of the codebase as the ‚Äúmain part of the program‚Äù, or, as the part of the code that runs as the process in the operating system, while the other piece of the codebase is written as a task to be executed in a new thread. A process and a thread can easily comunicate with each other through both control flow, and also, through data, because they share and have access to the same standard file descriptors (stdout, stdin, stderr) and also to the same memory space on the heap and global data section.\nIn more details, each thread that you create have a separate stack frame reserved just for that thread, which essentially means that each local object that you create inside this thread, is local to that thread, i.e.¬†the other threads cannot see this local object. Unless this object that you have created is an object that lives on the heap. In other words, if the memory associated with this object is on the heap, then, the other threads can potentially access this object.\nTherefore, objects that are stored in the stack are local to the thread where they were created. But objects that are stored on the heap are potentially accessible to other threads. All of this means that, each thread have it‚Äôs own separate stack frame, but, at the same time, all threads share the same heap, the same standard file descriptors (which means that they share the same stdout, stdin, stderr), and the same global data section in the program.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#creating-a-thread",
    "href": "Chapters/14-threads.html#creating-a-thread",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.3 Creating a thread",
    "text": "16.3 Creating a thread\nWe create new threads in Zig, by first, importing the Thread struct into our current Zig module, and then, calling the spawn() method of this struct, which creates (or, ‚Äúspawns‚Äù) a new thread of execution from our current process. This method have three arguments, which are, respectively:\n\na SpawnConfig object, which contains configurations for the spawn process.\nthe name of the function that is going to be executed (or, that is going to be ‚Äúcalled‚Äù) inside this new thread.\na list of arguments (or inputs) to be passed to the function provided in the second argument.\n\nWith these three arguments, you can control how the thread get‚Äôs created, and also, specify which work (or ‚Äútasks‚Äù) will be performed inside this new thread. A thread is just a separate context of execution, and we usually create new threads in our code, because we want to perform some work inside this new context of execution. And we specify which exact work, or, which exact steps that are going to be performed inside this context, by providing the name of a function on the second argument of the spawn() method.\nThus, when this new thread get‚Äôs created, this function that you provided as input to the spawn() method get‚Äôs called, or, get‚Äôs executed inside this new thread. You can control the arguments, or, the inputs that are passed to this function when it get‚Äôs called, by providing a list of arguments (or a list of inputs) on the third argument of the spawn() method. These arguments are passed to the function in the same order that they are provided to spawn().\nFurthermore, the SpawnConfig is a struct object with only two possible fields, or, two possible members, that you can set to tailor the spawn behaviour. These fields are:\n\nstack_size: you can provide an usize value to specify the size (in bytes) of the thread‚Äôs stack frame. By default, this value is: \\(16 \\times 1024 \\times 1024\\).\nallocator: you can provide an allocator object to be used when allocating memory for the thread.\n\nTo use one of these two fields (or, ‚Äúconfigs‚Äù) you just have to create a new object of type SpawnConfig, and provide this object as input to the spawn() method. But, if you are not interested in using one of these configs, and you are ok with using just the defaults, you can just provide an anonymous struct literal (.{}) in the place of this SpawnConfig argument.\nAs our first, and very simple example, consider the code exposed below. Inside the same program, you can create multiple threads of execution if you want to. But, in this first example, we are creating just a single thread of execution, because we call spawn() only once.\nAlso, notice in this example that we are executing the function do_some_work() inside the new thread. Since this function receives no inputs, because it has no arguments, in this instance, we have passed an empty list, or, more precisely, an empty and anonymous struct (.{}) in the third argument of spawn().\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Thread = std.Thread;\nfn do_some_work() !void {\n    _ = try stdout.write(\"Starting the work.\\n\");\n    std.time.sleep(100 * std.time.ns_per_ms);\n    _ = try stdout.write(\"Finishing the work.\\n\");\n}\n\npub fn main() !void {\n    const thread = try Thread.spawn(.{}, do_some_work, .{});\n    thread.join();\n}\n\nStarting the work.Finishing the work.\n\n\nNotice the use of try when calling the spawn() method. This means that this method can return an error in some circunstances. One circunstance in particular is when you attempt to create a new thread, when you have already created too much (i.e.¬†you have excedeed the quota of concurrent threads in your system).\nBut, if the new thread is succesfully created, the spawn() method returns a handler object (which is just an object of type Thread) to this new thread. You can use this handler object to effectively control all aspects of the thread.\nThe instant that you create the new thread, the function that you provided as input to spawn() get‚Äôs invoked (i.e.¬†get‚Äôs called) to start the execution on this new thread. In other words, everytime you call spawn(), not only a new thread get‚Äôs created, but also, the ‚Äústart work button‚Äù of this thread get‚Äôs automatically pressed. So the work being performed in this thread starts at the moment that the thread is created. This is similar to how pthread_create() from the pthreads library in C works, which also starts the execution at the moment that the thread get‚Äôs created.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#returning-from-a-thread",
    "href": "Chapters/14-threads.html#returning-from-a-thread",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.4 Returning from a thread",
    "text": "16.4 Returning from a thread\nWe have learned on the previous section that the execution of the thread starts at the moment that the thread get‚Äôs created. Now, we will learn how to ‚Äújoin‚Äù or ‚Äúdetach‚Äù a thread in Zig. ‚ÄúJoin‚Äù and ‚Äúdetach‚Äù are operations that control how the thread returns to the main thread, or, to the main process in our program.\nWe perform these operations by using the methods join() and detach() from the thread handler object. Every thread that you create can be marked as either joinable or detached (Linux man-pages 2024). You can turn a thread into a detached thread by calling the detach() method from the thread handler object. But if you call the join() method instead, then, this thread becomes a joinable thread.\nA thread cannot be both joinable and detached. Which in general means that you cannot call both join() and detach() on the same thread. But a thread must be one of the two, meaning that, you should always call either join() or detach() over a thread. If you don‚Äôt call one of these two methods over your thread, you introduce undefined behaviour into your program, which is described at Section 16.8.1.\nNow, let‚Äôs describe what each of these two methods do to your thread.\n\n16.4.1 Joining a thread\nWhen you join a thread, you are essentially saying: ‚ÄúHey! Could you please wait for the thread to finish, before you continue with your execution?‚Äù. For example, if we comeback to our first and simpliest example of a thread in Zig, in that example we have created a single thread inside the main() function of our program, and just called join() over this thread at the end. This section of the code example is reproduced below.\nBecause we are joining this new thread inside the main()‚Äôs scope, it means that the execution of the main() function is temporarily stopped, to wait for the execution of the thread to finish. That is, the execution of main() stops temporarily at the line where join() get‚Äôs called, and it will continue only after the thread has finished it‚Äôs tasks.\n\npub fn main() !void {\n    const thread = try Thread.spawn(.{}, do_some_work, .{});\n    thread.join();\n}\n\nBecause we have joined this new thread inside main(), by calling join(), we have a garantee that this new thread will finish before the end of the execution of main(). Because it is garanteed that main() will wait for the thread to finish it‚Äôs tasks. You could also interpret this as: the execution of main will hang at the line where join() is called, and the next lines of code that come after this join() call, will be executed solely after the execution of main is ‚Äúunlocked‚Äù after the thread finish it‚Äôs tasks.\nIn the example above, there is no more expressions after the join() call. We just have the end of the main()‚Äôs scope, and, therefore after the thread finish it‚Äôs tasks, the execution of our program just ends, since there is nothing more to do. But what if we had more stuff to do after the join call?\nTo demonstrate this other possibility, consider the next example exposed below. Here, we create a print_id() function, that just receives an id as input, and prints it to stdout. In this example, we are creating two new threads, one after another. Then, we join the first thread, then, we wait for two hole seconds, then, at last, we join the second thread.\nThe idea behind this example is that the last join() call is executed only after the first thread finish it‚Äôs task (i.e.¬†the first join() call), and also, after the two seconds of delay. If you compile and run this example, you will notice that most messages are quickly printed to stdout, i.e.¬†they appear almost instantly on your screen. However, the last message (‚ÄúJoining thread 2‚Äù) takes aroung 2 seconds to appear in the screen.\nfn print_id(id: *const u8) !void {\n    try stdout.print(\"Thread ID: {d}\\n\", .{id.*});\n}\n\npub fn main() !void {\n    const id1: u8 = 1;\n    const id2: u8 = 2;\n    const thread1 = try Thread.spawn(.{}, print_id, .{&id1});\n    const thread2 = try Thread.spawn(.{}, print_id, .{&id2});\n\n    _ = try stdout.write(\"Joining thread 1\\n\");\n    thread1.join();\n    std.time.sleep(2 * std.time.ns_per_s);\n    _ = try stdout.write(\"Joining thread 2\\n\");\n    thread2.join();\n}\nThread ID: Joining thread 1\n1\nThread ID: 2\nJoining thread 2\nThis demonstrates that both threads finish their work (i.e.¬†printing the IDs) very fast, before the two seconds of delay end. Because of that, the last join() call returns pretty much instantly. Because when this last join() call happens, the second thread have already finished it‚Äôs task.\nNow, if you compile and run this example, you will also notice that, in some cases, the messages get intertwined with each other. In other words, you might see the message ‚ÄúJoining thread 1‚Äù inserted in the middle of the message ‚ÄúThread 1‚Äù, or vice-versa. This happens because:\n\nthe threads are executing basically at the same time as the main process of the program (i.e.¬†the main() function).\nthe threads share the same stdout from the main process of the program, which means that the messages that the threads produce are sent to exact same place as the messages produced by the main process.\n\nBoth of these points were described previously at Section 16.1. So the messages might get intertwined because they are being produced and sent to the same stdout roughly at the same time. Anyway, when you call join() over a thread, the current process will wait for the thread to finish before it continues, and, when the thread does finishs it‚Äôs task, the resources associated with this thread are automatically freed, and, the current process continues with it‚Äôs execution.\n\n\n16.4.2 Detaching a thread\nWhen you detach a thread, by calling the detach() method, the thread is marked as detached. When a detached thread terminates, its resources are automatically released back to the system without the need for another thread to join with this terminated thread.\nIn other words, when you call detach() over a thread is like when your children becomes adults, i.e.¬†they become independent from you. A detached thread frees itself, and it does need to report the results back to you, when the thread finishs it‚Äôs task. Thus, you normally mark a thread as detached when you don‚Äôt need to use the return value of the thread, or, when you don‚Äôt care about when exactly the thread finishs it‚Äôs job, i.e.¬†the thread solves everything by itself.\nTake the code example below. We create a new thread, detach it, and then, we just print a final message before we end our program. We use the same print_id() function that we have used over the previous examples.\nfn print_id(id: *const u8) !void {\n    try stdout.print(\"Thread ID: {d}\\n\", .{id.*});\n}\n\npub fn main() !void {\n    const id1: u8 = 1;\n    const thread1 = try Thread.spawn(.{}, print_id, .{&id1});\n    thread1.detach();\n    _ = try stdout.write(\"Finish main\\n\");\n}\nFinish main\nNow, if you look closely at the output of this code example, you will notice that only the final message in main was printed to the console. The message that was supposed to be printed by print_id() did not appear in the console. Why? Is because the main process of our program has finished first, before the thread was able to say anything.\nAnd that is perfectly ok behaviour, because the thread was detached, so, it was able to free itself, without the need of the main process. If you ask main to sleep (or ‚Äúwait‚Äù) for some extra nanoseconds, before it ends, you will likely see the message printed by print_id(), because you give enough time for the thread to finish before the main process ends.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#introducing-thread-pools",
    "href": "Chapters/14-threads.html#introducing-thread-pools",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.5 Introducing thread pools",
    "text": "16.5 Introducing thread pools\nThread pools is a very popular programming pattern, which is used specially on servers and daemons processes. A thread pool is just a set of threads, or, a ‚Äúpool‚Äù of threads. Many programmers like to use this pattern, because it makes easier to manage and use multiple threads, instead of manually creating the threads when you need them.\nAlso, using thread pools might increase performance as well in your program, especially if your program is constantly creating threads to perform short-lived tasks. In such instance, a thread pool might cause an increase in performance because you do not have be constantly creating and destroying threads all the time, so you don‚Äôt face a lot of the overhead involved in this constant process of creating and destroying threads.\nThe main idea behind a thread pool is to have a set of threads already created and ready to perform tasks at all times. You create a set of threads at the moment that your program starts, and keep these threads alive while your program runs. Each of these threads will be either performing a task, or, waiting for a task to be assigned. Every time a new task emerges in your program, this task is added to a ‚Äúqueue of tasks‚Äù. The moment that a thread becomes available and ready to perform a new task, this thread takes the next task in the ‚Äúqueue of tasks‚Äù, then, it simply performs the task.\nThe Zig Standard Library offers a thread pool implementation on the std.Thread.Pool struct. You create a new instance of a Pool object by providing a Pool.Options object as input to the init() method of this struct. A Pool.Options object, is a struct object that contains configurations for the pool of threads. The most important settings in this struct object are the members n_jobs and allocator. As the name suggests, the member allocator should receive an allocator object, while the member n_jobs specifies the number of threads to be created and maintained in this pool.\nConsider the example exposed below, that demonstrates how can we create a new thread pool object. Here, we create a Pool.Options object that contains a general purpose allocator object, and also, the n_jobs member was set to 4, which means that the thread pool will create and use 4 threads.\nAlso notice that the pool object was initially set to undefined. This allow us to initially declare the thread pool object, but not properly instantiate the underlying memory of the object. You have to initially declare your thread pool object by using undefined like this, because the init() method of Pool needs to have an initial pointer to properly instantiate the object.\nSo, just remember to create your thread pool object by using undefined, and then, after that, you call the init() method over the object. You should also not forget to call the deinit() method over the thread pool object, once you are done with it, to release the resources allocated for the thread pool. Otherwise, you will have a memory leak in your program.\n\nconst std = @import(\"std\");\nconst Pool = std.Thread.Pool;\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const opt = Pool.Options{\n        .n_jobs = 4,\n        .allocator = allocator,\n    };\n    var pool: Pool = undefined;\n    _ = try pool.init(opt);\n    defer pool.deinit();\n}\n\nNow that we know how to create Pool objects, we have to understand how to assign tasks to be executed by the threads in this pool object. To assign a task to be performed by a thread, we need to call the spawn() method from the thread pool object.\nThis spawn() method works identical to the spawn() method from the Thread object. The method have almost the same arguments as the previous one, more precisely, we don‚Äôt have to provide a SpawnConfig object in this case. But instead of creating a new thread, this spawn() method from the thread pool object just register a new task in the internal ‚Äúqueue of tasks‚Äù to be performed, and any available thread in the pool will get this task, and it will simply perform the task.\nIn the example below, we are using our previous print_id() function once again. But you may notice that the print_id() function is a little different this time, because now we are using catch instead of try in the print() call. Currently, the Pool struct only supports functions that don‚Äôt return errors as tasks. Thus, when assigining tasks to threads in a thread pool, is essential to use functions that don‚Äôt return errors. That is why we are using catch here, so that the print_id() function don‚Äôt return an error.\n\nfn print_id(id: *const u8) void {\n    _ = stdout.print(\"Thread ID: {d}\\n\", .{id.*})\n        catch void;\n}\nconst id1: u8 = 1;\nconst id2: u8 = 2;\ntry pool.spawn(print_id, .{&id1});\ntry pool.spawn(print_id, .{&id2});\n\nThis limitation should probably not exist, and, in fact, it is already on the radar of the Zig team to fix this issue, and it is being tracked on an open issue1. So, if you do need to provide a function that might return an error as the task to be performed by the threads in the thread pool, then, you are either limited to:\n\nimplementing your own thread pool that does not have this limitation.\nwait for the Zig team to actually fix this issue.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#introducing-mutexes",
    "href": "Chapters/14-threads.html#introducing-mutexes",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.6 Introducing mutexes",
    "text": "16.6 Introducing mutexes\nMutexes are a classic component of every thread library. In essence, a mutex is a Mutually Exclusive Flag, and this flag acts like a type of ‚Äúlock‚Äù, or as a gate keeper to a particular section of your code. Mutexes are related to thread syncronization, more specifically, they prevent you from having some classic race conditions in your program, and, therefore, major bugs and undefined behaviour that are usually difficult to track and understand.\nThe main idea behind a mutex is to help us to control the execution of a particular section of the code, and to prevent two or more threads from executing this particular section of the code at the same time. Many programmers like to compare a mutex to a bathroom door (which usually have a lock). When a thread uses the mutex to lock the data, it is like if the bathroom door was locked, and, therefore, the other people (in this case, the other threads) that wants to use the same bathroom at the same time have to be patient, and simply wait for the door to be unlocked.\nSome other programmers also like to explain mutexes by using the analogy of ‚Äúeach person will have their turn to speak‚Äù. This is the analogy used on the Multithreading Code video from the Computherfile project2. Imagine if you are in a conversation circle. There is a moderator in this circle, which is the person that decides who have the right to speak at that particular moment. The moderator gives a green card to the person that is going to speak, and, as a result, everyone else must be silent and hear this person that has the green card. When the person finishs talking, it gives the green card back to the moderator, and the moderator decides who is going to talk next, and delivers the green card to that person. And the cycle goes on like this.\nA mutex acts like the moderator in this conversation circle. The mutex authorizes one single thread to execute a specific section of the code, and it also blocks the other threads from executing this same section of the code. If these other threads wants to execute this same piece of the code, they are forced to wait for the the authorized thread to finish first. When the authorized thread finishs executing this code, the mutex authorizes the next thread to execute this code, and the other threads are still blocked. Therefore, a mutex is a moderator that does a ‚Äúeach thread will have their turn to execute this section of the code‚Äù type of control.\nMutexes are specially used to prevent against data race problems, which happens when two or more threads are trying to read from or write to the same shared object at the same time. So, when you have an object that is shared will all threads, and, you want to avoid two or more threads from accessing this same object at the same time, you can use a mutex to lock this specific object. When a thread tries to access an object that is locked by a mutex, this thread stops it‚Äôs execution, and patiently waits for the object to be unlocked to continue.\nIn other words, the execution of the thread is paused while the object is locked by the mutex, and it is unpaused the moment that the object is unlocked by the other thread that was using this object. Notice that mutexes are used in objects that are shared with all threads. So mutexes are not used on objects that are local to the thread, only in objects that are either stored in the global data section, or, in the heap space of your program.\n\n16.6.1 Critical section\nCritical section is a concept commonly associated with mutexes and thread syncronization. In essence, a critical section is the section of the program that a thread access a shared resource (i.e.¬†an object, a file descriptor, something that all threads have access to). In other words, a critical section is the section of the program where race conditions might happen, and, therefor, where undefined behaviour can be introduced into the program.\nWhen we use mutexes in our program, we want to lock the shared resource at the beginning of the critical section, and then, unlock it at the end of the critical section. The two bulletpoints exposed below comes from the ‚ÄúCritical Section‚Äù article from GeekFromGeeks, and they summarise well the role that a critical section plays in the thread syncronization problem (Geeks for Geeks 2024).\n\nThe critical section must be executed as an atomic operation, which means that once one thread or process has entered the critical section, all other threads or processes must wait until the executing thread or process exits the critical section. The purpose of synchronization mechanisms is to ensure that only one thread or process can execute the critical section at a time.\nThe concept of a critical section is central to synchronization in computer systems, as it is necessary to ensure that multiple threads or processes can execute concurrently without interfering with each other. Various synchronization mechanisms such as semaphores, mutexes, monitors, and condition variables are used to implement critical sections and ensure that shared resources are accessed in a mutually exclusive manner.\n\n\n\n16.6.2 Atomic operations\nYou will also see the term ‚Äúatomic operation‚Äù a lot when reading about threads, race conditions and mutexes. In summary, an operation is categorized as ‚Äúatomic‚Äù, when there is no way to happen a context switch in the middle of this operation. In other words, this operation is always done from beginning to end, without interruptions, i.e.¬†the operation executes without the interruption of another process or operation in the middle of it‚Äôs execution phase.\nNot many operations today are atomic. But why atomic operations matters here? Is because data races (which is a type of a race condition) cannot happen on operations that are atomic. So if a particular line in your code performs an atomic operation, then, this line will never suffer from a data race problem. Therefore, programmers sometimes use an atomic operation to avoid data race problems in their code.\nWhen you have an operation that is compiled into just one single assembly instruction, this operation might be atomic because is just one assembly instruction. This is usually true for old CPU architectures (such as x86). But nowadays, most assembly instructions in modern CPU architectures turn into multiple micro-tasks, which inherently makes the operation not atomic anymore, even though it has just one single assembly instruction.\nThe Zig Standard Library offers some atomic operations on the std.atomic module. In this module, we have a public generic function called Value(). With this function we can create an ‚Äúatomic value‚Äù, which is a value that contains native atomic operations, most notably, a load() and a fetchAdd() atomic operations. Is important to emphasize that only primitive data types (i.e.¬†the types presented at Section 1.5) are supported by these atomic operations.\n\n\n16.6.3 Data races and race conditions\nTo understand why mutexes are used, we need to understand better the problem that they seek to solve, which can be summarized into data races problems. A data race problem is a type of a race condition, which happens when one thread is accessing a particular memory location (i.e.¬†a particular shared object) at the same time that another thread is trying to write/save new data into this same memory location (i.e.¬†the same shared object).\nWe can simply define a race condition as any type of bug in your program that is based on a ‚Äúwho get‚Äôs there first‚Äù problem. A data race problem is a type of a race condition, because it occurs when two or more parties are trying to read and write into the same memory location at the same time, and, therefore, the end result of this operation depends completely on who get‚Äôs to this memory location first. As consequence, a program that have a data race problem will likely produce a different result each time that we execute it.\nThus, race conditions produce unefined behaviour and unpredictability because the program produces a different a different answer in each time that a different person get‚Äôs to the target location first than the others. And we have no easy way to either predict or control who is going to get to this target location first. In other words, in each execution of your program, you get a different answer, because a different person, or, a different function, or, a different part of the code is finishing its tasks (or it is reaching a location) first than the others.\nAs an example, consider the code snippet exposed below. In this example, we create a global counter variable, and we also create a increment() function, whose job is to just increment this global counter variable in a for loop.\nSince the for loop iterates 1 hundred thousand times, and, we create two separate threads in this code example, what number do you expect to see in the final message printed to stdout? The answer should be 2 hundred thousand. Right? Well, in threory, this program was supposed to print 2 hundred thousand at the end, but in practice, every time that I execute this program I get a different answer.\nIn the example exposed below, you can see that this time we have executed the program, the end result was 117254, instead of the expected 200000. The second time I have executed this program, I got the number 108592 as result. So the end result of this program is varying, but it never gets to the expected 200000 that we want.\n\n// Global counter variable\nvar counter: usize = 0;\n// Function to increment the counter\nfn increment() void {\n    for (0..100000) |_| {\n        counter += 1;\n    }\n}\n\npub fn main() !void {\n    const thr1 = try Thread.spawn(.{}, increment, .{});\n    const thr2 = try Thread.spawn(.{}, increment, .{});\n    thr1.join();\n    thr2.join();\n    try stdout.print(\"Couter value: {d}\\n\", .{counter});\n}\n\nCouter value: 117254\nWhy this is happening? The answer is: because this program contains a data race problem. This program would print the correct number 200000, if, and only if the first thread finishs it‚Äôs tasks before the second thread starts to execute. But that is very unlikely to happen. Because the process of creating the thread is too fast, and therefore, both threads starts to execute roughly at the same time. If you change this code to add some nanoseconds of sleep between the first and the second calls to spawn(), you will increase the chances of the program producing the ‚Äúcorrect result‚Äù.\nSo the data race problem happens, because both threads are reading and writing to the same memory location at roughly the same time. In this example, each thread is essentially performing three basic operations at each iteration of the for loop, which are:\n\nreading the current value of count.\nincrementing this value by 1.\nwriting the result back into count.\n\nIdeally, a thread B should read the value of count, only after the other thread A has finished writing the incremented value back into the count object. Therefore, in the ideal scenario, which is demonstrated at Table¬†16.1, the threads should work in sync with each other. But the reality is that these threads are out of sync, and because of that, they suffer from a data race problem, which is demonstrated at Table¬†16.2.\nNotice that, in the data race scenario (#tbl-data-race-not), the read performed by a thread B happens before the write operation of thread A, and that ultimately leads to wrong results at the end of the program. Because when the thread B reads the value from the count variable, the thread A is still processing the initial value from count, and it did not write the new and incremented value into count yet. So what happens is that thread B ends up reading the same initial value (the ‚Äúold‚Äù value) from count, instead of reading the new and incremented version of this value that would be calculated by thread A.\n\n\n\nTable¬†16.1: An ideal scenario for two threads incrementing the same integer value\n\n\n\n\n\nThread 1\nThread 2\nInteger value\n\n\n\n\nread value\n\n0\n\n\nincrement\n\n1\n\n\nwrite value\n\n1\n\n\n\nread value\n1\n\n\n\nincrement\n2\n\n\n\nwrite value\n2\n\n\n\n\n\n\n\n\n\nTable¬†16.2: A data race scenario when two threads are incrementing the same integer value\n\n\n\n\n\nThread 1\nThread 2\nInteger value\n\n\n\n\nread value\n\n0\n\n\n\nread value\n0\n\n\nincrement\n\n1\n\n\n\nincrement\n1\n\n\nwrite value\n\n1\n\n\n\nwrite value\n1\n\n\n\n\n\n\nIf you think about these diagrams exposed in form of tables, you will notice that they relate back to our discussion of atomic operations at Section 16.6.2. Remember, atomic operations are operations that the CPU executes from beginning to end, without interruptions from other threads or processes. So, the scenario exposed at Table¬†16.1 do not suffer from a data race, because the operations performed by thread A are not interrupted in the middle by the operations from thread B.\nIf we also think about the discussion of critical section from Section 16.6.1, we can identify the section that representes the critical section of the program, which is the section that is vulnerable to data race conditions. In this example, the critical section of the program is the line where we increment the counter variable. So, ideally, we want to use a mutex, and lock right before this line, and then, unlock right after this line.\n\n\n16.6.4 Using mutexes in Zig\nNow that we know the problem that mutexes seek to solve, we can learn how to use them in Zig. Mutexes in Zig are available through the std.Thread.Mutex struct from the Zig Standard Library. If we take the same code example from the previous example, and improve it with mutexes, to solve our data race problem, we get the code example exposed below.\nNotice that we had this time to alter the increment() function to receive a pointer to the Mutex object as input. All that we need to do, to make this program safe against data race problems, is to call the lock() method at the beginning of the critical section, and then, call unlock() at the end of the critical section. Notice that the output of this program is the correct number of 200000.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Thread = std.Thread;\nconst Mutex = std.Thread.Mutex;\nvar counter: usize = 0;\nfn increment(mutex: *Mutex) void {\n    for (0..100000) |_| {\n        mutex.lock();\n        counter += 1;\n        mutex.unlock();\n    }\n}\n\npub fn main() !void {\n    var mutex: Mutex = .{};\n    const thr1 = try Thread.spawn(.{}, increment, .{&mutex});\n    const thr2 = try Thread.spawn(.{}, increment, .{&mutex});\n    thr1.join();\n    thr2.join();\n    try stdout.print(\"Couter value: {d}\\n\", .{counter});\n}\n\nCouter value: 200000",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#readwrite-locks",
    "href": "Chapters/14-threads.html#readwrite-locks",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.7 Read/Write locks",
    "text": "16.7 Read/Write locks\nMutexes are normally used when is always not safe to have two or more threads running the same piece of code at the same time. In contrast, read/write locks are normally used in situations where you have a mixture of scenarios, i.e.¬†there are some pieces of the codebase that are safe to run in parallel, and other pieces that are not safe.\nFor example, suppose that you have multiple threads that uses the same shared file in the filesystem to store some configurations, or, statistics. If two or more threads try to read the data from this same file at the same time, nothing bad happens. So this part of the codebase is perfectly safe to be executed in parallel, with multiple threads reading the same file at the same time.\nHowever, if two or more threads try to write data into this same file at the same time, then, we cause some race conditions problems. So this other part of the codebase is not safe to be executed in parallel. More specifically, a thread might end up writing data in the middle of the data written by the other thread. This process of two or more threads writing to the same location, might lead to data corruption. This specific situation is usually called of a torn write.\nThus, what we can extract from this is that there is certain types of operations that causes a race condition, but there are also, other types of operations that do not cause a race condition problem. You could also say that, there are types of operations that are susceptible to race condition problems, and there are other types of operations that are not.\nA read/write lock is a type of lock that acknowledges the existance of this specific scenario, and you can use this type of lock to control which parts of the codebase are safe to run in parallel, and which parts are not safe.\n\n16.7.1 Exclusive lock vs shared lock\nTherefore, a read/write lock is a little different from a mutex. Because a mutex is always an exclusive lock, meaning that, only one thread is allowed to execute at all times. With an exclusive lock, the other threads are always ‚Äúexcluded‚Äù, i.e.¬†they are always blocked from executing. But in a read/write lock, the other threads might be authorized to run at the same time, depending on the type of lock that they acquire.\nWe have two types of locks in a read/write lock, which are: an exclusive lock and a shared lock. An exclusive lock works exactly the same as a mutex, while a shared lock is a lock that does not block the other threads from running. In the pthreads C library, read/write locks are available through the pthread_rwlock_t C struct. With this C struct, you can create a ‚Äúwrite lock‚Äù, which corresponds to an exclusive lock, or, you can create a ‚Äúread lock‚Äù, which corresponds to a shared lock. The terminology might be a little different, but the meaning is the same, so just remember this relationship, write locks are exclusive locks, while read locks are shared locks.\nWhen a thread tries to acquire a read lock (i.e.¬†a shared lock), this thread get‚Äôs the shared lock if, and only if another thread does not currently holds a write lock (i.e.¬†an exclusive lock), and also, if there are no other threads that are already in the queue, waiting for their turn to acquire a write lock. In other words, the thread in the queue have attempted to get a write lock earlier, but this thread was blocked because there was another thread running that already had a write lock. As consequence, this thread is on the queue to get a write lock, and it‚Äôs currently waiting for the other thread with a write lock to finish it‚Äôs execution.\nWhen a thread tries to acquire a read lock, but it fails in acquiring this read lock, either because there is a thread with a write lock already running, or, because there is a thread in the queue to get a write lock, the execution of this thread is instantly blocked, i.e.¬†paused. This thread will indefinitely attempt to get the read lock, and it‚Äôs execution will be unblocked (or unpaused) only after this thread successfully acquires the read lock.\nIf you think deeply about this dynamic between read locks versus write locks, you might notice that a read lock is basically a safety mechanism. More specifically, it is a way for us to allow a particular thread to run together with the other threads, only when it‚Äôs safe to. In other words, if there is currently a thread with a write lock running, then, it is very likely not safe for the thread that is trying to acquire the read lock to run now. As consequence, the read lock protects this thread from running into dangerous waters, and patienly waits for the ‚Äúwrite lock‚Äù thread to finishs it‚Äôs tasks before it continues.\nOn the other hand, if there are only ‚Äúread lock‚Äù (i.e.¬†‚Äúshared lock‚Äù) threads currently running (i.e.¬†not a single ‚Äúwrite lock‚Äù thread currently exists), then, is perfectly safe for this thread that is acquiring the read lock to run in parallel with the other threads. As a result, the read lock just allows for this thread to run together with the other threads.\nThus, by using read locks (shared locks) in conjunction with write locks (exclusive locks), we can control which regions or sections of our multithreaded code is safe for us to have parallelism, and which sections are not safe to have parallelism.\n\n\n16.7.2 Using read/write locks in Zig\nThe Zig Standard Library supports read/write locks through the std.Thread.RwLock module. If you want to a particular thread to acquire a shared lock (i.e.¬†a read lock), you should call the lockShared() method from the RwLock object. But, if you want for this thread to acquire an exclusive lock (i.e.¬†a write lock) instead, then, you should call the lock() method from the RwLock object.\nAs with mutexes, we also have to unlock the shared or exclusive locks that we acquire through a read/write lock object, once we are at the end of our ‚Äúcritical section‚Äù. If you have acquired an exclusive lock, then, you unlock this exclusive lock by calling the unlock() method from the read/write lock object. In contrast, if you have acquired a shared lock instead, then, call unlockShared() to unlock this shared lock.\nAs a simple example, the code below creates three separate threads responsible for reading the current value in a counter object, and it also creates another thread, responsible for writing new data into the counter object (incrementing it, more specifically).\n\nvar counter: u32 = 0;\nfn reader(lock: *RwLock) !void {\n    while (true) {\n        lock.lockShared();\n        const v: u32 = counter;\n        try stdout.print(\"{d}\", .{v});\n        lock.unlockShared();\n        std.time.sleep(2 * std.time.ns_per_s);\n    }\n}\nfn writer(lock: *RwLock) void {\n    while (true) {\n        lock.lock();\n        counter += 1;\n        lock.unlock();\n        std.time.sleep(2 * std.time.ns_per_s);\n    }\n}\n\npub fn main() !void {\n    var lock: RwLock = .{};\n    const thr1 = try Thread.spawn(.{}, reader, .{&lock});\n    const thr2 = try Thread.spawn(.{}, reader, .{&lock});\n    const thr3 = try Thread.spawn(.{}, reader, .{&lock});\n    const wthread = try Thread.spawn(.{}, writer, .{&lock});\n\n    thr1.join();\n    thr2.join();\n    thr3.join();\n    wthread.join();\n}",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#potential-problems-in-threads",
    "href": "Chapters/14-threads.html#potential-problems-in-threads",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.8 Potential problems in threads",
    "text": "16.8 Potential problems in threads\nTODO: calling functions that might return an error inside threads (try) TODO: talk about deadlocks TODO: talk about race conditions TODO: joining with a thread that has already been joined leads to undefined behaviour. TODO: talk about zombie threads.\n\n16.8.1 Not calling join() or detach()\nWhen you do not call neither of these methods (join() or detach()), then, your thread does not have a clear ‚Äúreturn point‚Äù. You could also interpret this as: ‚Äúnobody is properly resposible for managing the thread‚Äù. In more details, when we don‚Äôt establish if a thread is either joinable or detached, nobody becomes responsible for dealing with the return value of this thread, and also, nobody becomes responsible for clearing (or freeing) the resources associated with this thread.\nYou don‚Äôt want to be in this situation, so remember to always use join() or detach() on the threads that you create. When you don‚Äôt use these methods, the execution of the thread becomes completely independent from the execution of the main process in your program. This means that the main process of your program might end before the thread finish it‚Äôs job, or vice-versa. The idea is that we have no idea of who is going to finish first. It becomes a race condition problem. In such case, we loose control over this thread, and it‚Äôs resources are never freed (i.e.¬†you have leaked resources in the system).",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#yielding-a-thread",
    "href": "Chapters/14-threads.html#yielding-a-thread",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.9 Yielding a thread",
    "text": "16.9 Yielding a thread\nThe Thread struct supports yielding through the yield() method. Yielding a thread means that the execution of the thread is temporarily stopped, and the thread comes back to the end of the queue of priority of the scheduler from your operating system.\nThat is, when you yield a thread, you are essentially saying the following to your OS: ‚ÄúHey! Could you please stop executing this thread for now, and comeback to continue it later?‚Äù. You could also interpret this yield operation as: ‚ÄúCould you please deprioritize this thread, to focus on doing other things instead?‚Äù. So this yield operation is also a way for you to stop a particular thread, so that you can work and prioritize other threads instead.\nIs important to say that, yielding a thread is a ‚Äúnot so commom‚Äù thread operation these days. In other words, not many programmers use yielding in production, simply because is hard to use this operation and make it work properly, and also, there are better alternatives. Most programmers prefer to use join() instead. In fact, most of the times, when you see somebody using yield in some code example, they are mostly using it to help them debug race conditions in their applications. That is, yield is mostly used as a debug tool nowadays.\nAnyway, if you want to yield a thread, just call the yield() method from it, like this:\nthread.yield();",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#how-to-stop-cancel-of-kill-a-particular-thread",
    "href": "Chapters/14-threads.html#how-to-stop-cancel-of-kill-a-particular-thread",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.10 How to stop, cancel of kill a particular thread",
    "text": "16.10 How to stop, cancel of kill a particular thread\n\n\n\n\nGeeks for Geeks. 2024. ‚ÄúCritical Section.‚Äù Geeks for Geeks. https://www.geeksforgeeks.org/g-fact-70/.\n\n\nLinux man-pages. 2024. ‚ÄúPthread_create(3) ‚Äî Linux Manual Page.‚Äù https://man7.org/linux/man-pages/man3/pthread_create.3.html.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#footnotes",
    "href": "Chapters/14-threads.html#footnotes",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "",
    "text": "https://github.com/ziglang/zig/issues/18810‚Ü©Ô∏é\nhttps://www.youtube.com/watch?v=7ENFeb-J75k&ab_channel=Computerphile‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chen, Jenny, and Ruohao Guo. 2022. ‚ÄúStack and Heap Memory.‚Äù\nIntroduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nGeeks for Geeks. 2024a. ‚ÄúCritical Section.‚Äù Geeks for\nGeeks. https://www.geeksforgeeks.org/g-fact-70/.\n\n\n‚Äî‚Äî‚Äî. 2024b. ‚ÄúGenerics in c++.‚Äù Geeks for\nGeeks. https://www.geeksforgeeks.org/generics-in-c/.\n\n\nKim, Juhee, Jinbum Park, Sihyeon Roh, Jaeyoung Chung, Youngjoo Lee,\nTaesoo Kim, and Byoungyoung Lee. 2024. ‚ÄúTikTag: Breaking ARM‚Äôs\nMemory Tagging Extension with Speculative Execution.‚Äù https://arxiv.org/abs/2406.08719.\n\n\nLinux man-pages. 2024. ‚ÄúPthread_create(3) ‚Äî Linux Manual\nPage.‚Äù https://man7.org/linux/man-pages/man3/pthread_create.3.html.\n\n\nMeehan, Eric. 2021. ‚ÄúCreating a Web Server from Scratch in\nc.‚Äù Youtube. https://www.youtube.com/watch?v=gk6NL1pZi1M&ab_channel=EricOMeehan.\n\n\nMicrosoft. 2021. ‚ÄúBitwise AND Operator: &.‚Äù Microsoft\nLearn. https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.\n\n\nSeguin, Karl. 2024. ‚ÄúGenerics.‚Äù https://www.openmymind.net/learning_zig/generics/.\n\n\nSobeston. 2024. ‚ÄúZig Guide.‚Äù https://zig.guide/.\n\n\nWeerasiri, Nipun Chamikara. 2023. ‚ÄúA Simple Web Server Written in\nc.‚Äù Medium. https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6.\n\n\nWikipedia. 2024a. ‚ÄúFile Descriptor.‚Äù Wikipedia. https://en.wikipedia.org/wiki/File_descriptor.\n\n\n‚Äî‚Äî‚Äî. 2024b. ‚ÄúGrayscale.‚Äù Wikipedia. https://en.wikipedia.org/wiki/Grayscale.\n\n\n‚Äî‚Äî‚Äî. 2024c. ‚ÄúHash Tables.‚Äù Wikipedia. https://en.wikipedia.org/wiki/Hash_table.\n\n\n‚Äî‚Äî‚Äî. 2024d. ‚ÄúPort (Computer Networking).‚Äù Wikipedia. https://en.wikipedia.org/wiki/Port_(computer_networking).\n\n\nYu, Jeffrey. 2023. ‚ÄúHow i Built a Simple HTTP Server from Scratch\nUsing c.‚Äù DEV Community. https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739.\n\n\nZig Software Foundation. 2024a. ‚ÄúIn-Depth Overview.‚Äù Zig\nSoftware Foundation. https://ziglang.org/learn/overview/.\n\n\n‚Äî‚Äî‚Äî. 2024b. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation.\nhttps://ziglang.org/documentation/master/.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#thread-pools",
    "href": "Chapters/14-threads.html#thread-pools",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.5 Thread pools",
    "text": "16.5 Thread pools\nThread pools is a very popular programming pattern, which is used specially on servers and daemons processes. A thread pool is just a set of threads, or, a ‚Äúpool‚Äù of threads. Many programmers like to use this pattern, because it makes easier to manage and use multiple threads, instead of manually creating the threads when you need them.\nAlso, using thread pools might increase performance as well in your program, especially if your program is constantly creating threads to perform short-lived tasks. In such instance, a thread pool might cause an increase in performance because you do not have be constantly creating and destroying threads all the time, so you don‚Äôt face a lot of the overhead involved in this constant process of creating and destroying threads.\nThe main idea behind a thread pool is to have a set of threads already created and ready to perform tasks at all times. You create a set of threads at the moment that your program starts, and keep these threads alive while your program runs. Each of these threads will be either performing a task, or, waiting for a task to be assigned. Every time a new task emerges in your program, this task is added to a ‚Äúqueue of tasks‚Äù. The moment that a thread becomes available and ready to perform a new task, this thread takes the next task in the ‚Äúqueue of tasks‚Äù, then, it simply performs the task.\nThe Zig Standard Library offers a thread pool implementation on the std.Thread.Pool struct. You create a new instance of a Pool object by providing a Pool.Options object as input to the init() method of this struct. A Pool.Options object, is a struct object that contains configurations for the pool of threads. The most important settings in this struct object are the members n_jobs and allocator. As the name suggests, the member allocator should receive an allocator object, while the member n_jobs specifies the number of threads to be created and maintained in this pool.\nConsider the example exposed below, that demonstrates how can we create a new thread pool object. Here, we create a Pool.Options object that contains a general purpose allocator object, and also, the n_jobs member was set to 4, which means that the thread pool will create and use 4 threads.\nAlso notice that the pool object was initially set to undefined. This allow us to initially declare the thread pool object, but not properly instantiate the underlying memory of the object. You have to initially declare your thread pool object by using undefined like this, because the init() method of Pool needs to have an initial pointer to properly instantiate the object.\nSo, just remember to create your thread pool object by using undefined, and then, after that, you call the init() method over the object. You should also not forget to call the deinit() method over the thread pool object, once you are done with it, to release the resources allocated for the thread pool. Otherwise, you will have a memory leak in your program.\n\nconst std = @import(\"std\");\nconst Pool = std.Thread.Pool;\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const opt = Pool.Options{\n        .n_jobs = 4,\n        .allocator = allocator,\n    };\n    var pool: Pool = undefined;\n    _ = try pool.init(opt);\n    defer pool.deinit();\n}\n\nNow that we know how to create Pool objects, we have to understand how to assign tasks to be executed by the threads in this pool object. To assign a task to be performed by a thread, we need to call the spawn() method from the thread pool object.\nThis spawn() method works identical to the spawn() method from the Thread object. The method have almost the same arguments as the previous one, more precisely, we don‚Äôt have to provide a SpawnConfig object in this case. But instead of creating a new thread, this spawn() method from the thread pool object just register a new task in the internal ‚Äúqueue of tasks‚Äù to be performed, and any available thread in the pool will get this task, and it will simply perform the task.\nIn the example below, we are using our previous print_id() function once again. But you may notice that the print_id() function is a little different this time, because now we are using catch instead of try in the print() call. Currently, the Pool struct only supports functions that don‚Äôt return errors as tasks. Thus, when assigining tasks to threads in a thread pool, is essential to use functions that don‚Äôt return errors. That is why we are using catch here, so that the print_id() function don‚Äôt return an error.\n\nfn print_id(id: *const u8) void {\n    _ = stdout.print(\"Thread ID: {d}\\n\", .{id.*})\n        catch void;\n}\nconst id1: u8 = 1;\nconst id2: u8 = 2;\ntry pool.spawn(print_id, .{&id1});\ntry pool.spawn(print_id, .{&id2});\n\nThis limitation should probably not exist, and, in fact, it is already on the radar of the Zig team to fix this issue, and it is being tracked on an open issue1. So, if you do need to provide a function that might return an error as the task to be performed by the threads in the thread pool, then, you are either limited to:\n\nimplementing your own thread pool that does not have this limitation.\nwait for the Zig team to actually fix this issue.",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/14-threads.html#mutexes",
    "href": "Chapters/14-threads.html#mutexes",
    "title": "16¬† Introducing threads and parallelism in Zig",
    "section": "16.6 Mutexes",
    "text": "16.6 Mutexes\nMutexes are a classic component of every thread library. In essence, a mutex is a Mutually Exclusive Flag, and this flag acts like a type of ‚Äúlock‚Äù, or as a gate keeper to a particular section of your code. Mutexes are related to thread syncronization, more specifically, they prevent you from having some classic race conditions in your program, and, therefore, major bugs and undefined behaviour that are usually difficult to track and understand.\nThe main idea behind a mutex is to help us to control the execution of a particular section of the code, and to prevent two or more threads from executing this particular section of the code at the same time. Many programmers like to compare a mutex to a bathroom door (which usually have a lock). When a thread locks it‚Äôs own mutex object, it is like if the bathroom door was locked, and, therefore, the other people (in this case, the other threads) that wants to use the same bathroom at the same time have to be patient, and simply wait for the other person (or the other thread) to unlock the door and get out of the bathroom.\nSome other programmers also like to explain mutexes by using the analogy of ‚Äúeach person will have their turn to speak‚Äù. This is the analogy used on the Multithreading Code video from the Computherfile project2. Imagine if you are in a conversation circle. There is a moderator in this circle, which is the person that decides who have the right to speak at that particular moment. The moderator gives a green card (or some sort of an authorization card) to the person that is going to speak, and, as a result, everyone else must be silent and hear this person that has the green card. When the person finishs talking, it gives the green card back to the moderator, and the moderator decides who is going to talk next, and delivers the green card to that person. And the cycle goes on like this.\nA mutex acts like the moderator in this conversation circle. The mutex authorizes one single thread to execute a specific section of the code, and it also blocks the other threads from executing this same section of the code. If these other threads wants to execute this same piece of the code, they are forced to wait for the the authorized thread to finish first. When the authorized thread finishs executing this code, the mutex authorizes the next thread to execute this code, and the other threads are still blocked. Therefore, a mutex is like a moderator that does a ‚Äúeach thread will have their turn to execute this section of the code‚Äù type of control.\nMutexes are specially used to prevent data race problems from happening. A data race problem happens when two or more threads are trying to read from or write to the same shared object at the same time. So, when you have an object that is shared will all threads, and, you want to avoid two or more threads from accessing this same object at the same time, you can use a mutex to lock the part of the code that access this specific object. When a thread tries to run this code that is locked by a mutex, this thread stops it‚Äôs execution, and patiently waits for this section of the codebase to be unlocked to continue.\nIn other words, the execution of the thread is paused while the code section is locked by the mutex, and it is unpaused the moment that the code section is unlocked by the other thread that was executing this code section. Notice that mutexes are normally used to lock areas of the codebase that access/modify data that is shared with all threads, i.e.¬†objects that are either stored in the global data section, or, in the heap space of your program. So mutexes are not normally used on areas of the codebase that access/modify objects that are local to the thread.\n\n16.6.1 Critical section\nCritical section is a concept commonly associated with mutexes and thread syncronization. In essence, a critical section is the section of the program that a thread access/modify a shared resource (i.e.¬†an object, a file descriptor, something that all threads have access to). In other words, a critical section is the section of the program where race conditions might happen, and, therefore, where undefined behaviour can be introduced into the program.\nWhen we use mutexes in our program, the critical section defines the area of the codebase that we want to lock. So we normally lock the mutex object at the beginning of the critical section, and then, we unlock it at the end of the critical section. The two bulletpoints exposed below comes from the ‚ÄúCritical Section‚Äù article from GeekFromGeeks, and they summarise well the role that a critical section plays in the thread syncronization problem (Geeks for Geeks 2024).\n\nThe critical section must be executed as an atomic operation, which means that once one thread or process has entered the critical section, all other threads or processes must wait until the executing thread or process exits the critical section. The purpose of synchronization mechanisms is to ensure that only one thread or process can execute the critical section at a time.\nThe concept of a critical section is central to synchronization in computer systems, as it is necessary to ensure that multiple threads or processes can execute concurrently without interfering with each other. Various synchronization mechanisms such as semaphores, mutexes, monitors, and condition variables are used to implement critical sections and ensure that shared resources are accessed in a mutually exclusive manner.\n\n\n\n16.6.2 Atomic operations\nYou will also see the term ‚Äúatomic operation‚Äù a lot when reading about threads, race conditions and mutexes. In summary, an operation is categorized as ‚Äúatomic‚Äù, when there is no way to happen a context switch in the middle of this operation. In other words, this operation is always done from beginning to end, without interruptions of another process or operation in the middle of it‚Äôs execution phase.\nNot many operations today are atomic. But why atomic operations matters here? Is because data races (which is a type of a race condition) cannot happen on operations that are atomic. So if a particular line in your code performs an atomic operation, then, this line will never suffer from a data race problem. Therefore, programmers sometimes use an atomic operation to protect themselves from data race problems in their code.\nWhen you have an operation that is compiled into just one single assembly instruction, this operation might be atomic, because is just one assembly instruction. But this is not guaranteed. This is usually true for old CPU architectures (such as x86). But nowadays, most assembly instructions in modern CPU architectures turn into multiple micro-tasks, which inherently makes the operation not atomic anymore, even though it has just one single assembly instruction.\nThe Zig Standard Library offers a thin wrapper in the std.atomic module, which makes some atomic operations easy to be done. In this module, we have a public generic function called Value(). With this function we can create an ‚Äúatomic value‚Äù, which is a value that contains native atomic operations, most notably, a load() and a fetchAdd() operation. Is important to emphasize that only primitive data types (i.e.¬†the types presented at Section 1.5) are supported by these atomic operations.\n\n\n16.6.3 Data races and race conditions\nTo understand why mutexes are used, we need to understand better the problem that they seek to solve, which can be summarized into data races problems. A data race problem is a type of a race condition, which happens when one thread is accessing a particular memory location (i.e.¬†a particular shared object) at the same time that another thread is trying to write/save new data into this same memory location (i.e.¬†the same shared object).\nWe can simply define a race condition as any type of bug in your program that is based on a ‚Äúwho get‚Äôs there first‚Äù problem. A data race problem is a type of a race condition, because it occurs when two or more parties are trying to read and write into the same memory location at the same time, and, therefore, the end result of this operation depends completely on who get‚Äôs to this memory location first. As consequence, a program that have a data race problem will likely produce a different result each time that we execute it.\nThus, race conditions produce unefined behaviour and unpredictability because the program produces a different answer in each time that a different person get‚Äôs to the target location first than the others. And we have no easy way to either predict or control who is going to get to this target location first. In other words, in each execution of your program, you get a different answer, because a different person, or, a different function, or, a different part of the code is finishing its tasks (or it is reaching a location) first than the others.\nAs an example, consider the code snippet exposed below. In this example, we create a global counter variable, and we also create a increment() function, whose job is to just increment this global counter variable in a for loop.\nSince the for loop iterates 1 hundred thousand times, and, we create two separate threads in this code example, what number do you expect to see in the final message printed to stdout? The answer should be 2 hundred thousand. Right? Well, in threory, this program was supposed to print 2 hundred thousand at the end, but in practice, every time that I execute this program I get a different answer.\nIn the example exposed below, you can see that this time we have executed the program, the end result was 117254, instead of the expected 200000. The second time I have executed this program, I got the number 108592 as result. So the end result of this program is varying, but it never gets to the expected 200000 that we want.\n\n// Global counter variable\nvar counter: usize = 0;\n// Function to increment the counter\nfn increment() void {\n    for (0..100000) |_| {\n        counter += 1;\n    }\n}\n\npub fn main() !void {\n    const thr1 = try Thread.spawn(.{}, increment, .{});\n    const thr2 = try Thread.spawn(.{}, increment, .{});\n    thr1.join();\n    thr2.join();\n    try stdout.print(\"Couter value: {d}\\n\", .{counter});\n}\n\nCouter value: 117254\nWhy this is happening? The answer is: because this program contains a data race problem. This program would print the correct number 200000, if, and only if the first thread finishs it‚Äôs tasks before the second thread starts to execute. But that is very unlikely to happen. Because the process of creating the thread is too fast, and therefore, both threads starts to execute roughly at the same time. If you change this code to add some nanoseconds of sleep between the first and the second calls to spawn(), you will increase the chances of the program producing the ‚Äúcorrect result‚Äù.\nSo the data race problem happens, because both threads are reading and writing to the same memory location at roughly the same time. In this example, each thread is essentially performing three basic operations at each iteration of the for loop, which are:\n\nreading the current value of count.\nincrementing this value by 1.\nwriting the result back into count.\n\nIdeally, a thread B should read the value of count, only after the other thread A has finished writing the incremented value back into the count object. Therefore, in the ideal scenario, which is demonstrated at Table¬†16.1, the threads should work in sync with each other. But the reality is that these threads are out of sync, and because of that, they suffer from a data race problem, which is demonstrated at Table¬†16.2.\nNotice that, in the data race scenario (Table¬†16.2), the read performed by a thread B happens before the write operation of thread A, and that ultimately leads to wrong results at the end of the program. Because when the thread B reads the value from the count variable, the thread A is still processing the initial value from count, and it did not write the new and incremented value into count yet. So what happens is that thread B ends up reading the same initial value (the ‚Äúold‚Äù value) from count, instead of reading the new and incremented version of this value that would be calculated by thread A.\n\n\n\nTable¬†16.1: An ideal scenario for two threads incrementing the same integer value\n\n\n\n\n\nThread 1\nThread 2\nInteger value\n\n\n\n\nread value\n\n0\n\n\nincrement\n\n1\n\n\nwrite value\n\n1\n\n\n\nread value\n1\n\n\n\nincrement\n2\n\n\n\nwrite value\n2\n\n\n\n\n\n\n\n\n\nTable¬†16.2: A data race scenario when two threads are incrementing the same integer value\n\n\n\n\n\nThread 1\nThread 2\nInteger value\n\n\n\n\nread value\n\n0\n\n\n\nread value\n0\n\n\nincrement\n\n1\n\n\n\nincrement\n1\n\n\nwrite value\n\n1\n\n\n\nwrite value\n1\n\n\n\n\n\n\nIf you think about these diagrams exposed in form of tables, you will notice that they relate back to our discussion of atomic operations at Section 16.6.2. Remember, atomic operations are operations that the CPU executes from beginning to end, without interruptions from other threads or processes. So, the scenario exposed at Table¬†16.1 do not suffer from a data race, because the operations performed by thread A are not interrupted in the middle by the operations from thread B.\nIf we also think about the discussion of critical section from Section 16.6.1, we can identify the section that representes the critical section of the program, which is the section that is vulnerable to data race conditions. In this example, the critical section of the program is the line where we increment the counter variable (counter += 1). So, ideally, we want to use a mutex, and lock right before this line, and then, unlock right after this line.\n\n\n16.6.4 Using mutexes in Zig\nNow that we know the problem that mutexes seek to solve, we can learn how to use them in Zig. Mutexes in Zig are available through the std.Thread.Mutex struct from the Zig Standard Library. If we take the same code example from the previous example, and improve it with mutexes, to solve our data race problem, we get the code example exposed below.\nNotice that we had this time to alter the increment() function to receive a pointer to the Mutex object as input. All that we need to do, to make this program safe against data race problems, is to call the lock() method at the beginning of the critical section, and then, call unlock() at the end of the critical section. Notice that the output of this program is now the correct number of 200000.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Thread = std.Thread;\nconst Mutex = std.Thread.Mutex;\nvar counter: usize = 0;\nfn increment(mutex: *Mutex) void {\n    for (0..100000) |_| {\n        mutex.lock();\n        counter += 1;\n        mutex.unlock();\n    }\n}\n\npub fn main() !void {\n    var mutex: Mutex = .{};\n    const thr1 = try Thread.spawn(.{}, increment, .{&mutex});\n    const thr2 = try Thread.spawn(.{}, increment, .{&mutex});\n    thr1.join();\n    thr2.join();\n    try stdout.print(\"Couter value: {d}\\n\", .{counter});\n}\n\nCouter value: 200000",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Introducing threads and parallelism in Zig</span>"
    ]
  }
]
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to Zig",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the ‚ÄúOpen Access‚Äù HTML version of the book ‚ÄúIntroduction to Zig: an project based book‚Äù, written by Pedro Duarte Faria. This is an open book that provides an introduction to the Zig programming language, which is a new general-purpose, and low-level language for building robust and optimal software.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "An Introduction to Zig",
    "section": "About this book",
    "text": "About this book\nThis an open book, meaning that, it is open-source, and it will always be open for anyone that wants to read it. However, this book is still under construction üöß and active development, so, it‚Äôs contents might change drastically in the near future.\nAlso, this is a project-based book, which means that we learn how to use the Zig programming language through small and simple projects, in a similar style to the famous ‚ÄúPython Crash Course‚Äù book from Eric Matthes.\nOfficial book‚Äôs repository: https://github.com/pedropark99/zig-book",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "An Introduction to Zig",
    "section": "About the author",
    "text": "About the author\nPedro Duarte Faria have a bachelor degree in Economics from Federal University of Ouro Preto - Brazil. Currently, he is a Data Platform Engineer at Blip1, and an Associate Developer for Apache Spark 3.0 certified by Databricks.\nThe author have more than 4 years of experience in the data industry. Developing data products, pipelines, reports and analysis for research institutions and some of the largest companies in the brazilian financial sector, such as the BMG Bank, Sodexo and Pan Bank.\nBut Pedro is also a passionate software developer that loves to learn and teach about programming. Although Pedro uses many different languages in his work, he is specialized in the R programming language, and have given several lectures and courses about it, inside graduate centers (such as PPEA-UFOP2), in addition to federal and state organizations (such as FJP-MG3).\nPersonal Website: https://pedro-faria.netlify.app/\nTwitter: @PedroPark9\nMastodon: @pedropark99@fosstodon.org",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "An Introduction to Zig",
    "section": "License",
    "text": "License\nCopyright ¬© 2024 Pedro Duarte Faria. This book is licensed by the CC-BY 4.0 Creative Commons Attribution 4.0 International Public License4.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-compilation-metadata",
    "href": "index.html#book-compilation-metadata",
    "title": "An Introduction to Zig",
    "section": "Book compilation metadata",
    "text": "Book compilation metadata\nThis book was compiled using the following versions of Zig and Quarto:\n\nSystem version: Linux, 6.5.0-44-generic, 22.04.1-Ubuntu, x86_64.\nZig version: 0.13.0-dev.266+0b0625ccf.\nQuarto version: 1.4.549.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-citation",
    "href": "index.html#book-citation",
    "title": "An Introduction to Zig",
    "section": "Book citation",
    "text": "Book citation\nYou can use the following BibTex entry to cite this book:\n@book{pedro2024,\n    author = {Pedro Duarte Faria},\n    title = {Introduction to Zig},\n    subtitle = {an project based book},\n    month = {December},\n    edition = {1},\n    year = {2024},\n    address = {Belo Horizonte}\n}",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#corresponding-author-and-maintainer",
    "href": "index.html#corresponding-author-and-maintainer",
    "title": "An Introduction to Zig",
    "section": "Corresponding author and maintainer",
    "text": "Corresponding author and maintainer\nPedro Duarte Faria\nContact: pedropark99@gmail.com\nPersonal website: https://pedro-faria.netlify.app/",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "An Introduction to Zig",
    "section": "",
    "text": "https://www.blip.ai/en/‚Ü©Ô∏é\nhttps://ppea.ufop.br/‚Ü©Ô∏é\nhttp://fjp.mg.gov.br/‚Ü©Ô∏é\nhttps://creativecommons.org/licenses/by/4.0/‚Ü©Ô∏é",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html",
    "href": "Chapters/01-zig-weird.html",
    "title": "1¬† Introducing Zig",
    "section": "",
    "text": "1.1 What is Zig?\nZig is a modern, low-level, and general-purpose programming language. Some programmers interpret Zig as the ‚Äúmodern C language‚Äù. It is a simple language like C, but with some modern features.\nIn the author‚Äôs personal interpretation, Zig is tightly connected with ‚Äúless is more‚Äù. Instead of trying to become a modern language by adding more and more features, many of the core improvements that Zig brings to the table are actually about removing annoying and evil behaviours/features from C and C++. In other words, Zig tries to be better by simplifying the language, and by having more consistent and robust behaviour. As a result, analyzing, writing and debugging applications become much easier and simpler in Zig, than it is in C or C++.\nThis philosophy becomes clear with the following phrase from the official website of Zig:\nThis phrase is specially true for C++ programmers. Because C++ is a gigantic language, with tons of features, and also, there are lots of different ‚Äúflavors of C++‚Äù. These elements are what makes C++ so much complex and hard to learn. Zig tries to go in the opposite direction. Zig is a very simple language, more closely related to other simple languages such as C and Go.\nThe phrase above is still important for C programmers too. Because, even C being a simple language, it is still hard sometimes to read and understand C code. For example, pre-processor macros in C are an evil source of confusion. They really makes it hard sometimes to debug C programs. Because macros are essentially a second language embedded in C that obscures your C code. With macros, you are no longer 100% sure about which pieces of code are being sent to the compiler. It obscures the actual source code that you wrote.\nYou don‚Äôt have macros in Zig. In Zig, the code you write, is the actual code that get‚Äôs compiled by the compiler. You don‚Äôt have evil features that obscures you code. You also don‚Äôt have hidden control flow happening behind the scenes. And, you also don‚Äôt have functions or operators from the standard library that make hidden memory allocations behind your back.\nBy being a simpler language, Zig becomes much more clear and easier to read/write, but at the same time, it also achieves a much more robust state, with more consistent behaviour in edge situations. Once again, less is more.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#what-is-zig",
    "href": "Chapters/01-zig-weird.html#what-is-zig",
    "title": "1¬† Introducing Zig",
    "section": "",
    "text": "‚ÄúFocus on debugging your application rather than debugging your programming language knowledge‚Äù.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "href": "Chapters/01-zig-weird.html#hello-world-in-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.2 Hello world in Zig",
    "text": "1.2 Hello world in Zig\nWe begin our journey in Zig by creating a small ‚ÄúHello World‚Äù program. To start a new Zig project in your computer, you simply call the init command from the zig compiler. Just create a new directory in your computer, then, init a new Zig project inside this directory, like this:\nmkdir hello_world\ncd hello_world\nzig init\ninfo: created build.zig\ninfo: created build.zig.zon\ninfo: created src/main.zig\ninfo: created src/root.zig\ninfo: see `zig build --help` for a menu of options\n\n1.2.1 Understanding the project files\nAfter you run the init command from the zig compiler, some new files are created inside of your current directory. First, a ‚Äúsource‚Äù (src) directory is created, containing two files, main.zig and root.zig. Each .zig file is a separate Zig module, which is simply a text file that contains some Zig code.\nThe main.zig file for example, contains a main() function, which represents the entrypoint of your program. It is where the execution of your program begins. As you would expect from a C, C++, Rust or Go, to build an executabe program in Zig, you also need to declare a main() function in your module. So, the main.zig module represents an executable program written in Zig.\nOn the other side, the root.zig module does not contain a main() function. Because it represents a library written in Zig. Libraries are different than executables. They don‚Äôt need to have an entrypoint to work. So, you can choose which file (main.zig or root.zig) you want to follow depending on which type of project (executable or library) you want to develop.\ntree .\n.\n‚îú‚îÄ‚îÄ build.zig\n‚îú‚îÄ‚îÄ build.zig.zon\n‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ main.zig\n    ‚îî‚îÄ‚îÄ root.zig\n\n1 directory, 4 files\nNow, in addition to the source directory, two other files were created in our working directory: build.zig and build.zig.zon. The first file (build.zig) represents a build script written in Zig. This script is executed when you call the build command from the zig compiler. In other words, this file contain Zig code that executes the necessary steps to build the entire project.\nIn general, low-level languages normally use a compiler to build your source code into binary executables or binary libraries. Nevertheless, this process of compiling your source code and building binary executables or binary libraries from it, became a real challenge in the programming world, once the projects became bigger and bigger. As a result, programmers created ‚Äúbuild systems‚Äù, which are a second set of tools designed to make this process of compiling and building complex projects, easier.\nExamples of build systems are CMake, GNU Make, GNU Autoconf and Ninja, which are used to build complex C and C++ projects. With these systems, you can write scripts, which are called ‚Äúbuild scripts‚Äù. They simply are scripts that describes the necessary steps to compile/build your project.\nHowever, these are separate tools, that do not belong to C/C++ compilers, like gcc or clang. As a result, in C/C++ projects, you have not only to install and manage your C/C++ compilers, but you also have to install and manage these build systems separately.\nBut instead of using a separate build system, in Zig, we use the Zig language itself to write build scripts. In other words, Zig contains a native build system in it. And we can use this build system to write small scripts in Zig, which describes the necessary steps to build/compile our Zig project2. So, everything you need to build a complex Zig project is the zig compiler, and nothing more.\nNow that we described this topic in more depth, let‚Äôs focus on the second generated file (build.zig.zon), which is the Zig package manager configuration file, where you can list and manage the dependencies of your project. Yes, Zig have a package manager (like pip in Python, cargo in Rust, or npm in Javascript) called Zon, and this build.zig.zon file is similar to the package.json file in Javascript projects, or, the Pipfile in Python projects.\n\n\n1.2.2 Looking at the root.zig file\nLet‚Äôs take a look at the root.zig file, and start to analyze some of the syntax of Zig. The first thing that you might notice, is that every line of code that have an expression in it, ends with a semicolon character (;). This is similar syntax to other languages such as C, C++ and Rust, which have the same rule.\nAlso, notice the @import() call at the first line. We use this built-in function to import functionality from other Zig modules into our current module. In other words, the @import() function works similarly to the #include pre-processor in C or C++, or, to the import statement in Python or Javascript code. In this example, we are importing the std module, which gives you access to the Zig standard library.\nIn this root.zig file, we can also see how assignments (i.e.¬†creating new objects) are made in Zig. You can create a new object in Zig by using the following syntax (const|var) name = value;. In the example below, we are creating two constant objects (std and testing). At Section 1.4 we talk more about objects in general.\n\nconst std = @import(\"std\");\nconst testing = std.testing;\n\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nFunctions in Zig are declared similarly to functions in Rust, using the fn keyword. In the example above, we are declaring a function called add(), which have two arguments named a and b, and returns a integer number (i32) as result.\nMaybe Zig is not exactly a strongly-typed language, because you do not need necessarily to specify the type of every single object you create across your source code. But you do have to explicitly specify the type of every function argument, and also, the return type of every function you create in Zig. So, at least in function declarations, Zig is a strongly-typed language.\nWe specify the type of an object or a function argument in Zig, by using a colon character (:) followed by the type after the name of this object/function argument. With the expressions a: i32 and b: i32, we know that, both a and b arguments have type i32, which is a signed 32 bit integer. In this part, the syntax in Zig is identical to the syntax in Rust, which also specifies types by using the colon character.\nLastly, we have the return type of the function at the end of the line, before we open the curly braces to start writing the function‚Äôs body, which, in the example above is again a signed 32 bit integer (i32) value. This specific part is different than it is in Rust. Because in Rust, the return type of a function is specified after an arrow (-&gt;). While in Zig, we simply declare the return type directly after the parentheses with the function arguments.\nWe also have an export keyword before the function declaration. This keyword is similar to the extern keyword in C. It exposes the function to make it available in the library API.\nIn other words, if you have a project where you are currently building a library for other people to use, you need to expose your functions so that they are available in the library‚Äôs API, so that users can use it. If we removed the export keyword from the add() function declaration, then, this function would be no longer exposed in the library object built by the zig compiler.\nHaving that in mind, the keyword export is a keyword used in libraries written in Zig. So, if you are not currently writing a library in your project, then, you do not need to care about this keyword.\n\n\n1.2.3 Looking at the main.zig file\nNow that we have learned a lot about Zig‚Äôs syntax from the root.zig file, let‚Äôs take a look at the main.zig file. A lot of the elements we saw in root.zig are also present in main.zig. But we have some other elements that we did not have seen yet, so let‚Äôs dive in.\nFirst, look at the return type of the main() function in this file. We can see a small change. Now, the return type of the function (void) is accompanied by an exclamation mark (!). What this exclamation mark is telling us, is that this main() function might also return an error.\nSo, in this example, the main() function can either return void, or, return an error. This is an interesting feature of Zig. If you write a function, and, something inside of the body of this function might return an error, then, you are forced to:\n\neither add the exclamation mark to the return type of the function, to make it clear that this function might return an error.\nor explicitly handle this error that might occur inside the function, to make sure that, if this error does happen, you are prepared, and your function will no longer return an error because you handled the error inside your function.\n\nIn most programming languages, we normally handle (or deals with) an error through a try catch pattern, and Zig, this is no different. But, if we look at the main() function below, you can see that we do have a try keyword in the 5th line. But we do not have a catch keyword in this code.\nThis means that, we are using the keyword try to execute a code that might return an error, which is the stdout.print() expression. But because we do not have a catch keyword in this line, we are not treating (or dealing with) this error. So, if this expression do return an error, we are not catching and solving this error in any way. That is why the exclamation mark was added to the return type of the function.\nSo, in essence, the try keyword executes the expression stdout.print(). If this expression returns a valid value, then, the try keyword do nothing essentially. It simply passes this value forward. But, if the expression do return an error, then, the try keyword will unwrap and return this error from the function, and also print it‚Äôs stack trace to stderr.\nThis might sound weird to you, if you come from a high-level language. Because in high-level languages, such as Python, if an error occurs somewhere, this error is automatically returned and the execution of your program will automatically stops, even if you don‚Äôt want to stop the execution. You are obligated to face the error.\nBut if you come from a low-level language, then, maybe, this idea do not sound so weird or distant to you. Because in C for example, normally functions doesn‚Äôt raise errors, or, they normally don‚Äôt stop the execution. In C, error handling is done by constantly checking the return value of the function. So, you run the function, and then, you use an if statement to check if the function returned a value that is valid, or, if it returned an error. If an error was returned from the function, then, the if statement will execute some code that fixes this error.\nSo, at least for C programmers, they do need to write a lot of if statements to constantly check for errors around their code. And because of that, this simple feature from Zig, might be extraordinary for them. Because this try keyword can automatically unwrap the error, and warn you about this error, and let you deal with it, without any extra work from the programmer.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nNow, another thing that you might have noticed in this code example, is that the main() function is marked with the pub keyword. This keyword means ‚Äúpublic‚Äù. It marks the main() function as a public function from this module.\nIn other words, every function that you declare in your Zig module is, by default, a private (or ‚Äústatic‚Äù) function that belongs to this Zig module, and can only be used (or called) from within this same module. Unless, you explicitly mark this function as a public function with the pub keyword. This means that the pub keyword in Zig do essentially the opposite of what the static keyword do in C/C++.\nBy making a function ‚Äúpublic‚Äù, you allow other Zig modules to access and call this function, and use it for they own purposes. all these other Zig modules need to do is, to import your module with the @import() built-in function. Then, they get access to all public functions that are present in your Zig module.\n\n\n1.2.4 Compiling your source code\nYou can compile your Zig modules into a binary executable by running the build-exe command from the zig compiler. You simply list all the Zig modules that you want to build after the build-exe command, separated by spaces. In the example below, we are compiling the module main.zig.\nzig build-exe src/main.zig\nSince we are building an executable, the zig compiler will look for a main() function declared in any of the files that you list after the build-exe command. If the compiler does not find a main() function declared somewhere, a compilation error will be raised, warning about this mistake.\nThe zig compiler also offers a build-lib and build-obj commands, which work the exact same way as the build-exe command. The only difference is that, they compile your Zig modules into a portale C ABI library, or, into object files, respectively.\nIn the case of the build-exe command, a binary executable file is created by the zig compiler in the root directory of your project. If we take a look now at the contents of our current directory, with a simple ls command, we can see the binary file called main that was created by the compiler.\nls\nbuild.zig  build.zig.zon  main  src\nIf I execute this binary executable, I get the ‚ÄúHello World‚Äù message in the terminal , as we expected.\n./main\nHello, world!\n\n\n1.2.5 Compile and execute at the same time\nOn the previous section, I presented the zig build-exe command, which compiles Zig modules into an executable file. However, this means that, in order to execute the executable file, we have to run two different commands. First, the zig build-exe command, and then, we call the executable file created by the compiler.\nBut what if we wanted to perform these two steps, all at once, in a single command? We can do that by using the zig run command.\nzig run src/main.zig\nHello, world!\n\n\n1.2.6 Compiling the entire project\nJust as I described at Section 1.2.1, as our project grows in size and complexity, we usually prefer to organize the compilation and build process of the project into a build script, using some sort of ‚Äúbuild system‚Äù.\nIn other words, as our project grows in size and complexity, the build-exe, build-lib and build-obj commands become harder to use directly. Because then, we start to list multiple and multiple modules at the same time. We also start to add built-in compilation flags to customize the build process for our needs, etc. It becomes a lot of work to write the necessary commands by hand.\nIn C/C++ projects, programmers normally opt to use CMake, Ninja, Makefile or configure scripts to organize this process. However, in Zig, we have a native build system in the language itself. So, we can write build scripts in Zig to compile and build Zig projects. Then, all we need to do, is to call the zig build command to build our project.\nSo, when you execute the zig build command, the zig compiler will search for a Zig module named build.zig inside your current directory, which should be your build script, containing the necessary code to compile and build your project. If the compiler do find this build.zig file in your directory, then, the compiler will essentially execute a zig run command over this build.zig file, to compile and execute this build script, which in turn, will compile and build your entire project.\nzig build\nAfter you execute this ‚Äúbuild project‚Äù command, a zig-out directory is created in the root of your project directory, where you can find the binary executables and libraries created from your Zig modules accordingly to the build commands that you specified at build.zig. We will talk more about the build system in Zig latter in this book.\nIn the example below, I‚Äôm executing the binary executable named hello_world that was generated by the compiler after the zig build command.\n./zig-out/bin/hello_world\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#how-to-learn-zig",
    "href": "Chapters/01-zig-weird.html#how-to-learn-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.3 How to learn Zig?",
    "text": "1.3 How to learn Zig?\nWhat are the best strategies to learn Zig? First of all, of course this book will help you a lot on your journey through Zig. But you will also need some extra resources if you want to be really good at Zig.\nAs a first tip, you can join a community with Zig programmers to get some help , when you need it:\n\nReddit forum: https://www.reddit.com/r/Zig/;\nZiggit community: https://ziggit.dev/;\nDiscord, Slack, Telegram, and others: https://github.com/ziglang/zig/wiki/Community;\n\nNow, one of the best ways to learn Zig is to simply read Zig code. Try to read Zig code often, and things will become more clear. A C/C++ programmer would also probably give you this same tip. Because this strategy really works!\nNow, where you can find Zig code to read? I personally think that, the best way of reading Zig code is to read the source code of the Zig Standard Library. The Zig Standard Library is available at the lib/std folder3 on the official GitHub repository of Zig. Access this folder, and start exploring the Zig modules.\nAlso, a great alternative is to read code from other large Zig codebases, such as:\n\nthe Javascript runtime Bun4.\nthe game engine Mach5.\na LLama 2 LLM model implementation in Zig6.\nthe financial transactions database tigerbeetle7.\nthe command-line arguments parser zig-clap8.\nthe UI framework capy9.\nthe Language Protocol implementation for Zig, zls10.\nthe event-loop library libxev11.\n\nAll these assets are available on GitHub, and this is great, because we can use the GitHub search bar in our advantage, to find Zig code that fits our description. For example, you can always include lang:Zig in the GitHub search bar when you are searching for a particular pattern. This will limit the search to only Zig modules.\nAlso, a great alternative is to consult online resources and documentations. Here is a quick list of resources that I personally use from time to time to learn more about the language each day:\n\nZig Language Reference: https://ziglang.org/documentation/master/;\nZig Standard Library Reference: https://ziglang.org/documentation/master/std/;\nZig Guide: https://zig.guide/;\nKarl Seguin Blog: https://www.openmymind.net/;\nZig News: https://zig.news/;\nRead the code written by one of the Zig core team members: https://github.com/kubkon;\nSome livecoding sessions are transmitted in the Zig Showtime Youtube Channel: https://www.youtube.com/@ZigSHOWTIME/videos;\n\nAnother great strategy to learn Zig, or honestly, to learn any language you want, is to practice it by solving exercises. For example, there is a famous repository in the Zig community called Ziglings12 , which contains more than 100 small exercises that you can solve. It is a repository of tiny programs written in Zig that are currently broken, and your responsibility is to fix these programs, and make them work again.\nA famous tech YouTuber known as The Primeagen also posted some videos (at YouTube) where he solves these exercises from Ziglings. The first video is named ‚ÄúTrying Zig Part 1‚Äù13.\nAnother great alternative, is to solve the Advent of Code exercises14. There are people that already took the time to learn and solve the exercises, and they posted their solutions on GitHub as well, so, in case you need some resource to compare while solving the exercises, you can look at these two repositories:\n\nhttps://github.com/SpexGuy/Zig-AoC-Template;\nhttps://github.com/fjebaker/advent-of-code-2022;",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-assignments",
    "href": "Chapters/01-zig-weird.html#sec-assignments",
    "title": "1¬† Introducing Zig",
    "section": "1.4 Creating new objects in Zig (i.e.¬†identifiers)",
    "text": "1.4 Creating new objects in Zig (i.e.¬†identifiers)\nLet‚Äôs talk more about objects in Zig. Readers that have past experience with other programming languages might know this concept through a different name, such as: ‚Äúvariable‚Äù or ‚Äúidentifier‚Äù. In this book, I choose to use the term ‚Äúobject‚Äù to refer to this concept.\nTo create a new object (or a new ‚Äúidentifier‚Äù) in Zig, we use the keywords const or var. These keywords specificy if the object that you are creating is mutable or not. If you use const, then the object you are creating is a constant (or immutable) object, which means that once you declare this object, you can no longer change the value stored inside this object.\nOn the other side, if you use var, then, you are creating a variable (or mutable) object. You can change the value of this object as many times you want. Using the keyword var in Zig is similar to using the keywords let mut in Rust.\n\n1.4.1 Constant objects vs variable objects\nIn the code example below, we are creating a new constant object called age. This object stores a number representing the age of someone. However, this code example does not compiles succesfully. Because on the next line of code, we are trying to change the value of the object age to 25.\nThe zig compiler detects that we are trying to change the value of an object/identifier that is constant, and because of that, the compiler will raise a compilation error, warning us about the mistake.\n\nconst age = 24;\n// The line below is not valid!\nage = 25;\n\nt.zig:10:5: error: cannot assign to constant\n    age = 25;\n      ~~^~~\nIn contrast, if you use var, then, the object created is a variable object. With var you can declare this object in your source code, and then, change the value of this object how many times you want over future points in your source code.\nSo, using the same code example exposed above, if I change the declaration of the age object to use the var keyword, then, the program gets compiled succesfully. Because now, the zig compiler detects that we are changing the value of an object that allows this behaviour, because it is an ‚Äúvariable object‚Äù.\n\nvar age: u8 = 24;\nage = 25;\n\n\n\n1.4.2 Declaring without an initial value\nBy default, when you declare a new object in Zig, you must give it an initial value. In other words, this means that we have to declare, and, at the same time, initialize every object we create in our source code.\nOn the other hand, you can, in fact, declare a new object in your source code, and not give it an explicit value. But we need to use a special keyword for that, which is the undefined keyword.\nIs important to emphasize that, you should avoid using undefined as much as possible. Because when you use this keyword, you leave your object uninitialized, and, as a consequence, if for some reason, your code use this object while it is uninitialized, then, you will definitely have undefined behaviour and major bugs in your program.\nIn the example below, I‚Äôm declaring the age object again. But this time, I do not give it an initial value. The variable is only initialized at the second line of code, where I store the number 25 in this object.\n\nvar age: u8 = undefined;\nage = 25;\n\nHaving these points in mind, just remember that you should avoid as much as possible to use undefined in your code. Always declare and initialize your objects. Because this gives you much more safety in your program. But in case you really need to declare an object without initializing it‚Ä¶ the undefined keyword is the way to do it in Zig.\n\n\n1.4.3 There is no such thing as unused objects\nEvery object (being constant or variable) that you declare in Zig must be used in some way. You can give this object to a function call, as a function argument, or, you can use it in another expression to calculate the value of another object, or, you can call a method that belongs to this particular object.\nIt doesn‚Äôt matter in which way you use it. As long as you use it. If you try to break this rule, i.e.¬†if your try to declare a object, but not use it, the zig compiler will not compile your Zig source code, and it will issue a error message warning that you have unused objects in your code.\nLet‚Äôs demonstrate this with an example. In the source code below, we declare a constant object called age. If you try to compile a simple Zig program with this line of code below, the compiler will return an error as demonstrated below:\n\nconst age = 15;\n\nt.zig:4:11: error: unused local constant\n    const age = 15;\n          ^~~\nEverytime you declare a new object in Zig, you have two choices:\n\nyou either use the value of this object;\nor you explicitly discard the value of the object;\n\nTo explicitly discard the value of any object (constant or variable), all you need to do is to assign this object to an special character in Zig, which is the underscore (_). When you assign an object to a underscore, like in the example below, the zig compiler will automatically discard the value of this particular object.\nYou can see in the example below that, this time, the compiler did not complain about any ‚Äúunused constant‚Äù, and succesfully compiled our source code.\n\n// It compiles!\nconst age = 15;\n_ = age;\n\nNow, remember, everytime you assign a particular object to the underscore, this object is essentially destroyed. It is discarded by the compiler. This means that you can no longer use this object further in your code. It doesn‚Äôt exist anymore.\nSo if you try to use the constant age in the example below, after we discarded it, you will get a loud error message from the compiler (talking about a ‚Äúpointless discard‚Äù) warning you about this mistake.\n\n// It does not compile.\nconst age = 15;\n_ = age;\n// Using a discarded value!\nstd.debug.print(\"{d}\\n\", .{age + 2});\n\nt.zig:7:5: error: pointless discard\n    of local constant\nThis same rule applies to variable objects. Every variable object must also be used in some way. And if you assign a variable object to the underscore, this object also get‚Äôs discarded, and you can no longer use this object.\n\n\n1.4.4 You must mutate every variable objects\nEvery variable object that you create in your source code must be mutated at some point. In other words, if you declare an object as a variable object, with the keyword var, and you do not change the value of this object at some point in the future, the zig compiler will detect this, and it will raise an error warning you about this mistake.\nThe concept behind this is that every object you create in Zig should be preferably a constant object, unless you really need an object whose value will change during the execution of your program.\nSo, if I try to declare a variable object such as where_i_live below, and I do not change the value of this object in some way, the zig compiler raises an error message with the phrase ‚Äúvariable is never mutated‚Äù.\n\nvar where_i_live = \"Belo Horizonte\";\n_ = where_i_live;\n\nt.zig:7:5: error: local variable is never mutated\nt.zig:7:5: note: consider using 'const'",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#primitive-data-types",
    "href": "Chapters/01-zig-weird.html#primitive-data-types",
    "title": "1¬† Introducing Zig",
    "section": "1.5 Primitive Data Types",
    "text": "1.5 Primitive Data Types\nZig have many different primitive data types available for you to use. You can see the full list of available data types at the official Language Reference page15.\nBut here is a quick list:\n\nUnsigned integers: u8, 8-bit integer; u16, 16-bit integer; u32, 32-bit integer; u64, 64-bit integer; u128, 128-bit integer.\nSigned integers: i8, 8-bit integer; i16, 16-bit integer; i32, 32-bit integer; i64, 64-bit integer; i128, 128-bit integer.\nFloat number: f16, 16-bit floating point; f32, 32-bit floating point; f64, 64-bit floating point; f128, 128-bit floating point;\nBoolean: bool, represents true or false values.\nC ABI compatible types: c_long, c_char, c_short, c_ushort, c_int, c_uint, and many others.\nPointer sized integers: isize and usize.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-arrays",
    "href": "Chapters/01-zig-weird.html#sec-arrays",
    "title": "1¬† Introducing Zig",
    "section": "1.6 Arrays",
    "text": "1.6 Arrays\nYou create arrays in Zig by using a syntax that resembles the C syntax. First, you specify the size of the array (i.e.¬†the number of elements that will be stored in the array) you want to create inside a pair of brackets.\nThen, you specify the data type of the elements that will be stored inside this array. All elements present in an array in Zig must have the same data type. For example, you cannot mix elements of type f32 with elements of type i32 in the same array.\nAfter that, you simply list the values that you want to store in this array inside a pair of curly braces. In the example below, I am creating two constant objets that contain different arrays. The first object contains an array of 4 integer values, while the second object, an array of 3 floating point values.\nNow, you should notice that in the object ls, I am not explicitly specifying the size of the array inside of the brackets. Instead of using a literal value (like the value 4 that I used in the ns object), I am using the special character underscore (_). This syntax tells the zig compiler to fill this field with the number of elements listed inside of the curly braces. So, this syntax [_] is for lazy (or smart) programmers who leave the job of counting how many elements there are in the curly braces for the compiler.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst ls = [_]f64{432.1, 87.2, 900.05};\n_ = ns; _ = ls;\n\n\n1.6.1 Selecting elements of the array\nOne very commom activity is to select specific portions of an array you have in your source code. In Zig, you can select a specific element from your array, by simply providing the index of this particular element inside brackets after the object name. In the example below, I am selecting the third element from the ns array. Notice that Zig is a ‚Äúzero-index‚Äù based language, like C, C++, Rust, Python, and many other languages.\n\nconst ns = [4]u8{48, 24, 12, 6};\ntry stdout.print(\"{d}\\n\", .{ ns[2] });\n\n12\n\n\nIn contrast, you can also select specific slices (or sections) of your array, by using a range selector. Some programmers also call these selectors of ‚Äúslice selectors‚Äù, and they also exist in Rust, and have the exact same syntax as in Zig. Anyway, a range selector is a special expression in Zig that defines a range of indexes, and it have the syntax start..end.\nIn the example below, at the second line of code, the sl object stores a slice (or a portion) of the ns array. More precisely, the elements at index 1 and 2 in the ns array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\n_ = sl;\n\nWhen you use the start..end syntax, the ‚Äúend tail‚Äù of the range selector is non-inclusive, meaning that, the index at the end is not included in the range that is selected from the array. Therefore, the syntax start..end actually means start..end - 1 in practice.\nYou can for example, create a slice that goes from the first to the last elements of the array, by using ar[0..ar.len] syntax In other words, it is a slice that access all elements in the array.\n\nconst ar = [4]u8{48, 24, 12, 6};\nconst sl = ar[0..ar.len];\n_ = sl;\n\nYou can also use the syntax start.. in your range selector. Which tells the zig compiler to select the portion of the array that begins at the start index until the last element of the array. In the example below, we are selecting the range from index 1 until the end of the array.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..];\n_ = sl;\n\n\n\n1.6.2 More on slices\nAs we discussed before, in Zig, you can select specific portions of an existing array. This is called slicing in Zig (Sobeston 2024), because when you select a portion of an array, you are creating a slice object from that array.\nA slice object is essentially a pointer object accompained by a length number. The pointer object points to the first element in the slice, and the length number tells the zig compiler how many elements there are in this slice.\n\nSlices can be thought of as a pair of [*]T (the pointer to the data) and a usize (the element count) (Sobeston 2024).\n\nThrough the pointer contained inside the slice you can access the elements (or values) that are inside this range (or portion) that you selected from the original array. But the length number (which you can access through the len property of your slice object) is the really big improvement (over C arrays for example) that Zig brings to the table here.\nBecause with this length number the zig compiler can easily check if you are trying to access an index that is out of the bounds of this particular slice, or, if you are causing any buffer overflow problems. In the example below, we access the len property of the slice sl, which tells us that this slice have 2 elements in it.\n\nconst ns = [4]u8{48, 24, 12, 6};\nconst sl = ns[1..3];\ntry stdout.print(\"{d}\\n\", .{sl.len});\n\n2\n\n\n\n\n1.6.3 Array operators\nThere are two array operators available in Zig that are very useful. The array concatenation operator (++), and the array multiplication operator (**). As the name suggests, these are array operators.\nOne important detail about these two operators is that they work only when both operands have a size (or ‚Äúlength‚Äù) that is compile-time known. We are going to talk more about the differences between ‚Äúcompile-time known‚Äù and ‚Äúruntime known‚Äù at Section 2.1.1. But for now, keep this information in mind, that you cannot use these operators in every situation.\nIn summary, the ++ operator creates a new array that is the concatenation, of both arrays provided as operands. So, the expression a ++ b produces a new array which contains all the elements from arrays a and b.\n\nconst a = [_]u8{1,2,3};\nconst b = [_]u8{4,5};\nconst c = a ++ b;\ntry stdout.print(\"{any}\\n\", .{c});\n\n{ 1, 2, 3, 4, 5 }\n\n\nThis ++ operator is particularly useful to concatenate strings together. Strings in Zig are described in depth at Section 1.12. In summary, a string object in Zig is essentially an arrays of bytes. So, you can use this array concatenation operator to effectively concatenate strings together.\nIn contrast, the ** operator is used to replicate an array multiple times. In other words, the expression a ** 3 creates a new array which contains the elements of the array a repeated 3 times.\n\nconst a = [_]u8{1,2,3};\nconst c = a ** 2;\ntry stdout.print(\"{any}\\n\", .{c});\n\n{ 1, 2, 3, 1, 2, 3 }",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#blocks-and-scopes",
    "href": "Chapters/01-zig-weird.html#blocks-and-scopes",
    "title": "1¬† Introducing Zig",
    "section": "1.7 Blocks and scopes",
    "text": "1.7 Blocks and scopes\nBlocks are created in Zig by a pair of curly braces. A block is just a group of expressions (or statements) contained inside of a pair of curly braces. All of these expressions that are contained inside of this pair of curly braces belongs to the same scope.\nIn other words, a block just delimits a scope in your code. The objects that you define inside the same block belongs to the same scope, and, therefore, are accessible from within this scope. At the same time, these objects are not accessible outside of this scope. So, you could also say that blocks are used to limit the scope of the objects that you create in your source code. In less technical terms, blocks are used to specify where in your source code you can access whatever object you have in your source code.\nSo, a block is just a group of expressions contained inside a pair of curly braces. And every block have it‚Äôs own scope separated from the others. The body of a function is a classic example of a block. If statements, for and while loops (and any other structure in the language that uses the pair of curly braces) are also examples of blocks.\nThis means that, every if statement, or for loop, etc., that you create in your source code have it‚Äôs own separate scope. That is why you can‚Äôt access the objects that you defined inside of your for loop (or if statement) in an outer scope, i.e.¬†a scope outside of the for loop. Because you are trying to access an object that belongs to a scope that is different than your current scope.\nYou can create blocks within blocks, with multiple levels of nesting. You can also (if you want to) give a label to a particular block, with the colon character (:). Just write label: before you open the pair of curly braces that delimits your block. When you label a block in Zig, you can use the break keyword to return a value from this block, like as if it was a function‚Äôs body. You just write the break keyword, followed by the block label in the format :label, and the expression that defines the value that you want to return.\nLike in the example below, where we are returning the value from the y object from the block add_one, and saving the result inside the x object.\n\nvar y: i32 = 123;\nconst x = add_one: {\n    y += 1;\n    break :add_one y;\n};\nif (x == 124 and y == 124) {\n    try stdout.print(\"Hey!\", .{});\n}\n\nHey!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-type-inference",
    "href": "Chapters/01-zig-weird.html#sec-type-inference",
    "title": "1¬† Introducing Zig",
    "section": "1.8 Type inference",
    "text": "1.8 Type inference\nZig is kind of a strongly typed language. I say ‚Äúkind of‚Äù because there are situations where you don‚Äôt have to explicitly write the type of every single object in your source code, as you would expect from a traditional strongly typed language, such as C and C++.\nIn some situations, the zig compiler can use type inference to solves the data types for you, easing some of the burden that you carry as a developer. The most commom way this happens is through function arguments that receives struct objects as input.\nIn general, type inference in Zig is done by using the dot character (.). Everytime you see a dot character written before a struct literal, or before a enum value, or something like that, you know that this dot character is playing a special party in this place. More specifically, it is telling the zig compiler something on the lines of: ‚ÄúHey! Can you infer the type of this value for me? Please!‚Äù. In other words, this dot character is playing a role similar to the auto keyword in C++.\nI give you some examples of this at Section 1.11, where we present anonymous struct literals. Because anonymous struct literals are, essentially, struct literals that use type inference to infer the exact type of this particular struct literal. This type inference is done by looking for some minimal hint of the correct data type to be used. You could say that the zig compiler looks for any neighbouring type annotation that might tell him what would be the correct type.\nAnother commom place where we use type inference in Zig is at switch statements (which we talk about at Section 1.9.2). Take a look at this fence() function, which comes from the atomic.zig module16 from the Zig Standard Library.\nThere are a lot of things in this function that we haven‚Äôt talked about yet, such as: what comptime means? inline? extern? What is this star symbol before Self? Let‚Äôs just ignore all of these things, and focus solely on the switch statement that is inside this function.\nWe can see that this switch statement uses the order object as input. This order object is one of the inputs of this fence() function, and we can see in the type annotation, that this object is of type AtomicOrder. We can also see a bunch of values inside the switch statements that begins with a dot character, such as .release and .acquire.\nBecause these weird values contain a dot character before them, we are asking the zig compiler to infer the types of these values inside the switch statement. Then, the zig compiler is looking into the current context where these values are being used, and it is trying to infer the types of these values.\nSince they are being used inside a switch statement, the zig compiler looks into the type of the input object given to the switch statement, which is the order object in this case. Because this object have type AtomicOrder, the zig compiler infers that these values are data members from this type AtomicOrder.\n\npub inline fn fence(self: *Self, comptime order: AtomicOrder) void {\n    // LLVM's ThreadSanitizer doesn't support the normal fences so we specialize for it.\n    if (builtin.sanitize_thread) {\n        const tsan = struct {\n            extern \"c\" fn __tsan_acquire(addr: *anyopaque) void;\n            extern \"c\" fn __tsan_release(addr: *anyopaque) void;\n        };\n\n        const addr: *anyopaque = self;\n        return switch (order) {\n            .unordered, .monotonic =&gt; @compileError(@tagName(order) ++ \" only applies to atomic loads and stores\"),\n            .acquire =&gt; tsan.__tsan_acquire(addr),\n            .release =&gt; tsan.__tsan_release(addr),\n            .acq_rel, .seq_cst =&gt; {\n                tsan.__tsan_acquire(addr);\n                tsan.__tsan_release(addr);\n            },\n        };\n    }\n\n    return @fence(order);\n}\n\nThis is how basic type inference is done in Zig. If we didn‚Äôt use the dot character before the values inside this switch statement, then, we would be forced to write explicitly the types of these values. For example, instead of writing .release we would have to write AtomicOrder.release. We would have to do this for every single value in this switch statement, and this is kind of painful. That is why type inference is commonly used on switch statements in Zig.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-zig-control-flow",
    "href": "Chapters/01-zig-weird.html#sec-zig-control-flow",
    "title": "1¬† Introducing Zig",
    "section": "1.9 Control flow",
    "text": "1.9 Control flow\nSometimes, you need to make decisions in your program. Maybe you need to decide wether to execute or not a specific piece of code. Or maybe, you need to apply the same operation over a sequence of values. These kinds of tasks, involve using structures that are capable of changing the ‚Äúcontrol flow‚Äù of our program.\nIn computer science, the term ‚Äúcontrol flow‚Äù usually refers to the order in which expressions (or commands) are evaluated in a given language or program. But this term is also used to refer to structures that are capable of changing this ‚Äúevaluation order‚Äù of the commands executed by a given language/program.\nThese structures are better known by a set of terms, such as: loops, if/else statements, switch statements, among others. So, loops and if/else statements are examples of structures that can change the ‚Äúcontrol flow‚Äù of our program. The keywords continue and break are also examples of symbols that can change the order of evaluation, since they can move our program to the next iteration of a loop, or make the loop stop completely.\n\n1.9.1 If/else statements\nAn if/else statement performs an ‚Äúconditional flow operation‚Äù. A conditional flow control (or choice control) allows you to execute or ignore a certain block of commands based on a logical condition. Many programmers and computer science professionals also use the term ‚Äúbranching‚Äù in this case. In essence, we use if/else statements to use the result of a logical test to decide whether or not to execute a given block of commands.\nIn Zig, we write if/else statements by using the keywords if and else. We start with the if keyword followed by a logical test inside a pair of parentheses, and then, a pair of curly braces with contains the lines of code to be executed in case the logical test returns the value true.\nAfter that, you can optionally add an else statement. Just add the else keyword followed by a pair of curly braces, with the lines of code to executed in case the logical test defined in the if returns false.\nIn the example below, we are testing if the object x contains a number that is greater than 10. Judging by the output printed to the console, we know that this logical test returned false. Because the output in the console is compatible with the line of code present in the else branch of the if/else statement.\n\nconst x = 5;\nif (x &gt; 10) {\n    try stdout.print(\n        \"x &gt; 10!\\n\", .{}\n    );\n} else {\n    try stdout.print(\n        \"x &lt;= 10!\\n\", .{}\n    );\n}\n\nx &lt;= 10!\n\n\n\n\n1.9.2 Swith statements\nSwitch statements are also available in Zig. A switch statement in Zig have a similar syntax to a switch statement in Rust. As you would expect, to write a switch statement in Zig we use the switch keyword. We provide the value that we want to ‚Äúswitch over‚Äù inside a pair of parentheses. Then, we list the possible combinations (or ‚Äúbranchs‚Äù) inside a pair of curly braces.\nLet‚Äôs take a look at the code example below. You can see in this example that, I‚Äôm creating an enum type called Role. We talk more about enums at Section 6.6. But in essence, this Role type is listing different types of roles in a fictituous company, like SE for Software Engineer, DE for Data Engineer, PM for Product Manager, etc.\nNotice that we are using the value from the role object in the switch statement, to discover which exact area we need to store in the area variable object. Also notice that we are using type inference inside the switch statement, with the dot character, as we described at Section 1.8. This makes the zig compiler infer the correct data type of the values (PM, SE, etc.) for us.\nAlso notice that, we are grouping multiple values in the same branch of switch statement. We just separate each possible value with a comma. So, for example, if role contains either DE or DA, the area variable would contain the value \"Data & Analytics\", instead of \"Platform\".\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst Role = enum {\n    SE, DPE, DE, DA, PM, PO, KS\n};\n\npub fn main() !void {\n    var area: []const u8 = undefined;\n    const role = Role.SE;\n    switch (role) {\n        .PM, .SE, .DPE, .PO =&gt; {\n            area = \"Platform\";\n        },\n        .DE, .DA =&gt; {\n            area = \"Data & Analytics\";\n        },\n        .KS =&gt; {\n            area = \"Sales\";\n        },\n    }\n    try stdout.print(\"{s}\\n\", .{area});\n}\n\nPlatform\n\n\nNow, one very important aspect about this switch statement presented in the code example above, is that it exhaust all existing possibilities. In other words, all possible values that could be found inside the order object are explicitly handled in this switch statement.\nSince the role object have type Role, the only possible values to be found inside this object are PM, SE, DPE, PO, DE, DA and KS. There is no other possible value to be stored in this role object. This what ‚Äúexhaust all existing possibilities‚Äù means. The switch statement covers every possible case.\nIn Zig, switch statements must exhaust all existing possibilities. You cannot write a switch statement, and leave an edge case with no expliciting action to be taken. This is a similar behaviour to switch statements in Rust, which also have to handle all possible cases.\nTake a look at the dump_hex_fallible() function below as an example. This function also comes from the Zig Standard Library, but this time, it comes from the debug.zig module17. There are multiple lines in this function, but I omitted them to focus solely on the switch statement found in this function. Notice that this switch statement have four possible cases, or four explicit branches. Also, notice that we used an else branch in this case. Whenever you have multiple possible cases in your switch statement which you want to apply the same exact action, you can use an else branch to do that.\n\npub fn dump_hex_fallible(bytes: []const u8) !void {\n    // Many lines ...\n    switch (byte) {\n        '\\n' =&gt; try writer.writeAll(\"‚êä\"),\n        '\\r' =&gt; try writer.writeAll(\"‚êç\"),\n        '\\t' =&gt; try writer.writeAll(\"‚êâ\"),\n        else =&gt; try writer.writeByte('.'),\n    }\n}\n\nMany users would also use an else branch to handle a ‚Äúnot supported‚Äù case. That is, a case that cannot be properly handled by your code, or, just a case that should not be ‚Äúfixed‚Äù. So many programmers use an else branch to panic (or raise an error) to stop the current execution.\nTake the code example below as an example. We can see that, we are handling the cases for the level object being either 1, 2, or 3. All other possible cases are not supported by default, and, as consequence, we raise an runtime error in these cases, through the @panic() built-in function.\nAlso notice that, we are assigning the result of the switch statement to a new object called category. This is another thing that you can do with switch statements in Zig. If the branchs in this switch statement output some value as result, you can store the result value of the switch statement into a new variable.\n\nconst level: u8 = 4;\nconst category = switch (level) {\n    1, 2 =&gt; \"beginner\",\n    3 =&gt; \"professional\",\n    else =&gt; {\n        @panic(\"Not supported level!\");\n    },\n};\ntry stdout.print(\"{s}\\n\", .{category});\n\nthread 13103 panic: Not supported level!\nt.zig:9:13: 0x1033c58 in main (switch2)\n            @panic(\"Not supported level!\");\n            ^\nFurthermore, you can also use ranges of values in switch statements. That is, you can create a branch in your switch statement that is used whenever the input value is contained in a range. These range expressions are created with the operator .... Is important to emphasize that the ranges created by this operator are inclusive on both ends.\nFor example, I could easily change the code example above to support all levels between 0 and 100. Like this:\n\nconst level: u8 = 4;\nconst category = switch (level) {\n    0...25 =&gt; \"beginner\",\n    26...75 =&gt; \"intermediary\",\n    76...100 =&gt; \"professional\",\n    else =&gt; {\n        @panic(\"Not supported level!\");\n    },\n};\ntry stdout.print(\"{s}\\n\", .{category});\n\nbeginner\n\n\nThis is neat, and it works with character ranges too. That is, I could simply write 'a'...'z', to match any character value that is a lowercase letter, and it would work fine.\n\n\n1.9.3 For loops\nA loop allows you to execute the same lines of code multiple times, thus, creating a ‚Äúrepetition space‚Äù in the execution flow of your program. Loops are particularly useful when we want to replicate the same function (or the same set of commands) over several different inputs.\nThere are different types of loops available in Zig. But the most essential of them all is probably the for loop. A for loop is used to apply the same piece of code over the elements of a slice or an array.\nFor loops in Zig have a slightly different syntax that you are probably used to see in other languages. You start with the for keyword, then, you list the items that you want to iterate over inside a pair of parentheses. Then, inside of a pair of pipes (|) you should declare an identifier that will serve as your iterator, or, the ‚Äúrepetition index of the loop‚Äù.\n\nfor (items) |value| {\n    // code to execute\n}\n\nInstead of using a (value in items) syntax, in Zig, for loops use the syntax (items) |value|. In the example below, you can see that we are looping through the items of the array stored at the object name, and printing to the console the decimal representation of each character in this array.\nIf we wanted, we could also iterate through a slice (or a portion) of the array, instead of iterating through the entire array stored in the name object. Just use a range selector to select the section you want. For example, I could provide the expression name[0..3] to the for loop, to iterate just through the first 3 elements in the array.\n\nconst name = [_]u8{'P','e','d','r','o'};\nfor (name) |char| {\n    try stdout.print(\"{d} | \", .{char});\n}\n\n80 | 101 | 100 | 114 | 111 | \n\n\nIn the above example we are using the value itself of each element in the array as our iterator. But there are many situations where we need to use an index instead of the actual values of the items.\nYou can do that by providing a second set of items to iterate over. More precisely, you provide the range selector 0.. to the for loop. So, yes, you can use two different iterators at the same time in a for loop in Zig.\nBut remember from Section 1.4 that, every object you create in Zig must be used in some way. So if you declare two iterators in your for loop, you must use both iterators inside the for loop body. But if you want to use just the index iterator, and not use the ‚Äúvalue iterator‚Äù, then, you can discard the value iterator by maching the value items to the underscore character, like in the example below:\n\nfor (name, 0..) |_, i| {\n    try stdout.print(\"{d} | \", .{i});\n}\n\n0 | 1 | 2 | 3 | 4 |\n\n\n1.9.4 While loops\nA while loop is created from the while keyword. While a for loop iterates through the items of an array, a while loop will loop continuously, and infinitely, until a logical test (specified by you) becomes false.\nYou start with the while keyword, then, you define a logical expression inside a pair of parentheses, and the body of the loop is provided inside a pair of curly braces, like in the example below:\n\nvar i: u8 = 1;\nwhile (i &lt; 5) {\n    try stdout.print(\"{d} | \", .{i});\n    i += 1;\n}\n\n1 | 2 | 3 | 4 | \n\n\n\n\n1.9.5 Using break and continue\nIn Zig, you can explicitly stop the execution of a loop, or, jump to the next iteration of the loop, using the keywords break and continue, respectively. The while loop present in the example below, is at first sight, an infinite loop. Because the logical value inside the parenthese will always be equal to true. What makes this while loop stop when the i object reaches the count 10? Is the break keyword!\nInside the while loop, we have an if statement that is constantly checking if the i variable is equal to 10. Since we are increasing the value of this i variable at each iteration of the while loop. At some point, this i variable will be equal to 10, and when it does, the if statement will execute the break expression, and, as a result, the execution of the while loop is stopped.\nNotice the expect() function from the Zig standard library after the while loop. This expect() function is an ‚Äúassert‚Äù type of function. This function checks if the logical test provided is equal to true. If this logical test is false, the function raises an assertion error. But it is equal to true, then, the function will do nothing.\n\nvar i: usize = 0;\nwhile (true) {\n    if (i == 10) {\n        break;\n    }\n    i += 1;\n}\ntry std.testing.expect(i == 10);\ntry stdout.print(\"Everything worked!\", .{});\n\nEverything worked!\n\n\nSince this code example was executed succesfully by the zig compiler, without raising any errors, then, we known that, after the execution of while loop, the i variable is equal to 10. Because if it wasn‚Äôt equal to 10, then, an error would be raised by expect().\nNow, in the next example, we have an use case for the continue keyword. The if statement is constantly checking if the current index is a multiple of 2. If it is, then we jump to the next iteration of the loop directly. But it the current index is not a multiple of 2, then, the loop will simply print this index to the console.\n\nconst ns = [_]u8{1,2,3,4,5,6};\nfor (ns) |i| {\n    if ((i % 2) == 0) {\n        continue;\n    }\n    try stdout.print(\"{d} | \", .{i});\n}\n\n1 | 3 | 5 |",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-structs-and-oop",
    "href": "Chapters/01-zig-weird.html#sec-structs-and-oop",
    "title": "1¬† Introducing Zig",
    "section": "1.10 Structs and OOP",
    "text": "1.10 Structs and OOP\nZig is a language more closely related to C (which is a procedural language), than it is to C++ or Java (which are object-oriented languages). Because of that, you do not have advanced OOP (Object-Oriented Programming) patterns available in Zig, such as classes, interfaces or class inheritance. Nonetheless, OOP in Zig is still possible by using struct definitions.\nWith struct definitions, you can create (or define) a new data type in Zig. These struct definitions work the same way as they work in C. You give a name to this new struct (or, to this new data type you are creating), then, you list the data members of this new struct. You can also register functions inside this struct, and they become the methods of this particular struct (or data type), so that, every object that you create with this new type, will always have these methods available and associated with them.\nIn C++, when we create a new class, we normally have a constructor method (or, a constructor function) to construct or to instantiate every object of this particular class, and you also have a destructor method (or a destructor function) that is the function responsible for destroying every object of this class.\nIn Zig, we normally declare the constructor and the destructor methods of our structs, by declaring an init() and a deinit() methods inside the struct. This is just a naming convention that you will find across the entire Zig standard library. So, in Zig, the init() method of a struct is normally the constructor method of the class represented by this struct. While the deinit() method is the method used for destroying an existing instance of that struct.\nBoth the init() and deinit() methods are used extensively in Zig code, and you will see both of them at Section 2.2.7. In this section, I present the ArenaAllocator(), which is a special type of allocator object that receives a second (child) allocator object at instantiation. We use the init() method to create a new ArenaAllocator() object, then, on the next line, we also used the deinit() method in conjunction with the defer keyword, to destroy this arena allocator object at the end of the current scope.\nBut, as another example, let‚Äôs build a simple User struct to represent an user of some sort of system. If you look at the User struct below, you can see the struct keyword, and inside of a pair of curly braces, we write the struct‚Äôs body.\nNotice the data members of this struct, id, name and email. Every data member have it‚Äôs type explicitly annotated, with the colon character (:) syntax that we described earlier at Section 1.2.2. But also notice that every line in the struct body that describes a data member, ends with a comma character (,). So every time you declare a data member in your Zig code, always end the line with a comma character, instead of ending it with the traditional semicolon character (;).\nNext, also notice in this example, that we registrated an init() function as a method of this User struct. This init() method is the constructor method that you use to instantiate every new User object. That is why this init() function return an User object as result.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst User = struct {\n    id: u64,\n    name: []const u8,\n    email: []const u8,\n\n    pub fn init(id: u64,\n                name: []const u8,\n                email: []const u8) User {\n\n        return User {\n            .id = id,\n            .name = name,\n            .email = email\n        };\n    }\n\n    pub fn print_name(self: User) !void {\n        try stdout.print(\"{s}\\n\", .{self.name});\n    }\n};\n\npub fn main() !void {\n    const u = User.init(1, \"pedro\", \"email@gmail.com\");\n    try u.print_name();\n}\n\npedro\n\n\nThe pub keyword plays an important role in struct declarations, and OOP in Zig. Every method that you declare in your struct that is marked with the keyword pub, becomes a public method of this particular struct.\nSo every method that you create in your struct, is, at first, a private method of that struct. Meaning that, this method can only be called from within this struct. But, if you mark this method as public, with the keyword pub, then, you can call the method directly from the User object you have in your code.\nIn other words, the functions marked by the keyword pub are members of the public API of that struct. For example, if I did not marked the print_name() method as public, then, I could not execute the line u.print_name(). Because I would not be authorized to call this method directly in my code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-anonymous-struct-literals",
    "href": "Chapters/01-zig-weird.html#sec-anonymous-struct-literals",
    "title": "1¬† Introducing Zig",
    "section": "1.11 Anonymous struct literals",
    "text": "1.11 Anonymous struct literals\nYou can declare a struct object as a literal value. When we do that, we normally specify the data type of this struct literal by writing it‚Äôs data type just before the opening curly braces. For example, I could write a struct literal of type User that we defined in the previous section like this:\n\nconst eu = User {\n    .id = 1,\n    .name = \"Pedro\",\n    .email = \"someemail@gmail.com\"\n};\n_ = eu;\n\nHowever, in Zig, we can also write an anonymous struct literal. That is, you can write a struct literal, but not especify explicitly the type of this particular struct. An anonymous struct is written by using the syntax .{}. So, we essentially replaced the explicit type of the struct literal with a dot character (.).\nAs we described at Section 1.8, when you put a dot before a struct literal, the type of this struct literal is automatically inferred by the zig compiler. In essence, the zig compiler will look for some hint of what is the type of that struct. It can be the type annotation of an function argument, or the return type annotation of the function that you are using, or the type annotation of a variable. If the compiler do find such type annotation, then, it will use this type in your literal struct.\nAnonymous structs are very commom to use in function arguments in Zig. One example that you have seen already constantly, is the print() function from the stdout object. This function takes two arguments. The first argument, is a template string, which should contain string format specifiers in it, which tells how the values provided in the second argument should be printed into the message.\nWhile the second argument is a struct literal that lists the values to be printed into the template message specified in the first argument. You normally want to use an anonymous struct literal here, so that, the zig compiler do the job of specifying the type of this particular anonymous struct for you.\n\nconst std = @import(\"std\");\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n\nHello, world!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#sec-zig-strings",
    "href": "Chapters/01-zig-weird.html#sec-zig-strings",
    "title": "1¬† Introducing Zig",
    "section": "1.12 How strings work in Zig?",
    "text": "1.12 How strings work in Zig?\nThe first project that we are going to build and discuss in this book is a base64 encoder/decoder (Chapter 3). But in order for us to build such a thing, we need to get a better understanding on how strings work in Zig. So let‚Äôs discuss this specific aspect of Zig.\nIn Zig, a string literal (or a string object if you prefer) is a pointer to a null-terminated array of bytes. Each byte in this array is represented by an u8 value, which is an unsigned 8 bit integer, so, it is equivalent to the C data type unsigned char.\nZig always assumes that this sequence of bytes is UTF-8 encoded. This might not be true for every sequence of bytes you have it, but is not really Zig‚Äôs job to fix the encoding of your strings (you can use iconv18 for that). Today, most of the text in our modern world, specially on the web, should be UTF-8 encoded. So if your string literal is not UTF-8 encoded, then, you will likely have problems in Zig.\nLet‚Äôs take for example the word ‚ÄúHello‚Äù. In UTF-8, this sequence of characters (H, e, l, l, o) is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In xecadecimal, this sequence is 0x48, 0x65, 0x6C, 0x6C, 0x6F. So if I take this sequence of hexadecimal values, and ask Zig to print this sequence of bytes as a sequence of characters (i.e.¬†a string), then, the text ‚ÄúHello‚Äù will be printed into the terminal:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};\n    try stdout.print(\"{s}\\n\", .{bytes});\n}\n\nHello\n\n\nIf you want to see the actual bytes that represents a string in Zig, you can use a for loop to iterate trough each byte in the string, and ask Zig to print each byte as an hexadecimal value to the terminal. You do that by using a print() statement with the X formatting specifier, like you would normally do with the printf() function19 in C.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_literal) |byte| {\n        try stdout.print(\"{X} \", .{byte});\n    }\n    try stdout.print(\"\\n\", .{});\n}\n\nBytes that represents the string object: 54 68 69 \n   73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65 20 6F\n  F 66 20 73 74 72 69 6E 67 20 6C 69 74 65 72 61 6C 2\n  20 69 6E 20 5A 69 67 \n\n\n\n1.12.1 Strings in C\nAt first glance, this looks very similar to how C treats strings as well. That is, string values in C are also treated internally as an array of bytes, and this array is also null-terminated.\nBut one key difference between a Zig string and a C string, is that Zig also stores the length of the array inside the string object. This small detail makes your code safer, because is much easier for the Zig compiler to check if you are trying to access an element that is ‚Äúout of bounds‚Äù, i.e.¬†if your trying to access memory that does not belong to you.\nTo achieve this same kind of safety in C, you have to do a lot of work that kind of seems pointless. So getting this kind of safety is not automatic and much harder to do in C. For example, if you want to track the length of your string troughout your program in C, then, you first need to loop through the array of bytes that represents this string, and find the null element ('\\0') position to discover where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.\nTo do that, you would need something like this in C. In this example, the C string stored in the object array is 25 bytes long:\n#include &lt;stdio.h&gt;\nint main() {\n    char* array = \"An example of string in C\";\n    int index = 0;\n    while (1) {\n        if (array[index] == '\\0') {\n            break;\n        }\n        index++;\n    }\n    printf(\"Number of elements in the array: %d\\n\", index);\n}\nNumber of elements in the array: 25\nBut in Zig, you do not have to do this, because the object already contains a len field which stores the length information of the array. As an example, the string_literal object below is 43 bytes long:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    try stdout.print(\"{d}\\n\", .{string_literal.len});\n}\n\n43\n\n\n\n\n1.12.2 A better look at the object type\nNow, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the @TypeOf() function. If we look at the type of the simple_array object below, you will find that this object is a array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type i32 in Zig. That is what an object of type [4]i32 is.\nBut if we look closely at the type of the string_literal object below, you will find that this object is a constant pointer (hence the *const annotation) to an array of 43 elements (or 43 bytes). Each element is a single byte (more precisely, an unsigned 8 bit integer - u8), that is why we have the [43:0]u8 portion of the type below. In other words, the string stored inside the string_literal object is 43 bytes long. That is why you have the type *const [43:0]u8 below.\nIn the case of string_literal, it is a constant pointer (*const) because the object string_literal is declared as constant in the source code (in the line const string_literal = ...). So, if we changed that for some reason, if we declare string_literal as a variable object (i.e.¬†var string_literal = ...), then, string_literal would be just a normal pointer to an array of unsigned 8-bit integers (i.e.¬†* [43:0]u8).\nNow, if we create an pointer to the simple_array object, then, we get a constant pointer to an array of 4 elements (*const [4]i32), which is very similar to the type of the string_literal object. This demonstrates that a string object (or a string literal) in Zig is already a pointer to an array.\nJust remember that a ‚Äúpointer to an array‚Äù is different than an ‚Äúarray‚Äù. So a string object in Zig is a pointer to an array of bytes, and not simply an array of bytes.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"This is an example of string literal in Zig\";\n    const simple_array = [_]i32{1, 2, 3, 4};\n    try stdout.print(\"Type of array object: {}\", .{@TypeOf(simple_array)});\n    try stdout.print(\n        \"Type of string object: {}\",\n        .{@TypeOf(string_literal)}\n    );\n    try stdout.print(\n        \"Type of a pointer that points to the array object: {}\",\n        .{@TypeOf(&simple_array)}\n    );\n}\n\nType of array object: [4]i32\nType of string object: *const [43:0]u8\nType of a pointer that points to\n    the array object: *const [4]i32\n\n\n1.12.3 Byte vs unicode points\nIs important to point out that each byte in the array is not necessarily a single character. This fact arises from the difference between a single byte and a single unicode point.\nThe encoding UTF-8 works by assigning a number (which is called a unicode point) to each character in the string. For example, the character ‚ÄúH‚Äù is stored in UTF-8 as the decimal number 72. This means that the number 72 is the unicode point for the character ‚ÄúH‚Äù. Each possible character that can appear in a UTF-8 encoded string have its own unicode point.\nFor example, the Latin Capital Letter A With Stroke (»∫) is represented by the number (or the unicode point) 570. However, this decimal number (570) is higher than the maximum number stored inside a single byte, which is 255. In other words, the maximum decimal number that can be represented with a single byte is 255. That is why, the unicode point 570 is actually stored inside the computer‚Äôs memory as the bytes C8 BA.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const string_literal = \"»∫\";\n    try stdout.print(\"Bytes that represents the string object: \", .{});\n    for (string_literal) |char| {\n        try stdout.print(\"{X} \", .{char});\n    }\n}\n\nBytes that represents the string object: C8 BA \n\n\nThis means that to store the character »∫ in an UTF-8 encoded string, we need to use two bytes together to represent the number 570. That is why the relationship between bytes and unicode points is not always 1 to 1. Each unicode point is a single character in the string, but not always a single byte corresponds to a single unicode point.\nAll of this means that if you loop trough the elements of a string in Zig, you will be looping through the bytes that represents that string, and not through the characters of that string. In the »∫ example above, the for loop needed two iterations (instead of a single iteration) to print the two bytes that represents this »∫ letter.\nNow, all english letters (or ASCII letters if you prefer) can be represented by a single byte in UTF-8. As a consequence, if your UTF-8 string contains only english letters (or ASCII letters), then, you are lucky. Because the number of bytes will be equal to the number of characters in that string. In other words, in this specific situation, the relationship between bytes and unicode points is 1 to 1.\nBut on the other side, if your string contains other types of letters‚Ä¶ for example, you might be working with text data that contains, chinese, japanese or latin letters, then, the number of bytes necessary to represent your UTF-8 string will likely be much higher than the number of characters in that string.\nIf you need to iterate through the characters of a string, instead of its bytes, then, you can use the std.unicode.Utf8View struct to create an iterator that iterates through the unicode points of your string.\nIn the example below, we loop through the japanese characters ‚Äú„Ç¢„É°„É™„Ç´‚Äù. Each of the four characters in this string is represented by three bytes. But the for loop iterates four times, one iteration for each character/unicode point in this string:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    var utf8 = (\n        (try std.unicode.Utf8View.init(\"„Ç¢„É°„É™„Ç´\"))\n            .iterator()\n    );\n    while (utf8.nextCodepointSlice()) |codepoint| {\n        try stdout.print(\n            \"got codepoint {}\\n\",\n            .{std.fmt.fmtSliceHexUpper(codepoint)}\n        );\n    }\n}\n\ngot codepoint E382A2\ngot codepoint E383A1\ngot codepoint E383AA\ngot codepoint E382AB",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#other-parts-of-zig",
    "href": "Chapters/01-zig-weird.html#other-parts-of-zig",
    "title": "1¬† Introducing Zig",
    "section": "1.13 Other parts of Zig",
    "text": "1.13 Other parts of Zig\nWe already learned a lot about Zig‚Äôs syntax, and also, some pretty technical details about it. Just as a quick recap:\n\nWe talked about how functions are written in Zig at Section 1.2.2 and Section 1.2.3.\nHow to create new objects/identifiers at Section 1.2.2 and specially at Section 1.4.\nBasic control flow syntax at Section 1.9.\nHow strings work in Zig at Section 1.12.\nHow to use arrays and slices at Section 1.6.\nHow to import functionality from other Zig modules at Section 1.2.2.\nHow Object-Oriented programming can be done in Zig through Struct declarations at Section 1.10.\n\nBut, for now, this amount of knowledge is enough for us to continue with this book. Later, over the next chapters we will still talk more about other parts of Zig‚Äôs syntax that are also equally important as the other parts. Such as:\n\nEnums at Section 6.6;\nPointers and Optionals at Chapter 5;\nError handling with try and catch;\nUnit tests at Chapter 7;\nVectors;\nBuild System at Chapter 8;\n\n\n\n\n\nSobeston. 2024. ‚ÄúZig Guide.‚Äù https://zig.guide/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-zig-weird.html#footnotes",
    "href": "Chapters/01-zig-weird.html#footnotes",
    "title": "1¬† Introducing Zig",
    "section": "",
    "text": "New programming languages in general, take years and years to be developed.‚Ü©Ô∏é\nhttps://ziglang.org/learn/overview/#zig-build-system.‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/tree/master/lib/std‚Ü©Ô∏é\nhttps://github.com/oven-sh/bun.‚Ü©Ô∏é\nhttps://github.com/hexops/mach‚Ü©Ô∏é\nhttps://github.com/cgbur/llama2.zig/tree/main‚Ü©Ô∏é\nhttps://github.com/tigerbeetle/tigerbeetle‚Ü©Ô∏é\nhttps://github.com/Hejsil/zig-clap‚Ü©Ô∏é\nhttps://github.com/capy-ui/capy‚Ü©Ô∏é\nhttps://github.com/zigtools/zls‚Ü©Ô∏é\nhttps://github.com/mitchellh/libxev‚Ü©Ô∏é\nhttps://codeberg.org/ziglings/exercises/.‚Ü©Ô∏é\nhttps://www.youtube.com/watch?v=OPuztQfM3Fg&t=2524s&ab_channel=TheVimeagen.‚Ü©Ô∏é\nhttps://adventofcode.com/‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/#Primitive-Types.‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/atomic.zig.‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/debug.zig‚Ü©Ô∏é\nhttps://www.gnu.org/software/libiconv/‚Ü©Ô∏é\nhttps://cplusplus.com/reference/cstdio/printf/‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introducing Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html",
    "href": "Chapters/01-memory.html",
    "title": "2¬† Memory and Allocators in Zig",
    "section": "",
    "text": "2.1 Memory spaces\nEvery object that you create in your Zig source code needs to be stored somewhere, in your computer‚Äôs memory. Depending on where and how you define your object, Zig will use a different ‚Äúmemory space‚Äù, or a different type of memory to store this object.\nEach type of memory normally serves for different purposes. In Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#memory-spaces",
    "href": "Chapters/01-memory.html#memory-spaces",
    "title": "2¬† Memory and Allocators in Zig",
    "section": "",
    "text": "Global data register (or the ‚Äúglobal data section‚Äù);\nStack;\nHeap;\n\n\n2.1.1 Compile-time known versus runtime known\nOne strategy that Zig uses to decide where it will store each object that you declare, is by looking at the value of this particular object. More specifically, by investigating if this value is known at ‚Äúcompile-time‚Äù or at ‚Äúruntime‚Äù.\nWhen you write a program in Zig, the values of some of the objects that you write in your program are known at compile time. Meaning that, when you compile your Zig source code, during the compilation process, the zig compiler can figure it out what is the exact value of a particular object that exists in your source code. Knowing the length (or the size) of each object is also important. So the length (or the size) of each object that you write in your program is, in some cases, known at compile time.\nThe zig compiler cares more about knowing the length (or the size) of a particular object , than to know it‚Äôs actual value. But, if the zig compiler knows the value of the object, then, it automatically knows the size of this object. Because it can simply calculate the size of the object by looking at the size of the value.\nTherefore, the priority for the zig compiler is to discover the size of each object in your source code. If the value of the object in question is known at compile-time, then, the zig compiler automatically knows the size/length of this object. But if the value of this object is not known at compile-time, then, the size of this object is only known at compile-time if, and only if, the type of this object have a known fixed size.\nIn order to a type have a known fixed size, this type must have data members whose size is fixed. If this type includes, for example, a variable sized array in it, then, this type do not have a known fixed size. Because this array can have any size at runtime (i.e.¬†it can be an array of 2 elements, or 50 elements, or 1 thousand elements, etc.).\nFor example, a string object, which internally is an array of constant u8 values ([]const u8) have a variable size. It can be a string object with 100 or 500 characters in it. If we do not know at compile-time, which exact string will be stored inside this string object, then, we cannot calculate the size of this string object at compile-time. So, any type, or any struct declaration that you make, that includes a string data member that do not have an explicit fixed size, makes this type, or this new struct that you are declaring, a type that do not have a known fixed size at compile-time.\nIn contrast, if the type or this struct that you are declaring, includes a data member that is an array, but this array have a known fixed size, like [60]u8 (which declares an array of 60 u8 values), then, this type, or, this struct that you are declaring, becomes a type with a known fixed size at compile-time. And because of that, in this case, the zig compiler do not need to known at compile-time the exact value of any object of this type. Since the compiler can find the necessary size to store this object by looking at the size of it‚Äôs type.\nLet‚Äôs look at an example. In the source code below, we have two constant objects (name and array) declared. Because the values of these particular objects are written down, in the source code itself (\"Pedro\" and the number sequence from 1 to 4), the zig compiler can easily discover the values of these constant objects (name and array) during the compilation process. This is what ‚Äúknown at compile time‚Äù means. It refers to any object that you have in your Zig source code whose value can be identified at compile time.\n\nconst name = \"Pedro\";\nconst array = [_]u8{1, 2, 3, 4};\n_ = name; _ = array;\n\nfn input_length(input: []const u8) usize {\n    const n = input.len;\n    return n;\n}\n\nThe other side of the spectrum are objects whose values are not known at compile time. Function arguments are a classic example of this. Because the value of each function argument depends on the value that you assign to this particular argument, when you call the function.\nFor example, the function input_length() contains an argument named input, which is an array of constant u8 integers ([]const u8). Is impossible to know at compile time the value of this particular argument. And it also is impossible to know the size/length of this particular argument. Because it is an array that do not have a fixed size specified explicitly in the argument type annotation.\nSo, we know that this input argument will be an array of u8 integers. But we do not know at compile-time, it‚Äôs value, and neither his size. This information is known only at runtime, which is the period of time when you program is executed. As a consequence, the value of the expression input.len is also known only at runtime. This is an intrinsic characteristic of any function. Just remember that the value of function arguments is usually not ‚Äúcompile-time known‚Äù.\nHowever, as I mentioned earlier, what really matters to the compiler is to know the size of the object at compile-time, and not necessarily it‚Äôs value. So, although we don‚Äôt know the value of the object n, which is the result of the expression input.len, at compile-time, we do know it‚Äôs size. Because the expression input.len always return a value of type usize, and the type usize have a known fixed size.\n\n\n2.1.2 Global data register\nThe global data register is a specific section of the executable of your Zig program, that is responsible for storing any value that is known at compile time.\nEvery constant object whose value is known at compile time that you declare in your source code, is stored in the global data register. Also, every literal value that you write in your source code, such as the string \"this is a string\", or the integer 10, or a boolean value such as true, is also stored in the global data register.\nHonestly, you don‚Äôt need to care much about this memory space. Because you can‚Äôt control it, you can‚Äôt deliberately access it or use it for your own purposes. Also, this memory space does not affect the logic of your program. It simply exists in your program.\n\n\n2.1.3 Stack vs Heap\nIf you are familiar with system‚Äôs programming, or just low-level programming in general, you probably have heard of the ‚Äúduel‚Äù between Stack vs Heap. These are two different types of memory, or different memory spaces, which are both available in Zig.\nThese two types of memory don‚Äôt actually duel with each other. This is a commom mistake that beginners have, when seeing ‚Äúx vs y‚Äù styles of tabloid headlines. These two types of memory are actually complementary to each other. So, in almost every Zig program that you ever write, you will likely use a combination of both. I will describe each memory space in detail over the next sections. But for now, I just want to stablish the main difference between these two types of memory.\nIn essence, the stack memory is normally used to store values whose length is fixed and known at compile time. In contrast, the heap memory is a dynamic type of memory space, meaning that, it is used to store values whose length might grow during the execution (runtime) of your program (Chen and Guo 2022).\nLengths that grow during runtime are intrinsically associated with ‚Äúruntime known‚Äù type of values. In other words, if you have an object whose length might grow during runtime, then, the length of this object becomes not known at compile time. If the length is not known at compile-time, the value of this object also becomes not known at compile-time. These types of objects should be stored in the heap memory space, which is a dynamic memory space, which can grow or shrink to fit the size of your objects.\n\n\n2.1.4 Stack\nThe stack is a type of memory that uses the power of the stack data structure, hence the name. A ‚Äústack‚Äù is a type of data structure that uses a ‚Äúlast in, first out‚Äù (LIFO) mechanism to store the values you give it to. I imagine you are familiar with this data structure. But, if you are not, the Wikipedia page1 , or, the Geeks For Geeks page2 are both excellent and easy resources to fully understand how this data structure works.\nSo, the stack memory space is a type of memory that stores values using a stack data structure. It adds and removes values from the memory by following a ‚Äúlast in, first out‚Äù (LIFO) principle.\nEvery time you make a function call in Zig, an amount of space in the stack is reserved for this particular function call (Chen and Guo 2022; Zig Software Foundation 2024). The value of each function argument given to the function in this function call is stored in this stack space. Also, every local object that you declare inside the function scope is usually stored in this same stack space.\nLooking at the example below, the object result is a local object declared inside the scope of the add() function. Because of that, this object is stored inside the stack space reserved for the add() function. The r object (which is declared outside of the add() function scope) is also stored in the stack. But since it is declared in the ‚Äúouter‚Äù scope, this object is stored in the stack space that belongs to this outer scope.\n\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) u8 {\n    const result = x + y;\n    return result;\n}\n\nSo, any object that you declare inside the scope of a function is always stored inside the space that was reserved for that particular function in the stack memory. This also counts for any object declared inside the scope of your main() function for example. As you would expect, in this case, they are stored inside the stack space reserved for the main() function.\nOne very important detail about the stack memory is that it frees itself automatically. This is very important, remember that. When objects are stored in the stack memory, you don‚Äôt have the work (or the responsibility) of freeing/destroying these objects. Because they will be automatically destroyed once the stack space is freed at the end of the function scope.\nSo, once the function call returns (or ends, if you prefer to call it this way) the space that was reserved in the stack is destroyed, and all of the objects that were in that space goes away with it. This mechanism exists because this space, and the objects within it, are not necessary anymore, since the function ‚Äúfinished it‚Äôs business‚Äù. Using the add() function that we exposed above as an example, it means that the object result is automatically destroyed once the function returns.\n\n\n\n\n\n\nImportant\n\n\n\nLocal objects that are stored in the stack space of a function are automatically freed/destroyed at the end of the function scope.\n\n\nThis same logic applies to any other special structure in Zig that have it‚Äôs own scope by surrounding it with curly braces ({}). For loops, while loops, if else statements, etc. For example, if you declare any local object in the scope of a for loop, this local object is accessible only within the scope of this particular for loop. Because once the scope of this for loop ends, the space in the stack reserved for this for loop is freed. The example below demonstrates this idea.\n\n// This does not compile succesfully!\nconst a = [_]u8{0, 1, 2, 3, 4};\nfor (0..a.len) |i| {\n    const index = i;\n    _ = index;\n}\n// Trying to use an object that was\n// declared in the for loop scope,\n// and that does not exist anymore.\nstd.debug.print(\"{d}\\n\", index);\n\nOne important consequence of this mechanism is that, once the function returns, you can no longer access any memory address that was inside the space in the stack reserved for this particular function. Because this space was destroyed. This means that, if this local object is stored in the stack, you cannot make a function that returns a pointer to this object.\nThink about that for a second. If all local objects in the stack are destroyed at the end of the function scope, why would you even consider returning a pointer to one of these objects? This pointer is at best, invalid, or, more likely, ‚Äúundefined‚Äù.\nConclusion, is totally fine to write a function that returns the local object itself as result, because then, you return the value of that object as the result. But, if this local object is stored in the stack, you should never write a function that returns a pointer to this local object. Because the memory address pointed by the pointer no longer exists.\nSo, using again the add() function as an example, if you rewrite this function so that it returns a pointer to the local object result, the zig compiler will actually compile you program, with no warnings or erros. At first glance, it looks that this is good code that works as expected. But this is a lie!\nIf you try to take a look at the value inside of the r object, or, if you try to use this r object in another expression or function call, then, you would have undefined behaviour, and major bugs in your program (Zig Software Foundation 2024, see ‚ÄúLifetime and Ownership‚Äù3 and ‚ÄúUndefined Behaviour‚Äù4 sections).\n\n// This code compiles succesfully. But it has\n// undefined behaviour. Never do this!!!\n\n// The `r` object is undefined!\nconst r = add(5, 27);\n_ = r;\n\nfn add(x: u8, y: u8) *const u8 {\n    const result = x + y;\n    return &result;\n}\n\nThis ‚Äúinvalid pointer to stack variable‚Äù problem is very known across many programming language communities. If you try to do the same thing, for example, in a C or C++ program (i.e.¬†returning an address to a local object stored in the stack), you would also get undefined behaviour in the program.\n\n\n\n\n\n\nImportant\n\n\n\nIf a local object in your function is stored in the stack, you should never return a pointer to this local object from the function. Because this pointer will always become undefined after the function returns, since the stack space of the function is destroyed at the end of it‚Äôs scope.\n\n\nBut what if you really need to use this local object in some way after your function returns? How can you do this? The answer is: ‚Äúin the same you would do if this was a C or C++ program. By returning an address to an object stored in the heap‚Äù. The heap memory have a much more flexible lifecycle, and allows you to get a valid pointer to a local object of a function that already returned from it‚Äôs scope.\n\n\n2.1.5 Heap\nOne important limitation of the stack, is that, only objects whose length/size is known at compile-time can be stored in it. In contrast, the heap is a much more dynamic (and flexible) type of memory. It is the perfect type of memory to use on objects whose size/length might grow during the execution of your program.\nVirtually any application that behaves as a server is a classic use case of the heap. A HTTP server, a SSH server, a DNS server, a LSP server, ‚Ä¶ any type of server. In summary, a server is a type of application that runs for long periods of time, and that serves (or ‚Äúdeals with‚Äù) any incoming request that reaches this particular server.\nThe heap is a good choice for this type of system, mainly because the server does not know upfront how many requests it will receive from users, while it is active. It could be one single request, or, 5 thousand requests, or, it could also be zero requests. The server needs to have the ability to allocate and manage it‚Äôs memory according to how many requests it receives.\nAnother key difference between the stack and the heap, is that the heap is a type of memory that you, the programmer, have complete control over. This makes the heap a more flexible type of memory, but it also makes it harder to work with it. Because you, the programmer, is responsible for managing everything related to it. Including where the memory is allocated, how much memory is allocated, and where this memory is freed.\n\nUnlike stack memory, heap memory is allocated explicitly by programmers and it won‚Äôt be deallocated until it is explicitly freed (Chen and Guo 2022).\n\nTo store an object in the heap, you, the programmer, needs to explicitly tells Zig to do so, by using an allocator to allocate some space in the heap. At Section 2.2, I will present how you can use allocators to allocate memory in Zig.\n\n\n\n\n\n\nImportant\n\n\n\nEvery memory you allocate in the heap needs to be explicitly freed by you, the programmer.\n\n\nThe majority of allocators in Zig do allocate memory on the heap. But some exceptions to this rule are ArenaAllocator() and FixedBufferAllocator(). The ArenaAllocator() is a special type of allocator that works in conjunction with a second type of allocator. On the other side, the FixedBufferAllocator() is an allocator that works based on buffer objects created on the stack. This means that the FixedBufferAllocator() makes allocations only on the stack.\n\n\n2.1.6 Summary\nAfter discussing all of these boring details, we can quickly recap what we learned. In summary, the Zig compiler will use the following rules to decide where each object you declare is stored:\n\nevery literal value (such as \"this is string\", 10, or true) is stored in the global data section.\nevery constant object (const) whose value is known at compile-time is also stored in the global data section.\nevery object (constant or not) whose length/size is known at compile time is stored in the stack space for the current scope.\nif an object is created with the method alloc() or create() of an allocator object, this object is stored in the memory space used by this particular allocator object. Most of allocators available in Zig use the heap memory, so, this object is likely stored in the heap (FixedBufferAllocator() is an exception to that).\nthe heap can only be accessed through allocators. If your object was not created through the alloc() or create() methods of an allocator object, then, he is most certainly not an object stored in the heap.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#sec-allocators",
    "href": "Chapters/01-memory.html#sec-allocators",
    "title": "2¬† Memory and Allocators in Zig",
    "section": "2.2 Allocators",
    "text": "2.2 Allocators\nOne key aspect about Zig, is that there are ‚Äúno hidden-memory allocations‚Äù in Zig. What that really means, is that ‚Äúno allocations happen behind your back in the standard library‚Äù (Sobeston 2024).\nThis is a known problem, specially in C++. Because in C++, there are some operators that do allocate memory behind the scene, and there is no way for you to known that, until you actually read the source code of these operators, and find the memory allocation calls. Many programmers find this behaviour annoying and hard to keep track of.\nBut, in Zig, if a function, an operator, or anything from the standard library needs to allocate some memory during it‚Äôs execution, then, this function/operator needs to receive (as input) an allocator provided by the user, to actually be able to allocate the memory it needs.\nThis creates a clear distinction between functions that ‚Äúdo not‚Äù from those that ‚Äúactually do‚Äù allocate memory. Just look at the arguments of this function. If a function, or operator, have an allocator object as one of it‚Äôs inputs/arguments, then, you know for sure that this function/operator will allocate some memory during it‚Äôs execution.\nAn example is the allocPrint() function from the Zig standard library. With this function, you can write a new string using format specifiers. So, this function is, for example, very similar to the function sprintf() in C. In order to write such new string, the allocPrint() function needs to allocate some memory to store the output string.\nThat is why, the first argument of this function is an allocator object that you, the user/programmer, gives as input to the function. In the example below, I am using the GeneralPurposeAllocator() as my allocator object. But I could easily use any other type of allocator object from the Zig standard library.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nconst name = \"Pedro\";\nconst output = try std.fmt.allocPrint(\n    allocator,\n    \"Hello {s}!!!\",\n    .{name}\n);\ntry stdout.print(\"{s}\\n\", .{output});\n\nHello Pedro!!!\n\n\nYou get a lot of control over where and how much memory this function can allocate. Because it is you, the user/programmer, that provides the allocator for the function to use. This makes ‚Äútotal control‚Äù over memory management easier to achieve in Zig.\n\n2.2.1 What are allocators?\nAllocators in Zig are objects that you can use to allocate memory for your program. They are similar to the memory allocating functions in C, like malloc() and calloc(). So, if you need to use more memory than you initially have, during the execution of your program, you can simply ask for more memory using an allocator.\nZig offers different types of allocators, and they are usually available through the std.heap module of the standard library. So, just import the Zig standard library into your Zig module (with @import(\"std\")), and you can start using these allocators in your code.\nFurthermore, every allocator object is built on top of the Allocator interface in Zig. This means that, every allocator object you find in Zig must have the methods alloc(), create(), free() and destroy(). So, you can change the type of allocator you are using, but you don‚Äôt need to change the function calls to the methods that do the memory allocation (and the free memory operations) for your program.\n\n\n2.2.2 Why you need an allocator?\nAs we described at Section 2.1.4, everytime you make a function call in Zig, a space in the stack is reserved for this function call. But the stack have a key limitation which is: every object stored in the stack have a known fixed length.\nBut in reality, there are two very commom instances where this ‚Äúfixed length limitation‚Äù of the stack is a deal braker:\n\nthe objects that you create inside your function might grow in size during the execution of the function.\nsometimes, it is impossible to know upfront how many inputs you will receive, or how big this input will be.\n\nAlso, there is another instance where you might want to use an allocator, which is when you want to write a function that returns a pointer to a local object. As I described at Section 2.1.4, you cannot do that if this local object is stored in the stack. However, if this object is stored in the heap, then, you can return a pointer to this object at the end of the function. Because you (the programmer) control the lyfetime of any heap memory that you allocate. You decide when this memory get‚Äôs destroyed/freed.\nThese are commom situations where the stack is not good for. That is why you need a different memory management strategy to store these objects inside your function. You need to use a memory type that can grow together with your objects, or that you can control the lyfetime of this memory. The heap fit this description.\nAllocating memory on the heap is commonly known as dynamic memory management. As the objects you create grow in size during the execution of your program, you grow the amount of memory you have by allocating more memory in the heap to store these objects. And you that in Zig, by using an allocator object.\n\n\n2.2.3 The different types of allocators\nAt the moment of the writing of this book, in Zig, we have 6 different allocators available in the standard library:\n\nGeneralPurposeAllocator().\npage_allocator().\nFixedBufferAllocator() and ThreadSafeFixedBufferAllocator().\nArenaAllocator().\nc_allocator() (requires you to link to libc).\n\nEach allocator have it‚Äôs own perks and limitations. All allocators, except FixedBufferAllocator() and ArenaAllocator(), are allocators that use the heap memory. So any memory that you allocate with these allocators, will be placed in the heap.\n\n\n2.2.4 General-purpose allocators\nThe GeneralPurposeAllocator(), as the name suggests, is a ‚Äúgeneral purpose‚Äù allocator. You can use it for every type of task. In the example below, I‚Äôm allocating enough space to store a single integer in the object some_number.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const some_number = try allocator.create(u32);\n    defer allocator.destroy(some_number);\n\n    some_number.* = @as(u32, 45);\n}\n\nWhile useful, you might want to use the c_allocator(), which is a alias to the C standard allocator malloc(). So, yes, you can use malloc() in Zig if you want to. Just use the c_allocator() from the Zig standard library. However, if you do use c_allocator(), you must link to Libc when compiling your source code with the zig compiler, by including the flag -lc in your compilation process. If you do not link your source code to Libc, Zig will not be able to find the malloc() implementation in your system.\n\n\n2.2.5 Page allocator\nThe page_allocator() is an allocator that allocates full pages of memory in the heap. In other words, every time you allocate memory with page_allocator(), a full page of memory in the heap is allocated, instead of just a small piece of it.\nThe size of this page depends on the system you are using. Most systems use a page size of 4KB in the heap, so, that is the amount of memory that is normally allocated in each call by page_allocator(). That is why, page_allocator() is considered a fast, but also ‚Äúwasteful‚Äù allocator in Zig. Because it allocates a big amount of memory in each call, and you most likely will not need that much memory in your program.\n\n\n2.2.6 Buffer allocators\nThe FixedBufferAllocator() and ThreadSafeFixedBufferAllocator() are allocator objects that work with a fixed sized buffer that is stored in the stack. So these two allocators only allocates memory in the stack. This also means that, in order to use these allocators, you must first create a buffer object, and then, give this buffer as an input to these allocators.\nIn the example below, I am creating a buffer object that is 10 elements long. Notice that I give this buffer object to the FixedBufferAllocator() constructor. Now, because this buffer object is 10 elements long, this means that I am limited to this space. I cannot allocate more than 10 elements with this allocator object. If I try to allocate more than that, the alloc() method will return an OutOfMemory error value.\n\nvar buffer: [10]u8 = undefined;\nfor (0..buffer.len) |i| {\n    buffer[i] = 0; // Initialize to zero\n}\n\nvar fba = std.heap.FixedBufferAllocator.init(&buffer);\nconst allocator = fba.allocator();\nconst input = try allocator.alloc(u8, 5);\ndefer allocator.free(input);\n\n\n\n2.2.7 Arena allocator\nThe ArenaAllocator() is an allocator object that takes a child allocator as input. The idea behind the ArenaAllocator() in Zig is similar to the concept of ‚Äúarenas‚Äù in the programming language Go5. It is an allocator object that allows you to allocate memory as many times you want, but free all memory only once. In other words, if you have, for example, called 5 times the method alloc() of an ArenaAllocator() object, you can free all the memory you allocated over these 5 calls at once, by simply calling the deinit() method of the same ArenaAllocator() object.\nIf you give, for example, a GeneralPurposeAllocator() object as input to the ArenaAllocator() constructor, like in the example below, then, the allocations you perform with alloc() will actually be made with the underlying object GeneralPurposeAllocator() that was passed. So, with an arena allocator, any new memory you ask for is allocated by the child allocator. The only thing that an arena allocator really do is helping you to free all the memory you allocated multiple times with just a single command. In the example below, I called alloc() 3 times. So, if I did not used an arena allocator, then, I would need to call free() 3 times to free all the allocated memory.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar aa = std.heap.ArenaAllocator.init(gpa.allocator());\ndefer aa.deinit();\nconst allocator = aa.allocator();\n\nconst in1 = allocator.alloc(u8, 5);\nconst in2 = allocator.alloc(u8, 10);\nconst in3 = allocator.alloc(u8, 15);\n_ = in1; _ = in2; _ = in3;\n\n\n\n2.2.8 The alloc() and free() methods\nIn the code example below, we are accessing the stdin, which is the standard input channel, to receive an input from the user. We read the input given by the user with the readUntilDelimiterOrEof() method.\nNow, after reading the input of the user, we need to store this input somewhere in our program. That is why I use an allocator in this example. I use it to allocate some amount of memory to store this input given by the user. More specifically, the method alloc() of the allocator object is used to allocate an array capable of storing 50 u8 values.\nNotice that this alloc() method receives two inputs. The first one, is a type. This defines what type of values the allocated array will store. In the example below, we are allocating an array of unsigned 8-bit integers (u8). But you can create an array to store any type of value you want. Next, on the second argument, we define the size of the allocated array, by specifying how much elements this array will contain. In the case below, we are allocating an array of 50 elements.\nAt Section 1.12 we described that strings in Zig are simply arrays of characters. Each character is represented by an u8 value. So, this means that the array that was allocated in the object input is capable of storing a string that is 50-characters long.\nSo, in essence, the expression var input: [50]u8 = undefined would create an array for 50 u8 values in the stack of the current scope. But, you can allocate the same array in the heap by using the expression var input = try allocator.alloc(u8, 50).\n\nconst std = @import(\"std\");\nconst stdin = std.io.getStdIn();\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var input = try allocator.alloc(u8, 50);\n    defer allocator.free(input);\n    for (0..input.len) |i| {\n        input[i] = 0; // initialize all fields to zero.\n    }\n    // read user input\n    const input_reader = stdin.reader();\n    _ = try input_reader.readUntilDelimiterOrEof(\n        input,\n        '\\n'\n    );\n    std.debug.print(\"{s}\\n\", .{input});\n}\n\nAlso, notice that in this example, we use the keyword defer to run a small piece of code at the end of the current scope, which is the expression allocator.free(input). When you execute this expression, the allocator will free the memory that it allocated for the input object.\nWe have talked about this at Section 2.1.5. You should always explicitly free any memory that you allocate using an allocator! You do that by using the free() method of the same allocator object you used to allocate this memory. The defer keyword is used in this example only to help us execute this free operation at the end of the current scope.\n\n\n2.2.9 The create() and destroy() methods\nWith the alloc() and free() methods, you can allocate memory to store multiple elements at once. In other words, with these methods, we always allocate an array to store multiple elements at once. But what if you need enough space to store just a single item? Should you allocate an array of a single element through alloc()?\nThe answer is no! In this case, you should use the create() method of the allocator object. Every allocator object offers the create() and destroy() methods, which are used to allocate and free memory for a single item, respectively.\nSo, in essence, if you want to allocate memory to store an array of elements, you should use alloc() and free(). But if you need to store just a single item, then, the create() and destroy() methods are ideal for you.\nIn the example below, I‚Äôm defining a struct to represent an user of some sort. It could be an user for a game, or a software to manage resources, it doesn‚Äôt mater. Notice that I use the create() method this time, to store a single User object in the program. Also notice that I use the destroy() method to free the memory used by this object at the end of the scope.\n\nconst std = @import(\"std\");\nconst User = struct {\n    id: usize,\n    name: []const u8,\n\n    pub fn init(id: usize, name: []const u8) User {\n        return .{ .id = id, .name = name };\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const user = try allocator.create(User);\n    defer allocator.destroy(user);\n\n    user.* = User.init(0, \"Pedro\");\n}\n\n\n\n\n\nChen, Jenny, and Ruohao Guo. 2022. ‚ÄúStack and Heap Memory.‚Äù Introduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nSobeston. 2024. ‚ÄúZig Guide.‚Äù https://zig.guide/.\n\n\nZig Software Foundation. 2024. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#footnotes",
    "href": "Chapters/01-memory.html#footnotes",
    "title": "2¬† Memory and Allocators in Zig",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)‚Ü©Ô∏é\nhttps://www.geeksforgeeks.org/stack-data-structure/‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/#Lifetime-and-Ownership‚Ü©Ô∏é\nhttps://ziglang.org/documentation/master/#Undefined-Behavior‚Ü©Ô∏é\nhttps://go.dev/src/arena/arena.go‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Memory and Allocators in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html",
    "href": "Chapters/01-base64.html",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "",
    "text": "3.1 How the base64 algorithm work?\nNow, how exactly the algorithm behind the base64 encoding works? Let‚Äôs discuss that. First, I will explain the base64 scale, which is the scale of 64 characters that represents the base64 encoding system.\nAfter that, I explain the algorithm behind a base64 encoder, which is the part of the algorithm that is responsible for encoding messages into the base64 encoding system. Then, after that, I explain the algorithm behind a base64 decoder, which is the part of the algorithm that is responsible for translating base64 messages back into their original meaning.\nIf you are unsure about the differences between an ‚Äúencoder‚Äù and a ‚Äúdecoder‚Äù, take a look at Section 3.2.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "href": "Chapters/01-base64.html#how-the-base64-algorithm-work",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "",
    "text": "3.1.1 The base64 scale\nIn essence, the base64 encoding system is based on a scale that goes from 0 to 64 (hence the name). Each index in this scale is represented by a character (it is a scale of 64 characters). So, in order to convert some binary data, to the base64 encoding, we need to convert each binary number to the corresponding character in this ‚Äúscale of 64 characters‚Äù.\nThe base64 scale starts with all ASCII uppercase letters (A to Z) which represents the first 25 indexes in this scale (0 to 25). After that, we have all ASCII lowercase letters (a to z), which represents the range 26 to 51 in the scale. After that, we have the one digit numbers (0 to 9), which represents the indexes from 52 to 61 in the scale. Finally, the last two indexes in the scale (62 and 63) are represented by the characters + and /, respectively.\nThese are the 64 characters that compose the base64 scale. The equal sign character (=) is not part of the scale itself, but it is a special character in the base64 encoding system. This character is used solely as a suffix, to mark the end of the character sequence, or, to mark the end of meaningful characters in the sequence.\nThe bulletpoints below summarises the base64 scale:\n\nrange 0 to 25 is represented by: ASCII uppercase letters -&gt; [A-Z];\nrange 26 to 51 is represented by: ASCII lowercase letters -&gt; [a-z];\nrange 52 to 61 is represented by: one digit numbers -&gt; [0-9];\nindex 62 and 63 are represented by the characters + and /, respectively;\nthe character = represents the end of meaningful characters in the sequence;\n\nEverytime that the base64 algorithm needs to fill some gap (which always occur at the end of the input string) with a group of 6 bits filled with only zeros (000000), this group is automatically mapped to the character =. Because this group of 6 bits is meaningless, they represent nothing, they are just filling the gap. As a result, the base64 algorithm maps this meaningless group to the character =, which represents the end of meaningful characters in the sequence. This characteristic is explained in more details at Section 3.1.3.\n\n\n3.1.2 Creating the scale as a lookup table\nThe best way to represent this scale in code, is to represent it as a lookup table. Lookup tables are a classic strategy in computer science to speed calculations. The basic idea is to replace a runtime calculation (which can take a long time to be done) by a basic array indexing operation.\nInstead of calculating the results everytime you need them, you calculate all possible results at once, and then, you store them in an array (which behaves lake a ‚Äútable‚Äù). Then, every time that you need to use one of the characters in the base64 scale, instead of using many resources to calculate the exact character to be used, you simply retrieve this character from the array where you stored all the possible characters in the base64 scale. So we retrieve the character that we need directly from memory.\nWe can start building a Zig struct to store our base64 decoder/encoder logic. We start with the Base64 struct below. You can see that, for now, we only have an init() function, to create a new instance of a Base64 object, and, a _char_at() function, which is a ‚Äúget chat at index ‚Ä¶‚Äù type of function.\n\nconst Base64 = struct {\n    _table: *const [64]u8,\n\n    pub fn init() Base64 {\n        const upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        const lower = \"abcdefghijklmnopqrstuvwxyz\";\n        const numbers_symb = \"0123456789+/\";\n        return Base64{\n            ._table = upper ++ lower ++ numbers_symb,\n        };\n    }\n\n    pub fn _char_at(self: Base64, index: u8) u8 {\n        return self._table[index];\n    }\n};\n\nIn other words, the _char_at() function is responsible for getting the character in the lookup table (i.e.¬†the _table variable) that corresponds to a particular index in the ‚Äúbase64 scale‚Äù. So, in the example below, we know that the character that corresponds to the index 28 in the ‚Äúbase64 scale‚Äù is the character ‚Äúc‚Äù.\n\nconst base64 = Base64.init();\ntry stdout.print(\n    \"Character at 28 index: {c}\\n\",\n    .{base64._char_at(28)}\n);\n\nCharacter at 28 index: c\n\n\n3.1.3 A base64 encoder\nThe algorithm behind a base64 encoder usually works on a window of 3 bytes. Because each byte have 8 bits, so, 3 bytes forms a set of \\(8 \\times 3 = 24\\) bits. This is desirable for the base64 algorithm, because 24 bits is divisble by 6, which form a set of 4 groups of 6 bits each.\nSo the base64 algorithm work by converting 3 bytes at a time into 4 characters in the base64 scale. It keeps iterating through the input string, 3 bytes at a time, and converting them into the base64 scale, producing 4 characters per iteration. It keeps iterating, and producing these ‚Äúnew characters‚Äù until it hits the end of the input string.\nNow you may think, what if you have a particular string that have a number of bytes that is not divisible by 3? What happens? For example, if you have a string that contains only two characters/bytes, such as ‚ÄúHi‚Äù. How the algorithm behaves in such situation? You find the answer at Figure¬†3.1. You can see at Figure¬†3.1 that the string ‚ÄúHi‚Äù, when converted to base64, becomes the string ‚ÄúSGk=‚Äù:\n\n\n\n\n\n\nFigure¬†3.1: The logic behind a base64 encoder\n\n\n\nIn the example of the string ‚ÄúHi‚Äù we have 2 bytes, or, 16 bits in total. So, we lack a full byte (8 bits) to complete the window of 24 bits that the base64 algorithm likes to work on. In essence, everytime that the algorithm does not meet this requirement, it simply add extra zeros until it fills the space that it needs.\nThat is why at Figure¬†3.1, on the third group after the 6-bit transformation, 2 extra zeros were added to fill the gap in this group, and also, the fourth group (which is the last 6-bit group) is entirely made by zeros that were added by the algorithm.\nSo every time that the base64 algorithm can‚Äôt produce a full group of 6 bits, it simply fills the gap in this group with zeros, until it get‚Äôs the 6 bits that it needs.\nIs worth mentioning that, everytime that the algorithm produces a group of 6 bits that is entirely composed by these extra zeros added by the algorithm, then, this group of 6 bits is automatically mapped to the character = (equal sign). However, notice that a group of 6-bit entirely made by extra zeros, is different than a group of 6-bit entirely made by zeros.\nIn other words, if the algorithm produces a 6-bit group made by zeros, without needing to include extra-zeros to fill any gap, then, this ‚Äúgroup of zeros‚Äù is interpreted as is. In binary, the 6-bit group 000000 simply means zero. So, if we give the index zero to the function _char_at(), this zero index is mapped to the first character in the base64 scale, which is ‚ÄúA‚Äù.\nSo be aware of this important distinction. A group of ‚Äúextra-zeros‚Äù that are ‚Äúfilling the gap‚Äù is different than a group of actual zeros that were calculated by the 6-bit transformation. As an example, if you give the string ‚Äú0‚Äù as input to a base64 encoder, this string is translated into the base64 sequence ‚ÄúMA==‚Äù.\nThe character ‚Äú0‚Äù is, in binary, the sequence 001100001. So, with the 6-bit transformation exposed at Figure¬†3.1, this single character would produce these two 6-bit groups: 001100, 000000. The other two 6-bit groups are entirely made by extra-zeros, and that is why the last two characters in the output sequence (MA==) are ==.\n\n\n3.1.4 A base64 decoder\nThe algorithm behind a base64 decoder is essentially the inverse process of a base64 encoder. A base64 decoder needs to be able to translate base64 messages back into their original meaning, i.e.¬†into the original sequence of binary data.\nA base64 decoder usually works on a window of 4 bytes. Because it wants to convert these 4 bytes back into the original sequence of 3 bytes, that was converted into 4 groups of 6 bits by the base64 encoder. Remember, in a base64 decoder we are essentially reverting the process made by the base64 encoder.\nEach byte in the input string (the base64 encoded string) normally contributes to re-create two different bytes in the output (the original binary data). In other words, each byte that comes out of a base64 decoder is created by transforming merging two different bytes in the input together. You can see this fact at Figure¬†3.2:\n\n\n\n\n\n\nFigure¬†3.2: The logic behind a base64 decoder\n\n\n\nThe exact transformations, or, the exact steps applied to each byte from the input to transform them into the bytes in the output, are a bit tricky to visualize in a figure like this. Because of that, I summarized these transformations as ‚ÄúSome bit shifting and additions ‚Ä¶‚Äù. These transformations will be described in depth later.\nBesides that, if you look again at Figure¬†3.2, you will notice that the character = was completly ignored in the algorithm. Remember, this is just a special character that marks the end of meaninful characters in the base64 sequence. So, every = character in a base64 encoded sequence should be ignored.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encode-vs-decode",
    "href": "Chapters/01-base64.html#sec-encode-vs-decode",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "3.2 Difference between encode and decode",
    "text": "3.2 Difference between encode and decode\nIf you don‚Äôt have any previous experience with base64, you might be confused about what is the differente between ‚Äúencode‚Äù and ‚Äúdecode‚Äù. Essentially, the terms ‚Äúencode‚Äù and ‚Äúdecode‚Äù here have the exact same meaning as they have in the field of encryption (i.e.¬†they mean the same thing as ‚Äúencode‚Äù and ‚Äúdecode‚Äù in hashing algorithms, like the MD5 algorithm).\nSo, ‚Äúencode‚Äù means that we want to encode, or, in other words, we want to translate some message into the base64 encoding system. We want to produce the sequence of base64 characters that represent this original message in the base64 encoding system.\nIn contrast, ‚Äúdecode‚Äù represents the inverse process. We want to decode, or, in other words, translate a base64 message back to it‚Äôs original content. So, in this process we get a sequence of base64 characters as input, and produce as output, the binary data that is represented by this sequence of base64 characters.\nSo, any base64 library is normally composed by these two parts: 1) the encoder, which is a function that encodes (i.e.¬†it converts) any sequence of binary data into a sequence of base64 characters; 2) the decoder, which is a function that converts a sequence of base64 characters back into the original sequence of binary data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-base64-length-out",
    "href": "Chapters/01-base64.html#sec-base64-length-out",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "3.3 Calculating the size of the output",
    "text": "3.3 Calculating the size of the output\nOne task that we need to do is to calculate how much space we need to reserve for the output, both of the encoder and decoder. This is simple math, and can be done easily in Zig because every array have it‚Äôs length (it‚Äôs number of bytes) easily accesible by consulting the .len property of the array.\nFor the encoder, the logic is the following: for each 3 bytes that we find in the input, 4 new bytes are created in the output. So, we take the number of bytes in the input, divide it by 3, use a ceiling function, then, we multiply the result by 4. That way, we get the total number of bytes that will be produced by the encoder in it‚Äôs output.\nThe _calc_encode_length() function below encapsulates this logic. Notice that we convert the .len property of the array, which is always a integer (more precisely, an usize value), into a floating point number of 64 bits (f64). We do this, because the ceiling function (@ceil()) works only with floating point numbers. So, we convert it so that the division with the number 3.0 results in a floating point number. Then, after the ceiling process, we can convert the result back into an integer value (with the @intFromFloat() function).\n\nfn _calc_encode_length(input: []const u8) u64 {\n    if (input.len &lt; 3) {\n        const n_output: u64 = 4;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@ceil(len_as_float / 3.0) * 4.0);\n    return n_output;\n}\n\nIs important to notice that, when I am using the built-in functions from Zig to convert data types (@floatFromInt() and intFromFloat()), I‚Äôm always annotating explicitly the type of the variable that stores the result of these functions. I do that, because these functions need this information. @floatFromInt() needs to know which type of floating point number I want to use in it‚Äôs output. Is it f16? f32? f64? etc. The same goes to @intFromFloat().\nAlso, you might have notice that, if the input length is less than 3 bytes, then, the output length of the encoder will be always 4 bytes. This is because the algorithm will always fill the gap in the input with zeroes, until it fits the window of 24 bits that the algorithm likes to work on, as I described at Section 3.1.3. So the output of the algorithm will always be 4 bytes in this specific case.\nNow, for the decoder, we just need to apply the inverse logic: for each 4 bytes in the input, 3 bytes will be produced in the output of the decoder. I mean, this is roughly true, because we also need to take the = character into account, which is always ignored by the decoder, as we described at Section 3.1.4, and, at Figure¬†3.2. But we can ignore this fact for now, to make things simpler.\nSo, the function _calc_decode_length() summarizes this logic that we described. It is very similar to the function _calc_encode_length(), only the division part is twisted, and also, in the special case where we have less than 4 bytes in the input to work on.\n\nfn _calc_decode_length(input: []const u8) u64 {\n    if (input.len &lt; 4) {\n        const n_output: u64 = 3;\n        return n_output;\n    }\n    const len_as_float: f64 = @floatFromInt(input.len);\n    const n_output: u64 = @intFromFloat(@floor(len_as_float / 4.0) * 3.0);\n    return n_output;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-encoder-logic",
    "href": "Chapters/01-base64.html#sec-encoder-logic",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "3.4 Building the encoder logic",
    "text": "3.4 Building the encoder logic\nIn this section, we can start building the logic behind the encode() function, which will be responsible for encoding messages into the base64 encoding system.\nIf you are an anxious person, and you want to see now the full source code of the implementation for this base64 encoder/decoder, you can find it at the ZigExamples folder in the official repository of this book2.\n\n3.4.1 The 6-bit transformation\nThe 6-bit transformation presented at Figure¬†3.1 is the core part of the base64 encoder algorithm. By understanding how this transformation is made in code, the rest of the algorithm becomes much simpler to comprehend.\nIn essence, this 6-bit transformation is made with the help of bitwise operators. Bitwise operators are essential to any type of low-level operation that is done at the bit-level. For the specific case of the base64 algorithm, the operators bif shift to the left (&lt;&lt;), bit shift to the right (&gt;&gt;), and the bitwise and (&) are used. They are the core solution for the 6-bit transformation.\nWe have 3 different scenarios that we need to account for in this transformation. First, is the perfect scenario, where we have the perfect window of 3 bytes to work on. Second, we have the scenario where we have a window of only two bytes to work with. And last, we have the scenario where we have a window of one single byte.\nIn each of these 3 scenarios, the 6-bit transformation works a bit different. To make the explanation easier, I will use the variable output to refer to the bytes in the output of the base64 encoder, and the variable input to refer to the bytes in the input of the encoder.\nSo, if you have the perfect window of 3 bytes, these are steps for the 6-bit transformation:\n\noutput[0] is produced by moving the bits from input[0] two positions to the right.\noutput[1] is produced by summing two components. First, take the last two bits from input[0], then, move them four positions to the left. Second, move the bits from input[1] four positions to the right. Sum these two components.\noutput[2] is produced by summing two components. First, take the last four bits from input[1], then, move them two positions to the left. Second, move the bits from input[2] six positions to the right.\noutput[3] is produced by taking the last six bits from input[2].\n\nThis is the perfect scenario, when we have a full window of 3 bytes to work on. Just to make things as clear as possible, the Figure¬†3.3 demonstrates visually how the step 2 mentioned above works. So this is the step necessary to produce the 2nd byte in the output of the encoder, by taking the 1st byte (dark purple) and the 2nd byte (orange) in the input. You can see that, at the end of the process, we get a new byte that contains the last 2 bits from the 1st byte in the input, and the first 4 bits from the 2nd byte in the input.\n\n\n\n\n\n\nFigure¬†3.3: How the 2nd byte in the output of the encoder is produced from the 1st byte (dark purple) and the 2nd byte (orange) of the input\n\n\n\nOn the other hand, we must be prepared for the possibilities where we do not have the perfect window of 3 bytes. If you have a window of 2 bytes, then, the steps 3 and 4, which produces the bytes output[2] and output[3], change a little bit, and they become:\n\noutput[2] is produced by taking the last 4 bits from input[1], then, move them two positions to the left.\noutput[3] is the character '='.\n\nFinally, if you have a window of a single byte, then, the steps 2 to 4, which produces the bytes output[1], output[2] and output[3] change, becoming:\n\noutput[1] is produced by taking the last two bits from input[0], then, move them four positions to the left.\noutput[2] and output[3] are the character =.\n\nIf these bulletpoints were a bit confusing for you, you may find the Table¬†3.1 more intuitive. This table unifies all this logic into a simple table. Notice that this table also provides the exact expression in Zig that creates the corresponding byte in the output.\n\n\n\nTable¬†3.1: How the 6-bit transformation translates into code in different window settings.\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nNumber of bytes in the window\nByte index in the output\nIn code\n\n\n\n\n3\n0\ninput[0] &gt;&gt; 2\n\n\n3\n1\n((input[0] & 0x03) &lt;&lt; 4) +\n(input[1] &gt;&gt; 4)\n\n\n3\n2\n((input[1] & 0x0f) &lt;&lt; 2) +\n(input[2] &gt;&gt; 6)\n\n\n3\n3\ninput[2] & 0x3f\n\n\n2\n0\ninput[0] &gt;&gt; 2\n\n\n2\n1\n((input[0] & 0x03) &lt;&lt; 4) +\n(input[1] &gt;&gt; 4)\n\n\n2\n2\n((input[1] & 0x0f) &lt;&lt; 2)\n\n\n2\n3\n'='\n\n\n1\n0\ninput[0] &gt;&gt; 2\n\n\n1\n1\n((input[0] & 0x03) &lt;&lt; 4)\n\n\n1\n2\n'='\n\n\n1\n3\n'='\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 Bit-shifting in Zig\nBit-shifting in Zig works similarly to bit-shifting in C. All bitwise operators that exists in C are available in Zig. Here, in the base64 encoder algorithm, they are essential to produce the result we want.\nFor those who are not familiar with these operators, they are operators that operates at the bit-level of your values. This means that these operators takes the bits that form the value you have, and change them in some way. This ultimately also changes the value itself, because the binary representation of this value changes.\nWe already saw at Figure¬†3.3 visually what is the effect produced by a bit-shift. But let‚Äôs use the first byte in the output of the base64 encoder as another example of what bit-shifting means. This is the easiest byte of the 4 bytes in the output to build. Because we only need to move the bits from the first byte in the input two positions to the right, with the bit shift to the right (&gt;&gt;) operator.\nIf we take the string ‚ÄúHi‚Äù that we used at Figure¬†3.1 as an example, the first byte in this string is ‚ÄúH‚Äù, which is the sequence 01001000 in binary. If we move the bits of this byte, two places to the right, we get the sequence 00010010 as result. This binary sequence is the value 18 in decimal, and also, the value 0x12 in hexadecimal. Notice that the first 6 bits of the first byte in the input were moved to the end of the byte. With this operation, we get the first byte of the ouput, which corresponds to the index in the base64 scale for the first character in the base64 scale.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const input = \"Hi\";\n    var output = [4]u8{0,0,0,0};\n    output[0] = input[0] &gt;&gt; 2;\n    try stdout.print(\"{d}\\n\", .{output[0]});\n}\n\n18\n\n\nIf you recall Figure¬†3.1, the first byte present in the output should be equivalent to the 6-bit group 010010. Although being visually different, the sequences 010010 and 00010010 are semantically equal. They mean the same thing. They both represent the number 18 in decimal, and the value 0x12 in hexadecimal.\nSo, don‚Äôt take the ‚Äú6-bit group‚Äù factor so seriously. We do not need necessarily to get a 6-bit sequence as result. As long as the meaning of the 8-bit sequence we get is the same of the 6-bit sequence, we are in the clear.\n\n\n3.4.3 Selecting specific bits with the & operator\nIf you comeback to Section 3.4.1, you will see that to produce the second and third bytes in the output, we need to select specific bits from the first and second bytes in the input string. But how can we do that? The answer relies on the bitwise and (&) operator.\nThe Figure¬†3.3 already showed you what effect this & operator produces in the bits of it‚Äôs operands. But let‚Äôs make a clear description of it.\nIn summary, the & operator performs a logical conjunction operation between the bits of it‚Äôs operands. In more details, the operator & compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0 (Microsoft 2021).\nSo, if we apply this operator to the binary sequences 1000100 and 00001101 the result of this operation is the binary sequence 00000100. Because only at the sixth position in both binary sequences we had a 1 value. So any position where we do not have both binary sequences setted to 1, we get a 0 bit in the resulting binary sequence.\nWe loose information about the original bit values from both sequences in this case. Because we no longer know if this 0 bit in the resulting binary sequence was produced by combining 0 with 0, or 1 with 0, etc.\nAs an example, suppose you have the binary sequence 10010111, which is the number 151 in decimal. How can we get a new binary sequence which contains only the third and fourth bits?\nWe just need to combine this sequence with the sequence 00110000 (is 0x30 in hexadecimal) using the & operator. Notice that only the third and fourth positions in this binary sequence is setted to 1. As a consequence, only the third and fourth values of both binary sequences are potentially preserved in the output. All the remaining positions are setted to zero in the output sequence, which is 00010000 (is the number 16 in decimal).\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\npub fn main() !void {\n    const bits = 0b10010111;\n    try stdout.print(\"{d}\\n\", .{bits & 0b00110000});\n}\n\n16\n\n\n\n\n3.4.4 Allocating space for the output\nAs I described at Section 2.1.4, to store a variable in the stack, this variable needs to have a known and fixed length at compile-time. This is a problem for our a base64 encoder/decoder case. Because the size of the output (from both the encoder and decoder) depends directly on the size of the input.\nHaving this in mind, we cannot know at compile time which is the size of the output for both the encoder and decoder. So, if we can‚Äôt know the size of the output at compile time, this means that we cannot store in the stack, the output for both the encoder and decoder.\nConsequently, we need to store this output on the heap, and, as I commented at Section 2.1.5, we can only store variables in the heap by using allocator objects. So, one the arguments to both the encode() and decode() functions, needs to be an allocator object, because we know for sure that, at some point inside the body of these functions, we need to allocate space on the heap to store the output of these functions.\nThat is why, both the encode() and decode() functions that I present in this book, have an argument called allocator, which receives a allocator object as input, identified by the type std.mem.Allocator from the Zig standard library.\n\n\n3.4.5 Writing the encode() function\nNow that we have a basic understanding on how the bitwise operators work, and how exactly they help us to achieve the result we want to achieve. We can now encapsulate all the logic that we described at Figure¬†3.1 and Table¬†3.1 into a nice function that we can add to our Base64 struct definition, that we started at Section 3.1.2.\nYou can find the encode() function below. Notice that the first argument of this function, is the Base64 struct itself. Therefore, tis argument clearly signals that this function is a method from the Base64 struct.\nBecause the encode() function itself is fairly long, I intentionally ommitted the Base64 struct definition in this source code, just for brevity reasons. So, just remember that this function is a public function (or a public method) from the Base64 struct.\nFurthermore, this encode() function have two other arguments:\n\ninput is the input sequence of characters that you want to encode in base64;\nallocator is an allocator object to use in the necessary memory allocations.\n\nI described everything you need to know about allocator objects at Section 2.2. So, if you are not familiar with them, I highly recommend you to comeback to that section, and read it. By looking at the encode() function, you will see that we use this allocator object to allocate enough memory to store the output of encoding process.\nRemember from Section 2.1.4, that the stack can be used only to store variables that have a compile-time known fixed size. Unfortunately, this is not the case here. The size of the encode() output is tidly related to the size of the input from the user. So, the size of the output is only known at runtime. That is why we use an allocator object, to allocate memory on the heap (which allows objects whose size are runtime-known), and store the output there.\nThe main for loop in the function is responsible for iterating the entire input string. In every iteration, we use a count variable to count how many iterations we had at the moment. When count reaches 3, then, we try to encode the 3 characters (or bytes) that we accumulated until this point in the temporary buffer object (buf).\nAfter encoding these 3 characters and storing the result in the output variable, we reset the count variable to zero, and start to count again on the next iteration of the loop. If the loop hits the end of the string, and, the count variable is less than 3, then, it means that the temporary buffer contains the last 1 or 2 bytes from the input. That is why we have two if statements after the for loop. To deal which each possible case.\n\npub fn encode(self: Base64,\n              allocator: std.mem.Allocator,\n              input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n\n    const n_out = _calc_encode_length(input);\n    var out = try allocator.alloc(u8, n_out);\n    var buf = [3]u8{ 0, 0, 0 };\n    var count: u8 = 0;\n    var iout: u64 = 0;\n\n    for (input, 0..) |_, i| {\n        buf[count] = input[i];\n        count += 1;\n        if (count == 3) {\n            out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n            out[iout + 1] = self._char_at(\n                ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n            );\n            out[iout + 2] = self._char_at(\n                ((buf[1] & 0x0f) &lt;&lt; 2) + (buf[2] &gt;&gt; 6)\n            );\n            out[iout + 3] = self._char_at(buf[2] & 0x3f);\n            iout += 4;\n            count = 0;\n        }\n    }\n\n    if (count == 1) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            (buf[0] & 0x03) &lt;&lt; 4\n        );\n        out[iout + 2] = '=';\n        out[iout + 3] = '=';\n    }\n\n    if (count == 2) {\n        out[iout] = self._char_at(buf[0] &gt;&gt; 2);\n        out[iout + 1] = self._char_at(\n            ((buf[0] & 0x03) &lt;&lt; 4) + (buf[1] &gt;&gt; 4)\n        );\n        out[iout + 2] = self._char_at(\n            (buf[1] & 0x0f) &lt;&lt; 2\n        );\n        out[iout + 3] = '=';\n        iout += 4;\n    }\n\n    return out;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#sec-decoder-logic",
    "href": "Chapters/01-base64.html#sec-decoder-logic",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "3.5 Building the decoder logic",
    "text": "3.5 Building the decoder logic\nNow, we can focus on writting the base64 decoder logic. Remember from Figure¬†3.2 that, a base64 decoder do the inverse process of an encoder. So, all we need to do, is to write a decode() function that performs the inverse process that I exposed at Section 3.4.\n\n3.5.1 Mapping base64 characters to their indexes\nOne thing that we need to do, in order to decode a base64-encoded message, is to calculate the index in the base64 scale of every base64 character that we encounter in the decoder input.\nIn other words, the decoder receives as input, a sequence of base64 characters. We need to translate this sequence of characters into a sequence of indexes. These indexes are the index of each character in the base64 scale. This way, we get the value/byte that was calculated in the 6-bit transformation step of the encoder process.\nThere are probably better ways to calculate this, specially using a ‚Äúdivide and conquer‚Äù type of strategy. But for now, I am satisfied with a simple and ‚Äúbrute force‚Äù type of strategy. The _char_index() function below contains this strategy.\nWe are essentially looping through the lookup table with the base64 scale, and comparing the character we got with each character in the base64 scale. If these characters match, then, we return the index of this character in the base64 scale as the result.\nNotice that, if the input character is '=', the function returns the index 64, which is ‚Äúout of range‚Äù in the scale. But, as I described at Section 3.1.1, the character '=' does not belong to the base64 scale itself. It is a special and meaningless character in base64.\nAlso notice that this _char_index() function is a method from our Base64 struct, because of the self argument. Again, I ommitted the Base64 struct definition in this example, because of brevity reasons.\n\nfn _char_index(self: Base64, char: u8) u8 {\n    if (char == '=')\n        return 64;\n    var index: u8 = 0;\n    for (0..63) |i| {\n        if (self._char_at(i) == char) {\n            index = i;\n            break;\n        }\n    }\n\n    return index;\n}\n\n\n\n3.5.2 The 6-bit transformation\nOnce again, the core part of the algorithm is the 6-bit transformation. If we understand the necessary steps to perform this transformation, the rest of the algorithm becomes much easier.\nFirst of all, before we actually go to the 6-bit transformation, we need to make sure that we use _char_index() to convert the sequence of base64 characters into a sequence of indexes. So the snippet below will be important for the job to be done. The result of _char_index() will be stored in a temporary buffer, and this temporary buffer is what we are going to use in the 6-bit transformation, instead of the actual input object.\n\nfor (0..input.len) |i| {\n    buf[i] = self._char_index(input[i]);\n}\n\nNow, instead of producing 4 bytes (or 4 characters) as output per each window of 3 characters in the input, a base64 decoder produces 3 bytes (or 3 characters) as output per each window of 4 characters in the input. Once again, is the inverse process.\nSo, the steps to produce the 3 bytes in the output are:\n\noutput[0] is produced by summing two components. First, move the bits from buf[0] two positions to the left. Second, move the bits from buf[1] 4 positions to the right. Then, sum these two components.\noutput[1] is produced by summing two components. First, move the bits from buf[1] four positions to the left. Second, move the bits from buf[2] 2 positions to the right. Then, sum these two components.\noutput[2] is produced by summing two components. First, move the bits from buf[2] six positions to the left. Then, you sum the result with buf[3].\n\nBefore we continue, let‚Äôs try to visualize how these transformations make the original bytes that we had before the encoding process. First, think back at the 6-bit transformation performed by the encoder exposed at #sec-encoder-logic. The first byte in the output of the encoder is produced by moving the bits in the first byte of the input two positions to the right.\nSo, if for example the first byte in the input of the encoder was the sequence ABCDEFGH, then, the first byte in the output of the encoder would be 00ABCDEF (this sequence would be the first byte in the input of the decoder). Now, if the second byte in the input of the encoder was the sequence IJKLMNOP, then, the second byte in the encoder output would be 00GHIJKL (as we demonstrated at Figure¬†3.3).\nSo, if the sequences 00ABCDEF and 00GHIJKL sequences are the first byte and the second bytes, respectively, in the input of the decoder, the Figure¬†3.4 demonstrates visually how these two bytes are transformed into the first byte of the output of the decoder. Notice that the output byte is the sequence ABCDEFGH, which is the original byte from the input of the encoder.\n\n\n\n\n\n\nFigure¬†3.4: How the 1st byte in the decoder output is produced from the 1st byte (dark purple) and the 2nd byte (orange) of the input\n\n\n\nThe Table¬†3.2 presents how the three steps described ealier translate into Zig code:\n\n\n\nTable¬†3.2: The necessary steps for the 6-transformation in the decode process.\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\nByte index in the output\nIn code\n\n\n\n\n0\n(buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4)\n\n\n1\n(buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2)\n\n\n2\n(buf[2] &lt;&lt; 6) + buf[3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.5.3 Writing the decode() function\nThe decode() function below contains the entire decoding process. Notice that, we first calculate the necessary size for the output, with _calc_decode_length(), then, we allocate memory for this output with the allocator object.\nThree temporary variables are created: 1) count, to hold the window count in each iteration of the for loop; 2) iout, to hold the current index in the output; 3) buf, which is the temporary buffer that holds the base64 indexes to be converted through the 6-bit transformation.\nThen, in each iteration of the for loop we fill the temporary buffer with the current window of bytes. When count hits the number 4, then, we have a full window of indexes in buf to be converted, and then, we apply the 6-bit transformation over the temporary buffer.\nNotice that we check if the indexes 2 and 3 in the temporary buffer are the number 64, which, if you recall from Section 3.5.1, is when the _calc_index() function receives a '=' character as input. So, if these indexes are equal to the number 64, the decode() function knows that it can simply ignore these indexes. They are not converted, because, as I described before, the character '=' have no meaning, despite being the end of meaningful characters in the sequence. So we can safely ignore them, when they appear in the sequence.\n\nfn decode(self: Base64,\n          allocator: std.mem.Allocator,\n          input: []const u8) ![]u8 {\n\n    if (input.len == 0) {\n        return \"\";\n    }\n    const n_output = _calc_decode_length(input);\n    var output = try allocator.alloc(u8, n_output);\n    for (output, 0..) |_, i| {\n        output[i] = 0;\n    }\n    var count: u8 = 0;\n    var iout: u64 = 0;\n    var buf = [4]u8{ 0, 0, 0, 0 };\n\n    for (0..input.len) |i| {\n        buf[count] = self._char_index(input[i]);\n        count += 1;\n        if (count == 4) {\n            output[iout] = (buf[0] &lt;&lt; 2) + (buf[1] &gt;&gt; 4);\n            if (buf[2] != 64) {\n                output[iout + 1] = (buf[1] &lt;&lt; 4) + (buf[2] &gt;&gt; 2);\n            }\n            if (buf[3] != 64) {\n                output[iout + 2] = (buf[2] &lt;&lt; 6) + buf[3];\n            }\n            iout += 3;\n            count = 0;\n        }\n    }\n\n    return output;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#the-end-result",
    "href": "Chapters/01-base64.html#the-end-result",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "3.6 The end result",
    "text": "3.6 The end result\nNow that we have both decode() and encode() implemented. We have a full functioning base64 encoder/decoder implemented in Zig. Here is an example of use of our Base64 struct with the encode() and decode() methods that we implemented.\n\nvar memory_buffer: [1000]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(\n    &memory_buffer\n);\nconst allocator = fba.allocator();\n\nconst text = \"Testing some more shit\";\nconst etext = \"VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\";\nconst base64 = Base64.init();\nconst encoded_text = try base64.encode(\n    allocator, text\n);\nconst decoded_text = try base64.decode(\n    allocator, etext\n);\ntry stdout.print(\n    \"Encoded text: {s}\\n\", .{encoded_text}\n);\ntry stdout.print(\n    \"Decoded text: {s}\\n\", .{decoded_text}\n);\n\nEncoded text: VGVzdGluZyBzb21lIG1vcmUgc2hpdA==\nDecoded text: Testing some more shit\nYou can also see the full source code at once, by visiting the official repository of this book3. More precisely inside the ZigExamples folder4.\n\n\n\n\nMicrosoft. 2021. ‚ÄúBitwise AND Operator: &.‚Äù Microsoft Learn. https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/01-base64.html#footnotes",
    "href": "Chapters/01-base64.html#footnotes",
    "title": "3¬† Building a base64 encoder/decoder",
    "section": "",
    "text": "Notice that, the character ‚Äú0‚Äù is different than the actual number 0, which is simply zero in binary.‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/base64/base64_basic.zig.‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/base64/base64_basic.zig.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Building a base64 encoder/decoder</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html",
    "href": "Chapters/02-debugging.html",
    "title": "4¬† Debugging Zig applications",
    "section": "",
    "text": "4.1 Printing debugging\nWe begin with the classic and battle-tested print debugging strategy. The key advantage that debugging offers you is visibility. With print statements you can easily see what results and objects that are being generated within your functions.\nThat is the essence of print debugging. Is to use print expressions to see the values that are being generated by your program, and, as a result, get a much better understanding of how your program is behaving.\nMany programmers often resort to the print functions in Zig, such as the stdout.print(), or, the std.debug.print(), to get a better understanding of their programs. This is an known and old strategy that is very simple and effective, and it is better known within the programming community as print debugging. In Zig, you can either print information to the stdout or stderr streams of your system.\nLet‚Äôs begin with stdout. First, you need to get access to the stdout, by calling the getStdOut() method, from the Zig standard library. This method returns a file descriptor object, and, through this object you can read/write to the stdout. I recommend you to check out all methods available in this object, by checking the page in the Zig Standard Library Official Reference for the type File1.\nFor our purpose here, which is to write something to the stdout, specially to debug our program, I recommend you to use the writer() method, which gives your a writer object. This writer object offers some helper methods to write stuff into the file descriptor object that represents the stdout stream. In special, the print() method.\nThe print() method from this writer object is a ‚Äúprint formatter‚Äù type of a function. In other words, this method works exactly like the printf() function from C, or, like println!() from Rust. In the first argument of the function, you specify a template string, and, in the second argument, you provide a list of values (or objects) that you want to insert into your template message.\nIdeally, the template string in the first argument should contain some format specifier. Each format specifier is matched to a value (or object) that you listed in the second argument. So, if you provided 5 different objects in the second argument, then, the template string should contain 5 format specifiers, one for each object provided.\nEach format specifier is represented by a single letter, and you provide this format specifier inside a pair of curly braces. So, if you want to format your object using the string specifier (s), then, you can insert the text {s} in your template string. Here is a quick list of the most used format specifiers:\nThe code example below, gives you an example of use of this print() method with the d format specifier.\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    _ = try stdout.print(\"Result: {d}\", .{result});\n}\n\nResult: 50\nIs important to emphasize that, the stdout.print() method, as you would expect, print your template string into the stdout stream of your system. However, you can also print your template string into the stderr stream if your prefer. All you need to do, is to replace the stdout.print() call with the function std.debug.print(). Like this:\nconst std = @import(\"std\");\nfn add(x: u8, y: u8) u8 {\n    return x + y;\n}\n\npub fn main() !void {\n    const result = add(34, 16);\n    std.debug.print(\"Result: {d}\\n\", .{result});\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#printing-debugging",
    "href": "Chapters/02-debugging.html#printing-debugging",
    "title": "4¬† Debugging Zig applications",
    "section": "",
    "text": "d: for printing integers.\nf: for printing floating-point numbers.\nc: for printing characters.\ns: for printing strings.\np: for printing memory addresses.\nx: for printing hexadecimal values.\nany: use any compatible format specifier (i.e.¬†it automatically selects a format specifier for you).\n\n\n\n\n\nResult: 50",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#debugging-through-debuggers",
    "href": "Chapters/02-debugging.html#debugging-through-debuggers",
    "title": "4¬† Debugging Zig applications",
    "section": "4.2 Debugging through debuggers",
    "text": "4.2 Debugging through debuggers\nAlthough print debugging is a valid and very useful strategy, most programmers prefer to use a debugger to debug their programs. Since Zig is a low-level language, you can use either GDB (GNU Debugger), or LLDB (LLVM Project Debugger) as your debugger.\nBoth debuggers can work with Zig code, and it‚Äôs a matter of taste here. You choose the debugger of your preference, and you work with it. In this book, I will use LLDB as my debugger on the examples.\n\n4.2.1 Compile your source code in Debug mode\nIn order to debug your program through a debugger, you must compile your source code in Debug mode. Because when you compile your source code in other modes (such as Release), the compiler usually strips out some essential information that is used by the debugger to read and track your program, like PDB (Program Database) files.\nBy compiling your source code in Debug mode, you ensure that the debugger will find the necessary information in your program to debug it. By default, the compiler uses the Debug mode. Having this in mind, when you compile your program with the build-exe command (that we exposed at Section 1.2.4), if you don‚Äôt specify an explicit mode through the -O command-line 2 argument, then, the compiler will compile your code in Debug mode.\n\n\n4.2.2 Let‚Äôs debug a program\nAs an example, let‚Äôs debug some Zig code, and demonstrate how can we use LLDB to navigate and check the following piece of Zig code:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\n\nfn add_and_increment(a: u8, b: u8) u8 {\n    const sum = a + b;\n    const incremented = sum + 1;\n    return incremented;\n}\n\npub fn main() !void {\n    var n = add_and_increment(2, 3);\n    n = add_and_increment(n, n);\n    _ = try stdout.print(\"Result: {d}!\\n\", .{n});\n}\n\nResult: 13!\n\n\nThere is nothing wrong with this program. But it is a good start for us. First, we need to compile this program with the zig build-exe command. For this example, suppose that I compiled the above Zig code into a binary executable called add_program.\nzig build-exe add_program.zig\nNow, we can start LLDB with add_program, like this:\nlldb add_program\nFrom now on, LLDB is started, and you can know that I‚Äôm executing LLDB commands by looking at the prefix (lldb). If something is prefixed with (lldb), then you know that it is a LLDB command.\nThe first thing I will do, is to set a breakpoint at the main() function, by executing b main. After that, I just start the execution of the program with run. You can see in the output below, that the execution stopped at the first line in the function main(), as we expected.\n(lldb) b main\nBreakpoint 1: where = debugging`debug1.main + 22\n    at debug1.zig:11:30, address = 0x00000000010341a6\n(lldb) run\nProcess 8654 launched: 'add_program' (x86_64)\nProcess 8654 stopped\n* thread #1, name = 'add_program',\n    stop reason = breakpoint 1.1 frame #0: 0x10341a6\n    add_program`debug1.main at add_program.zig:11:30\n   8    }\n   9    \n   10   pub fn main() !void {\n-&gt; 11       var n = add_and_increment(2, 3);\n   12       n = add_and_increment(n, n);\n   13       try stdout.print(\"Result: {d}!\\n\", .{n});\n   14   }\nI can start to navigate through the code, and investigating the variables that are being generated. If you not familiar with the commands available in LLDB, I recommend you to read the official documentation of the project3. You can also look for cheat sheets. Which quickly describes all commands available for you, and, as a result, are also good resources for you4.\nCurrently, we are in the first line at the main() function. In this line, we create the n object, by executing the add_and_increment() function. To execute the current line of code, and go to the next line, we can run the n LLDB command. Let‚Äôs execute this command.\nAfter we executed this line, we can also look at the value stored inside this n object by using the p LLDB command. The syntax for this command is p &lt;name-of-object&gt;.\nIf we take a look at the value stored in the n object (p n), notice that it stores the hexadecimal value 0x06, which is the number 6 in decimal. We can also see that, this value have a type unsigned char, which is an unsigned 8-bit integer. We have talked already about this at Section 1.12, that u8 integers in Zig are equivalent to the C data type unsigned char.\n(lldb) n\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step over frame #0: 0x10341ae\n    debugging`debug1.main at debug1.zig:12:26\n   9    \n   10   pub fn main() !void {\n   11       var n = add_and_increment(2, 3);\n-&gt; 12       n = add_and_increment(n, n);\n   13       try stdout.print(\"Result: {d}!\\n\", .{n});\n   14   }\n(lldb) p n\n(unsigned char) $1 = '\\x06'\nNow, on the next line of code, we are executing the add_and_increment() function once again. Why not step inside this function? Shall we? We can do that, by executing the s LLDB command. Notice in the example below that, after executing this command, we entered inside the context of the add_and_increment() function.\nAlso notice in the example below that, I walked two more lines in the functions body, then, I executed the frame variable LLDB command, to see at once, the value stored in each of the variables that were created inside the current scope.\nYou can see in the output below that, the object sum stores the value \\f, which represents the form feed character. This character in the ASCII table, corresponds to the hexadecimal value 0x0C, or, in decimal, the number 12. So, this means that the result of the expression a + b executed at line 5, resulted in the number 12.\n(lldb) s\nProcess 4798 stopped\n* thread #1, name = 'debugging',\n    stop reason = step in frame #0: 0x10342de\n    debugging`debug1.add_and_increment(a='\\x02', b='\\x03')\n    at debug1.zig:4:39\n-&gt; 4    fn add_and_increment(a: u8, b: u8) u8 {\n   5        const sum = a + b;\n   6        const incremented = sum + 1;\n   7        return incremented;\n(lldb) n\n(lldb) n\n(lldb) frame variable\n(unsigned char) a = '\\x06'\n(unsigned char) b = '\\x06'\n(unsigned char) sum = '\\f'\n(unsigned char) incremented = '\\x06'",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#how-to-investigate-the-data-type-of-your-objects",
    "href": "Chapters/02-debugging.html#how-to-investigate-the-data-type-of-your-objects",
    "title": "4¬† Debugging Zig applications",
    "section": "4.3 How to investigate the data type of your objects",
    "text": "4.3 How to investigate the data type of your objects\nSince Zig is a strongly-typed language, the data types associated with your objects are very important for your program. So, debugging the data types associated with your objects might be important to understand bugs and errors in your program.\nWhen you walk through your program with a debugger, you can inspect the types of your objects by simply printing them to the console, with the LLDB p command. But you also have alternatives embedded in the language itself to access the data types of your objects.\nIn Zig, you can retrieve the data type of an object, by using the built-in function @TypeOf(). Just apply this function over the object, and you get access to the data type of the object.\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nconst expect = std.testing.expect;\n\npub fn main() !void {\n    const number: i32 = 5;\n    try expect(@TypeOf(number) == i32);\n    try stdout.print(\"{any}\\n\", .{@TypeOf(number)});\n}\n\ni32\n\n\nThis function is similar to the type() built-in function from Python, or, the typeof operator in Javascript.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/02-debugging.html#footnotes",
    "href": "Chapters/02-debugging.html#footnotes",
    "title": "4¬† Debugging Zig applications",
    "section": "",
    "text": "https://ziglang.org/documentation/master/std/#std.fs.File.‚Ü©Ô∏é\nSee https://ziglang.org/documentation/master/#Debug.‚Ü©Ô∏é\nhttps://lldb.llvm.org/‚Ü©Ô∏é\nhttps://gist.github.com/ryanchang/a2f738f0c3cc6fbd71fa.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Debugging Zig applications</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html",
    "href": "Chapters/05-pointers.html",
    "title": "5¬† Pointers and Optionals in Zig",
    "section": "",
    "text": "5.1 Constant objects vs variable objects\nYou can have a pointer that points to a constant object, or, a pointer that points to a variable object. But regardless of who this pointer is, a pointer must always respect the characteristics of the object that it points to. As a consequence, if the pointer points to a constant object, then, you cannot use this pointer to change the value that it points to. Because it points to a value that is constant. As we discussed at Section 1.4, you cannot change a value that is constant.\nFor example, if I have a number object, which is constant, I cannot execute the expression below where I‚Äôm trying to change the value of number to 6 through the pointer object. As demonstrated below, when you try to do something like that, you get a compile time error:\nconst number = 5;\nconst pointer = &number;\npointer.* = 6;\nIf I change the number object to be a variable object, by introducing the var keyword, then I can change the value of this object through a pointer, as demonstrated below:\nvar number: u8 = 5;\nconst pointer = &number;\npointer.* = 6;\ntry stdout.print(\"{d}\\n\", .{number});\n\n6\nYou can see this relationship on the data type of your pointer object. In other words, the data type of a pointer object already gives you some clues about whether the value that it points to is constant or not.\nWhen a pointer object points to a constant value, then, this pointer have a data type *const T, which means ‚Äúa pointer to a constant value of type T‚Äù. In contrast, if the pointer points to a variable value, then, the type of the pointer is usually *T, which is simply ‚Äúa pointer to a value of type T‚Äù.\nWhenever you see a pointer object whose type is in the format *const T, then, you know that you cannot use this pointer to change the value that it points to. Because this pointer points to a constant value of type T.\nHence, we talked about the value pointed by the pointer being constant or not, and the consequences that arises from it. But, what about the pointer object itself? I mean, what happens if the pointer object itself is constant or not? Think about it. We can have a constant pointer that points to a constant value. But we can also have a variable pointer that points to a constant value. And vice-versa.\nUntil this point, the pointer object was always constant, but what this means for us? What is the consequence of the pointer object being constant? The consequence is that we cannot change the pointer object, because it is constant. We can use the pointer object in multiple ways, but we cannot change the memory address that is inside this pointer object.\nHowever, if we mark the pointer object as a variable object, then, we can change the memory address pointed by this pointer object. The example below demonstrates that. Notice that the object pointed by the pointer object changes from c1 to c2.\nconst c1: u8 = 5;\nconst c2: u8 = 6;\nvar pointer = &c1;\ntry stdout.print(\"{d}\\n\", .{pointer.*});\npointer = &c2;\ntry stdout.print(\"{d}\\n\", .{pointer.*});\nThus, by setting the pointer object to a var or const object, you specify if the memory address contained in this pointer object can change or not in your program. On the other side, you can change the value pointed by the pointer, if, and only if this value is stored in a variable object. If this value is in a constant object, then, you cannot change this value through a pointer.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Pointers and Optionals in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#sec-pointer-var",
    "href": "Chapters/05-pointers.html#sec-pointer-var",
    "title": "5¬† Pointers and Optionals in Zig",
    "section": "",
    "text": "p.zig:6:12: error: cannot assign to constant\n    pointer.* = 6;\n\n\n\n\n\n\n\n\n\n5\n6",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Pointers and Optionals in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#types-of-pointer",
    "href": "Chapters/05-pointers.html#types-of-pointer",
    "title": "5¬† Pointers and Optionals in Zig",
    "section": "5.2 Types of pointer",
    "text": "5.2 Types of pointer\nIn Zig, there are two types of pointers (Zig Software Foundation 2024), which are:\n\nsingle-item pointer (*);\nmany-item pointer ([*]);\n\nSingle-item pointer objects are objects whose data types are in the format *T. So, for example, if an object have a data type *u32, it means that, this object contains a pointer that points to an unsigned 32-bit integer value. As another example, if an object have type *User, then, it contains a pointer to a User value.\nIn contrast, many-item pointer objects are objects whose data types are in the format [*]T. Notice that the star symbol (*) is now inside a pair of brackets ([]). If the star symbol is inside a pair of brackets, you know that this object is a many-item pointer.\nWhen you apply the & operator over an object, you will always get a single-item pointer. Many-item pointers are more of a ‚Äúinternal type‚Äù of the language, more closely related to slices. So, when you deliberately create a pointer with the & operator, you always get a single-item pointer as result. Remember that.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Pointers and Optionals in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#pointer-arithmethic",
    "href": "Chapters/05-pointers.html#pointer-arithmethic",
    "title": "5¬† Pointers and Optionals in Zig",
    "section": "5.3 Pointer arithmethic",
    "text": "5.3 Pointer arithmethic\nPointer arithmethic is available in Zig, and they work the same way they work in C. When you have a pointer that points to an array, the pointer usually points to the first element in the array, and you can use pointer arithmethic to advance this pointer and access the other elements in the array.\nNotice in the example below, that initially, the ptr object was pointing to the first element in the array ar. But then, I started to walk through the array, by advancing the pointer with simple pointer arithmethic.\n\nconst ar = [_]i32{1,2,3,4};\nvar ptr = &ar;\ntry stdout.print(\"{d}\\n\", .{ptr.*});\nptr += 1;\ntry stdout.print(\"{d}\\n\", .{ptr.*});\nptr += 1;\ntry stdout.print(\"{d}\\n\", .{ptr.*});\n\n1\n2\n3\nAlthough you can create a pointer to an array like that, and start to walk through this array by using pointer arithmethic, in Zig, we prefer to use slices, which were presented at Section 1.6.\nBehind the hood, slices already are pointers, and they also come with the len property, which indicates how many elements are in the slice. This is good because the zig compiler can use it to check for potential buffer overflows, and other problems like that.\nAlso, you don‚Äôt need to use pointer arithmethic to walk through the elements of a slice. You can simply use the slice[index] syntax to directly access any element you want in the slice. As I mentioned at Section 1.6, you can get a slice from an array by using a range selector inside brackets. In the example below, I‚Äôm creating a slice (sl) that covers the entire ar array. I can access any element of ar from this slice, and, the slice itself already is a pointer behind the hood.\n\nconst ar = [_]i32{1,2,3,4};\nconst sl = ar[0..ar.len];\n_ = sl;",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Pointers and Optionals in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#optionals-and-optional-pointers",
    "href": "Chapters/05-pointers.html#optionals-and-optional-pointers",
    "title": "5¬† Pointers and Optionals in Zig",
    "section": "5.4 Optionals and Optional Pointers",
    "text": "5.4 Optionals and Optional Pointers\nLet‚Äôs talk about optionals and how they relate to pointers in Zig. By default, objects in Zig are non-nullable. This means that, in Zig, you can safely assume that any object in your source code is not null.\nThis is a powerful feature of Zig when you compare it to the developer experience in C. Because in C, any object can be null at any point, and, as consequence, a pointer in C might point to a null value. This is a commom source of undefined behaviour in C. When programmers work with pointers in C, they have to constantly check if their pointers are pointing to null values or not.\nIf for some reason, your Zig code produces a null value somewhere, and, this null value ends up in an object that is non-nullable, a runtime error is always raised by your Zig program. Take the program below as an example. The zig compiler can see the null value at compile time, and, as result, it raises a compile time error. But, if a null value is raised during runtime, a runtime error is also raised by the Zig program, with a ‚Äúattempt to use null value‚Äù message.\n\nvar number: u8 = 5;\nnumber = null;\n\np5.zig:5:14: error: expected type 'u8',\n        found '@TypeOf(null)'\n    number = null;\n             ^~~~\nYou don‚Äôt get this type of security in C. In C, you don‚Äôt get warnings or errors about null values being produced in your program. If for some reason, your code produces a null value in C, most of the times, you end up getting a segmentation fault error as result, which can mean many things. That is why programmers have to constantly check for null values in C. Because they do not have much visibility of null values.\nPointers in Zig are also, by default, non-nullable. This is another amazing feature in Zig. So, any pointer you create in your code, you can safely assume that this pointer is pointing to a non-null value. Therefore, you don‚Äôt have this heavy work of checking if the pointers you create in Zig are pointing to a null value.\nThis is an important feature, because this is also a commom source source of undefined behaviour in C. For example, if you have a pointer x that points to an object y, the value of the object y might change during the runtime of your program, and, as consequence, the value pointed by the pointer x will change. I demonstrated already how the value pointed by a pointer might change at Section 5.1.\nSo, if for some reason, the value of y changes to a null value during runtime, and, you try to use the object y in some way in your code, the chances of producing a undefined behaviour in your program are sky high.\nIn C, when the value of y changes, you have no garantees that the value of the object y changed to a null value or not. You simply don‚Äôt know upfront if you have a null value in y or not. But in Zig, you can safely assume that the object y will never have a null value.\n\n5.4.1 What are optionals?\nOk, we know now that all objects are non-nullable by default in Zig. But what if we actually need to use an object that might receive a null value? Here is where optionals come in.\nAn optional object in Zig is an object that can be null. To mark an object as optional, we use the ? operator. When you put this ? operator right before the data type of an object, you transform this data type into an optional data type, and the object becomes an optional object.\nTake the snippet below as an example. We are creating a new variable object called num. This object have data type ?i32, which means that, this object contains either a signed 32-bit integer (i32), or, a null value. Both alternatives are valid values to the num object. That is why, I can actually change the value of this object to null, and, no errors are raised by the zig compiler, as demonstrated below:\n\nvar num: ?i32 = 5;\nnum = null;\n\n\n\n5.4.2 Optional pointers\nYou can also mark a pointer object as an optional pointer, meaning that, this pointer points to either a null value, or, a value that is not null. In other words, by marking a pointer in Zig as optional, you get a pointer in Zig that behaves like a pointer in C.\nWhen you mark a pointer as optional, the data type of this pointer object becomes ?*const T or ?*T, depending if the value pointed by the pointer is a constant value or not. The ? identifies the object as optional, and the * identifies it as a pointer object.\nIn the example below, we are creating a variable object named num, and an optional pointer object named ptr. Notice that the data type of the object ptr indicates that it is either a null value, or a pointer to an i32 value. Also, notice that the pointer object (ptr) can be marked as optional, even if the object num is not optional.\nWhat this code tells us is that, the num variable will never contain a null value. This variable will always contain a valid i32 value. But in contrast, the ptr object might contain either a null value, or, a pointer to an i32 value.\n\nvar num: i32 = 5;\nconst ptr: ?*i32 = &num;\n_ = ptr;\n\nBut what happens if we turn the table, and mark the num object as optional, instead of the pointer object. If we do that, then, the pointer object is not optional anymore. It would be a similar (altough different) result. Because then, we would have a pointer to an optional value. In other words, a pointer to a value that is either a null value, or, a not-null value.\nIn the example below, we are recreating this idea. Now, the ptr object have a data type of *?i32, instead of ?*i32. Notice that the * symbol comes before of ? this time. So now, we have a pointer that points to a value that is either null , or, a signed 32-bits integer.\n\nvar num: ?i32 = 5;\n// ptr have type `*?i32`, instead of `?*i32`.\nconst ptr = &num;\n_ = ptr;\n\n\n\n5.4.3 Null handling in optionals\nWhen you have an optional object in your Zig code, you have to explicitly handle the possibility of this object being null. Is like error-handling with try and catch. In Zig you also have to handle null values like if they were a type of error.\nWe can do that, by using either:\n\nan if statement, like you would do in C.\nthe orelse keyword.\nunwrap the optional value with the ? method.\n\nWhen you use an if statement, you use a pair of pipes to unwrap the optional value, and use this ‚Äúunwrapped object‚Äù inside the if block. Using the example below as a reference, if the object num is null, then, the code inside the if statement is not executed. Otherwise, the if statement will unwrap the object num into the not_null_num object. This not_null_num object is garanteed to be not null inside the scope of the if statement.\n\nconst num: ?i32 = 5;\nif (num) |not_null_num| {\n    try stdout.print(\n        \"{d}\\n\", .{not_null_num}\n    );\n}\n\n5\n\n\nNow, the orelse keyword behaves like a binary operator. You connect two expressions with this keyword. On the left side of orelse, you provide the expression that might result in a null value, and on the right side of orelse you provide another expression that will not result in a null value.\nThe idea behind the orelse keyword is: if the expression on the left side result in a not-null value, then, this not-null value is used. However, if this expression on the left side result in a null value, then, the value of the expression on the right side is used instead.\nLooking at the example below, since the x object is currently null, the orelse decided to use the alternative value, which is the number 15.\n\nconst x: ?i32 = null;\nconst dbl = (x orelse 15) * 2;\ntry stdout.print(\"{d}\\n\", .{dbl});\n\n30\n\n\nYou can use the if statement or the orelse keyword, when you want to solve (or deal with) this null value. However, if there is no clear solution to this null value, and the most logic and sane path is to simply panic and raise a loud error in your program when this null value is encountered, you can use the ? method of your optional object.\nIn essence, when you use this ? method, the optional object is unwraped. If a not-null value is found in the optional object, then, this not-null value is used. Otherwise, the unreachable keyword is used. You can read more about this unreacheable keyword at the official documentation1. But in essence, when you build your Zig source code using the build modes ReleaseSafe or Debug, this unreacheable keyword causes the program to panic and raise an error during runtime, like in the example below:\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().writer();\nfn return_null(n: i32) ?i32 {\n    if (n == 5) return null;\n    return n;\n}\n\npub fn main() !void {\n    const x: i32 = 5;\n    const y: ?i32 = return_null(x);\n    try stdout.print(\"{d}\\n\", .{y.?});\n}\n\nthread 12767 panic: attempt to use null value\np7.zig:12:34: 0x103419d in main (p7):\n    try stdout.print(\"{d}\\n\", .{y.?});\n                                 ^\n\n\n\n\nZig Software Foundation. 2024. ‚ÄúLanguage Reference.‚Äù Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Pointers and Optionals in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/05-pointers.html#footnotes",
    "href": "Chapters/05-pointers.html#footnotes",
    "title": "5¬† Pointers and Optionals in Zig",
    "section": "",
    "text": "https://ziglang.org/documentation/master/#unreachable.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Pointers and Optionals in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html",
    "href": "Chapters/04-http-server.html",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "",
    "text": "6.1 What is a HTTP Server?\nFirst of all, what is a HTTP Server? A HTTP server, as any other type of server, is essentially a program that runs indefinetly, on a infinite loop, waiting for incoming connections from clients. Once the server receives an incoming connection, it will accept this connection, and it will send messages back-and-forth to the client through this connection.\nBut the messages that are transmitted inside this connection are in a specific format. They are HTTP messages (i.e.¬†messages that uses the HTTP Protocol specification). The HTTP Protocol is the backbone of the modern web. The world wide web as we know it today, would not exist without the HTTP Protocol.\nSo, Web servers (which is just a fancy name to HTTP Servers) are servers that exchange HTTP messages with clients. And these HTTP servers and the HTTP Protocol specification are simply essential to the operation of the internet of today.\nThat is the whole picture of the process. Again, we have two subjects involved here, a server (which is a program that is running indefinetly, waiting for connections), and a client (which is someone that wants to connect to and exchange HTTP messages with the server).\nYou may find the material about the HTTP Protocol available at the Mozilla MDN Docs1 , a great resource for you to also look at. It gives you a great overview on how HTTP works, and what role the server plays in this matter.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-how-http-works",
    "href": "Chapters/04-http-server.html#sec-how-http-works",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.2 How a HTTP Server works?",
    "text": "6.2 How a HTTP Server works?\nImagine a HTTP Server as if it were the receptionist of a large hotel. In a hotel, you have a reception, and inside that reception there is a receptionist waiting for customers to arrive. A HTTP Server is essentially a receptionist that is indefinetly waiting for new customers (or, in the context of HTTP, new clients) to arrive in the hotel.\nWhen a customer arrives at the hotel, that customer starts a conversation with the receptionist. He tells the receptionist how many days he wants to stay at the hotel. Then, the receptionist search for an available apartment. If there is an available apartment at the moment, the customer pays the hotel fees, then, he gets the keys to the apartment, and then, he goes to the apartment to rest.\nAfter this entire process of dealing with the customer (searching for available rooms, receiving payment, handing over the keys), the receptionist goes back to what he was doing earlier, which is to wait. Wait for new customers to arrive.\nThat is, in a nutshell, what a HTTP Server do. It waits for clients to connect to the server. When a client attempts to connect to the server, the server accepts this connection, and it starts to exchange messages with the client through this connection. The first message that happens inside this connection is always a message from the client to the server. This message is called the HTTP Request.\nThis HTTP Request is a HTTP message that contains what the client wants from the server. Is literally a request. The client that connected to the server is asking this server to do something for him.\nThere are different ‚Äútypes of request‚Äù that any client can do to a HTTP Server. But the most basic type of request, is when a client ask to the HTTP Server to serve (i.e.¬†to send) some specific web page (which is a HTML file) to him. When you type google.com in your web browser, you are essentially sending a HTTP Request to Google‚Äôs HTTP servers, which asks these servers to send the Google webpage to you.\nNonetheless, when the server reiceves this first message, the HTTP Request, it analyzes this request, to understand: who the client is? what he wants the server to do? this client provided all the necessary information to perform the action that he asked? Etc.\nOnce the server understands what the client wants, he simply perform the action that was requested, and, to finish the whole process, the server sends back a HTTP message to the client, informing if the action performed was succesful or not, and, at last, the server ends (or closes) the connection with the client.\nThis last HTTP message sent from the server to the client, is called the HTTP Response. Because the server is responding to the action that was requested by the client. The main objective of this response message is let the client knows if the action requested was succesful or not, before the server closes the connection.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-http-how-impl",
    "href": "Chapters/04-http-server.html#sec-http-how-impl",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.3 How a HTTP server is normally implemented?",
    "text": "6.3 How a HTTP server is normally implemented?\nLet‚Äôs use the C language as an example. There are many materials teaching how to write a simple HTTP server in C code, like Yu (2023), or Weerasiri (2023), or Meehan (2021). Having this in mind, I will not show C code examples here, because you can find them on the internet. But I will describe the theory behind the necessary steps to perform in the C code.\nIn essence, we normally implement a HTTP server in C using WebSocket technology, which involves the following steps:\n\nCreate a socket object.\nBind a name (or more specifically, an address) to this socket object.\nMake this socket object to start listening and waiting for incoming connections.\nWhen a connection arrive, we accept this connection, and we exchange the HTTP messages (HTTP Request and HTTP Response).\nThen, we simply close this connection.\n\nA socket object (which uses the WebSocket technology) is essentially a channel of communication. You are creating a channel where people can send messages to. When you create a socket object, this object is not binded to any particular address. This means that with this object you have a representation of a channel of communication in your hands. But this channel is not currently available, or, it is not currently accessible, because it do not have a known address where you can find it.\nThat is what the ‚Äúbind‚Äù operation do. It binds a name (or more specifically, an address) to this socket object, or, this channel of communication, so that it becomes available, or, accessible through this address. While the ‚Äúlisten‚Äù operation makes the socket object to listen for incoming connections in this address. In other words, the ‚Äúlisten‚Äù operation makes the socket to wait for incoming connections.\nNow, when a client actually attempts to connect to the server through the address we specify, then, the socket object needs to accept this incoming connection. When we accept it, then, the connection is established, client and server are now connected to each other, and they can read or write messages in this established connection.\nAfter we received the HTTP Request from the client, and sent the HTTP Response to the client, we can now close the connection, and end this communication.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#implementing-the-server---part-1",
    "href": "Chapters/04-http-server.html#implementing-the-server---part-1",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.4 Implementing the server - Part 1",
    "text": "6.4 Implementing the server - Part 1\n\n6.4.1 Creating the socket object\nLet‚Äôs begin with creating the socket for our server. Just to make things shorter, I will create this socket object in a separate Zig module. I will name it config.zig.\nIn Zig, we can create a web socket using the std.posix.socket() function, from the Zig Standard Library. As I meantioned earlier at Section 6.3, every socket object we create represents a communication channel, and we need to bind this channel to a specific address. An ‚Äúaddress‚Äù is defined as an IP address, or, more specifically, an IPv4 address2. Every IPv4 address is composed by two components. The first component is the host, which is a sequence of 4 numbers separated by dot characters (.) that identifies the machine used. While the second component is a port number, which identifies the specific door, or, the specific port to use in the host.\nThe sequence of 4 numbers (i.e.¬†the host) identifies the machine (i.e.¬†the computer itselft) where this socket will live in. Every computer normally have multiple ‚Äúdoors‚Äù available inside him, because this allows the computer to receive multiple connections at the same time. He simply use a single door for each connection. So the port number, is essentially a number that identifies the specific door in the computer that will be resposible for receiving the connection. That is, it identifies the ‚Äúdoor‚Äù in the computer that the socket will use to receive incoming connections.\nTo make things simpler, I will use an IP address that identifies our current machine in this example. This means that, our socket object will reside on the same computer that we are currently using (this is also known as the ‚Äúlocalhost‚Äù) to write this Zig source code.\nBy convention, the IP address that identifies the ‚Äúlocahost‚Äù, which is the current machine we are using, is the IP 127.0.0.1. So, that is the IP address we are going to use in our server. I can declare it in Zig by using an array of 4 integers, like this:\n\nconst localhost = [4]u8{\n    127, 0, 0, 1\n};\n_ = localhost;\n\nNow, we need to decide which port number to use. By convention, there are some port numbers that are reserved, meaning that, we cannot use them for our own purposes, like the port 22 (which is normally used for SSH connections). For TCP connections, which is our case here, a port number is a 16-bit unsigned integer (type u16 in Zig), thus ranging from 0 to 65535 (Wikipedia 2024). So, we can choose a number from 0 to 65535 for our port number. In the example of this book, I will use the port number 3490 (just a random number).\nNow that we have these two informations at hand, I can finally create our socket object, using the std.posix.socket() function. First, we use the host and the port number to create an Address object, with the std.net.Address.initIp4() function, like in the example below. After that, I use this address object inside the socket() function to create our socket object.\nThe Socket struct defined below summarizes all the logic behind this this process. In this struct, we have two data members, which are: 1) the address object; 2) and a stream object, which is the object we will use to read and write the messages into any connection we establish.\nNotice that, inside the constructor method of this struct, when we create the socket object, we are using the IPROTO.TCP property as an input to tell the function to create a socket for TCP connections.\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst net = @import(\"std\").net;\n\npub const Socket = struct {\n    _address: std.net.Address,\n    _stream: std.net.Stream,\n\n    pub fn init() !Socket {\n        const host = [4]u8{ 127, 0, 0, 1 };\n        const port = 3490;\n        const addr = net.Address.initIp4(host, port);\n        const socket = try std.posix.socket(\n            addr.any.family,\n            std.posix.SOCK.STREAM,\n            std.posix.IPPROTO.TCP\n        );\n        const stream = net.Stream{ .handle = socket };\n        return Socket{ ._address = addr, ._stream = stream };\n    }\n};\n\n\n\n6.4.2 Listening and receiving connections\nRemember that we stored the Socket struct declaration that we built at Section 6.4.1 inside a Zig module named config.zig. This is why I imported this module into our main module (main.zig) in the example below, as the SocketConf object, to access the Socket struct.\nOnce we created our socket object, we can focus now on making this socket object to listen and receive new incoming connections. We do that, by calling the listen() method from the Address object that is contained in the socket object, and then, we call the accept() method over the result.\nThe listen() method from the Address object produces a server object, which is an object that will stay open and running indefinitely, waiting to receive an incoming connection. Therefore, if you try to run the code example below, by calling the run command from the zig compiler, you will notice that the programs keeps running indefinitely, without a clear end.\nThis happens, because the program is waiting for something to happen. It is waiting for someone to try to connect to the address (http://127.0.0.1:3490) where the server is running and listening for incoming connections. This is what the listen() method do, it makes the socket to be active waiting for someone to connect.\nOn the other side, the accept() method is the function that establish the connection when someone try to connect to the socket. This means that, the accept() method returns a new connection object as a result. And you can use this connection object to read or write messages from or to the client. For now, we are not doing anything with this connection object. But we are going to use it on the next section.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n    _ = connection;\n}\n\nThis code example allows one single connection. In other words, the server will wait for one incoming connection, and as soon as the server is done with the first connection that it establishs, the program ends, and the server stops.\nThis is not the norm on the real world. Most people that write a HTTP server like this, usually put the accept() method inside a while (infinite) loop, where if a connection is created with accept(), a new thread of execution is created to deal with this new connection and the client. That is, real-world examples of HTTP Servers normally rely on parallel computing to work.\nWith this design, the server simply accepts the connection, and the whole process of dealing with the client, and receiving the HTTP Request, and sending the HTTP Response, all of this is done in the background, on a separate execution thread.\nSo, as soon as the server accepts the connection, and creates the separate thread, the server goes back to what he was doing, which is to wait indefinitely for a new connection to accept. Having this in mind, the code example exposed above, is a server that serves only a single client. Because the program terminates as soon as the connection is accepted.\n\n\n6.4.3 Reading the message from the client\nNow that we have a connection established, i.e.¬†the connection object that we created through the accept() function, we can now use this connection object to read any messages that the client send to our server. But we can also use it to send messages back to the client.\nThe basic idea is, if we write any data into this connection object, then, we are sending data to the client, and if we read the data present in this connection object, then, we are reading any data that the client sent to us, through this connection object. So, just have this logic in mind. ‚ÄúRead‚Äù is for reading messages from the client, and ‚Äúwrite‚Äù is to send a message to the client.\nRemember from Section 6.2 that, the first thing that we need to do is to read the HTTP Request sent by the client to our server. Because it is the first message that happens inside the established connection, and, as a consequence, it is the first thing that we need to deal with.\nThat is why, I‚Äôm going to create a new Zig module in this small project, named request.zig to keep all functions related to the HTTP Request together. Then, I will create a new function named read_request() that will use our connection object to read the message sent by the client, which is the HTTP Request.\n\nconst std = @import(\"std\");\nconst Connection = std.net.Server.Connection;\npub fn read_request(conn: Connection,\n                    buffer: []u8) !void {\n    const reader = conn.stream.reader();\n    _ = try reader.read(buffer);\n}\n\nThis function accepts a slice object which behaves as a buffer. The read_request() function reads the contents of the message sent into the connection object, and saves this content into this buffer object that we provided as input.\nNotice that I‚Äôm using the connection object that we created to read the message from the client. I first access the reader object that lives inside the connection object. Then, I call the read() method of this reader object to effectivelly read and save the data sent by the client into the buffer object that we created earlier. I‚Äôm discarting the return value of the read() method, by assigning it to the underscore character (_), because this return value is not useful for us right now.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#looking-at-the-current-state-of-the-program",
    "href": "Chapters/04-http-server.html#looking-at-the-current-state-of-the-program",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.5 Looking at the current state of the program",
    "text": "6.5 Looking at the current state of the program\nI think it is a good time to see how our program is currently working. Shall we? So, the first thing I will do is to update the main.zig module in our small Zig project, so that the main() function call this new read_request() function that we just created. I will also add a print statement at the end of the main() function, just so that you can see what the HTTP Request we just loaded into the buffer object looks like.\nAlso, I‚Äôm creating the buffer object in the main() function, which will be responsible for storing the message sent by the client, and, I‚Äôm also using a for loop to initialize all fields of this buffer object to the number zero. This is important to make sure that we don‚Äôt have uninitialized memory in this object. Because uninitialized memory may cause undefined behaviour in our program.\nSince the read_request() receives as input the buffer object as a slice object ([]u8), I am using the syntax array[0..array.len] to get access to a slice of this buffer object, and provide it as input to the function.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst Request = @import(\"request.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n    var buffer: [1000]u8 = undefined;\n    for (0..buffer.len) |i| {\n        buffer[i] = 0;\n    }\n    _ = try Request.read_request(\n        connection, buffer[0..buffer.len]\n    );\n    try stdout.print(\"{s}\\n\", .{buffer});\n}\n\nNow, I‚Äôm going to execute this program, with the run command from the zig compiler. But remember, as we sad earlier, as soon as I execute this program, it will hang indefinitely, because the program is waiting for a client trying to connect to the server.\nMore specifically, the program will pause at the line with the accept() call. As soon as a client try to connect to the server, then, the execution will ‚Äúunpause‚Äù, and the accept() function will finally be executed to create the connection object we need, and the remaining of the program will run.\nYou can see that at Figure¬†6.1. The message Server Addr: 127.0.0.1:3490 is printed to the console, and the program is now waiting for an incoming connection.\n\n\n\n\n\n\nFigure¬†6.1: A screenshot of running the program\n\n\n\nWell, we can finally try to connect to this server, and there are several ways we can do this. For example, we could use the following Python script:\nimport requests\nrequests.get(\"http://127.0.0.1:3490\")\nOr, we could also open any web browser of our preference, and type the URL localhost:3490. OBS: localhost is the same thing as the IP 127.0.0.1. When you press enter, and your web browser go to this address, first, the browser will probably print a message saying that ‚Äúthis page isn‚Äôt working‚Äù, and, then, it will probably change to a new message saying that ‚Äúthe site can‚Äôt be reached‚Äù.\nYou get these ‚Äúerror messages‚Äù in the web browser, because it got no response back from the server. In other words, when the web browser connected to our server, it did send the HTTP Request through the established connection. Then, the web browser was expecting to receive a HTTP Response back, but it got no response from the server (we didn‚Äôt implemented the HTTP Response logic yet).\nBut that is okay. We achieved the result that we wanted for now, which is to connect to the server, and see the HTTP Request that was sent by the web browser (or by the Python script) to the server.\nIf you comeback to the console that you left open when you executed the program, you will see that the program finished it‚Äôs execution, and, a new message is printed in the console, which is the actual HTTP Request message that was sent by the web browser to the server. You can see this message at Figure¬†6.2.\n\n\n\n\n\n\nFigure¬†6.2: A screenshot of the HTTP Request sent by the web browser",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#sec-enum",
    "href": "Chapters/04-http-server.html#sec-enum",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.6 Learning about Enums in Zig",
    "text": "6.6 Learning about Enums in Zig\nEnums structures are available in Zig through the enum keyword. An enum (short for ‚Äúenumeration‚Äù) is a special structure that represents a group of constant values. So, if you have a variable which can assume a short and known set of values, you might want to associate this variable to an enum structure, to make sure that this variable only assumes a value from this set.\nA classic example for enums are primary colors. If for some reason, your program needs to represent one of the primary colors, you can create a enum that represents one of these colors. In the example below, we are creating the enum PrimaryColorRGB, which represents a primary color from the RGB color system. By using this enum, I am garanteed that the acolor object for example, will contain one of these three values: RED, GREEN or BLUE.\n\nconst PrimaryColorRGB = enum {\n    RED, GREEN, BLUE\n};\nconst acolor = PrimaryColorRGB.RED;\n_ = acolor;\n\nIf for some reason, my code tries to save in acolor, a value that is not in this set, I will get an error message warning me that a value such as ‚ÄúMAGENTA‚Äù do not exist inside the PrimaryColorRGB enum. Then I can easily fix my mistake.\n\nconst acolor = PrimaryColorRGB.MAGENTA;\n\ne1.zig:5:36: error: enum 'PrimaryColorRGB' has\n        no member named 'MAGENTA':\n    const acolor = PrimaryColorRGB.MAGENTA;\n                                   ^~~~~~~\nBehind the hood, enums in Zig work the same way that enums work in C. Each enum value is essentially represented as a integer. The first value in the set is represented as zero, then, the second value is one, ‚Ä¶ etc.\nOne thing that we are going to learn on the next section is that enums can have methods in them. Wait‚Ä¶ What? This is amazing! Yes, enums in Zig are similar to structs, and they can have private and public methods inside them.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#implementing-the-server---part-2",
    "href": "Chapters/04-http-server.html#implementing-the-server---part-2",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.7 Implementing the server - Part 2",
    "text": "6.7 Implementing the server - Part 2\nNow, on this section, I want to focus on parsing the HTTP Request we received from the client. However, to effectively parse a HTTP Request message, we first need to understand it‚Äôs structure. In summary, a HTTP Request is a text message that is divided into 3 different sections (or parts):\n\nThe top-level header indicating the method of the HTTP Request, the URI, and the HTTP version used in the message.\nA list of HTTP Headers.\nThe body of the HTTP Request.\n\n\n6.7.1 The top-level header\nThe first line of text in a HTTP Request always come with the three most essential information about the request being analyzed. These three key attributes of the HTTP Request are separated by a simple space in this first line of the request. The first information is the HTTP method that is being used in the request, second, we have the URI to which this HTTP Request is being sent to, and third, we have the version of the HTTP protocol that is being used in this HTTP Request.\nIn the snippet below, you will find an example of this first line in a HTTP Request. First, we have the the HTTP method of this request (GET). Many programmers refer to the URI component (/users/list) as the ‚ÄúAPI endpoint‚Äù to which the HTTP Request is being sent to. In the context of this specific request, since it is a GET request, you could also say that the URI component is the path to the resource we want to access, or, the path to the document (or the file) that we want to retrieve from the server.\nGET /users/list HTTP/1.1\nAlso, notice that this HTTP Request is using the version 1.1 of the HTTP protocol, which is the most popular version of the protocol used in the web.\n\n\n6.7.2 The list of HTTP headers\nMost HTTP Requests also include a section of HTTP Headers, which is just a list of attributes or key-value pairs associated with this particular request. This section always comes right after the ‚Äútop-level header‚Äù of the request.\nFor our purpose in this chapter, which is to build a simple HTTP Server, we are going to ignore this section of the HTTP Request, for simplicity. But most HTTP servers that exist in the wild parses and use these HTTP headers to change the way that the server responds to the request send by the client.\nFor example, many requests we encounter in the real-world comes with a HTTP header called Accept. In this header, we find a list of MIME types3. This list indicates the file formats that the client can read, or parse, or interpret. In other words, you also interpret this header as the client saying the following phrase to the server: ‚ÄúHey! Look, I can read only HTML documents, so please, send me back a document that is in a HTML format.‚Äù.\nSo, if the HTTP server can read and use this Accept header, then, the server can identify which is the best format of the document to send to the client. Maybe the HTTP server have the same document in multiple formats, for example, in JSON, in XML, in HTML and in PDF, but the client can only understand documents in the format HTML. That is the purpose of this Accept header.\n\n\n6.7.3 The body\nThe body comes after the list of HTTP headers, and it is an optional section of the HTTP Request, meaning that, not all HTTP Request will come with a body in it. For example, every HTTP Request that uses the GET method usually do not come with a body.\nBecause a GET request is used to request data, instead of sending it to the server. So, the body section is more related to the POST method, which is a method that involves sending data to the server, to be processed and stored.\nSince we are going to support only the GET method in this project, it means that we also do not need to care about the body of the request.\n\n\n6.7.4 Creating the HTTP Method enum\nEvery HTTP Request comes with a explicit method. The method used in a HTTP Request is identified by one these words:\n\nGET;\nPOST;\nOPTIONS;\nPATCH;\nDELETE;\nand some other methods.\n\nEach HTTP method is used for a specific type of task. The POST method for example is normally used to post some data into the destination. In other words, it is used to send some data to the HTTP server, so that it can be processed and stored by the server.\nAs another example, the GET method is normally used to get content from the server. In other words, we use this method whenever we want the server to send some content back to us. It can be any type of content. It can be a web page, a document file, or some data in JSON format.\nWhen a client send a POST HTTP Request, the HTTP Response sent by the server normally have the sole purpose of letting the client know if the server processed and stored the data succesfully. In contrast, when the server receives a GET HTTP Request, then, the server sends the content that the client asked for in the HTTP Response itself. This demonstrates that the method associated with the HTTP Request changes a lot on the dynamics and the roles that each party plays in the whole process.\nSince the HTTP method of the HTTP Request is identified by this very small and specific set of words, it would be interesting to create an enum structure to represent a HTTP method. This way, we can easily check if the HTTP Request we receive from the client is a HTTP method that we currently support in our small HTTP server project.\nThe Method structure below represents this enumeration. Notice that, for now, only the GET HTTP method is included in this enumeration. Because, for the purpose of this chapter, I want to implement only the GET HTTP method. That is why I am not including the other HTTP methods in this enumeration.\n\npub const Method = enum {\n    GET\n};\n\nNow, I think we should add two methods to this enum structure. One method is is_supported(), which will be a function that returns a boolean value, indicating if the input HTTP method is supported or not by our HTTP Server. The other is init(), which is a constructor function that takes a string as input, and tries to convert it into a Method value.\nBut in order to build these functions, I will use a functionality from the Zig Standard Library, called StaticStringMap(). This function allows us to create a simple map from strings to enum values. In other words, we can use this map structure to map a string to the respective enum value. To some extent, this specific structure from the standard library works almost like a ‚Äúhashtable‚Äù structure, and it is optmized for a small sets of words, or, a small set of keys, which is our case here.\nTo use this function, you have to import it from the std.static_string_map module. Just to make things shorter and easier to type, I am going to import this function through a different and shorter name (Map).\nWith Map() imported, we just apply this function over the enum structure that we are going to use in the resulting map. In our case here, it is the Method enum structure that we declared at the last code example. Then, I call the initComptime() method with the map, i.e.¬†the list of key-value pairs that we are going to use.\nYou can see in the example below that I write this map using multiple anonymous struct literals. Inside the first (or ‚Äútop-level‚Äù) struct literal we have a list (or a sequence) of struct literals. Each struct literal in this list represents a key-value pair. The first element in this struct is the key, while the second element is the value. The first element (or the key) in each key-value pair should always be a string value. While the second element should be a value from the enum structure that you used inside the Map() function.\n\nconst Map = std.static_string_map.StaticStringMap;\nconst MethodMap = Map(Method).initComptime(.{\n    .{ \"GET\", Method.GET },\n});\n\nTherefore, the MethodMap object is basically a std::map object from C++, or, a dict object from Python. You can retrieve (or get) the enum value that corresponds to a particular key, by using the get() method from the map object. This method returns an optional value, so, the get() method might result in a null value.\nWe can use this in our advantage to detect if a particular HTTP method is supported or not in our HTTP server. Because, if the get() method returns null, it means that it did not find this method inside our MethodMap object, and, as a consequence, this method is not supported by our HTTP server. In this specific case, a null value means ‚Äúnot supported method‚Äù.\nThe init() method below, takes a string value as input, and then, it simply passes this string value to the get() method of our MethodMap object. As consequence, we should get the enum value that corresponds to this input string.\nNotice in the example below that, the init() method returns either an error (which might happen if the ? method returns unreacheable, checkout Section 5.4.3 for more details) or a Method object as result. Since GET is currently the only value in our Method enum structure, it means that, the init() method will most likely return the value Method.GET as result.\nAlso notice that, in the is_supported() method, we are using the optional value returned by the get() method from our MethodMap object. The if statement unwrapes the optional value returned by this method, and returns true in case this optional value is a not-null value. Otherwise, it simply returns false.\n\npub const Method = enum {\n    GET,\n    pub fn init(text: []const u8) !Method {\n        return MethodMap.get(text).?;\n    }\n    pub fn is_supported(m: []const u8) bool {\n        const method = MethodMap.get(m);\n        if (method) |_| {\n            return true;\n        }\n        return false;\n    }\n};\n\n\n\n6.7.5 Writing the parse request function\nNow that we created the enum that represents our HTTP method, we should start to write the function responsible for actually parsing the HTTP Request. Let‚Äôs first, understand the structure of a HTTP Request.\nThe first thing we can do, is to write a struct to represent the HTTP Request. Take the Request struct below as an example. It contains the three essential information from the ‚Äútop-level‚Äù header (i.e.¬†the first line) in the HTTP Request.\n\nconst Request = struct {\n    method: Method,\n    version: []const u8,\n    uri: []const u8,\n    pub fn init(method: Method,\n                uri: []const u8,\n                version: []const u8) Request {\n        return Request{\n            .method = method,\n            .uri = uri,\n            .version = version,\n        };\n    }\n};\n\nThe parse_request() function should receive a string as input. This input string contains the entire HTTP Request message, and the parsing function should read and understand the individual parts of this message.\nNow, remember that for the purpose of this chapter, we care about only about the first line in this message, which contains the ‚Äútop-level header‚Äù, or, the three essential attributes about the HTTP Request, which are the HTTP method used, the URI and the HTTP version.\nNotice that I use the function indexOfScalar() in parse_request(). This function from the Zig Standard Library returns the first index where the scalar value that we provide happens in a string. In this case, I‚Äôm looking at the first occurrence of the new line character (\\n). Because once again, we care only about the first line in the HTTP Request message. This is the line where we have the three information we want to parse (version of HTTP, the HTTP method and the URI).\nTherefore, we are using this indexOfScalar() function to limit our parsing process to the first line in the message. Is also worth mentioning that, the indexOfScalar() function returns an optional value. That is why I use the orelse keyword to provide an alternative value, in case the value returned by the function is a null value.\nSince each of these three attributes are separated by a simple space, we could use the function splitScalar() from the Zig Standard Library to split the input string into sections by looking for every position that appears a simple space. In other words, this splitScalar() function is equivalent to the split() method in Python, or, the std::getline() function from C++, or the strtok() function in C.\nWhen you use this splitScalar() function you get an iterator as the result. This iterator have a next() method that you can use to advance the iterator to the next position, or, to the next section of the splitted string. Note that, when you use next(), the method not only advances the iterator, but it also returns a slice to the current section of the splitted string as result.\nNow, if you want to get a slice to the current section of the splitted string, but not advance the iterator to the next position, you can use the peek() method. Both next() and peek() methods return an optional value, that is why I use the ? method to unwrap these optional values.\n\npub fn parse_request(text: []u8) Request {\n    const line_index = std.mem.indexOfScalar(\n        u8, text, '\\n'\n    ) orelse text.len;\n    var iterator = std.mem.splitScalar(\n        u8, text[0..line_index], ' '\n    );\n    const method = try Method.init(iterator.next().?);\n    const uri = iterator.next().?;\n    const version = iterator.next().?;\n    const request = Request.init(method, uri, version);\n    return request;\n}\n\nHave you notice that the ‚Äústring utility functions‚Äù we imported from the Zig Standard Library, and that we applied over the input string, comes from the mem module (which is the ‚Äúmemory utility functions‚Äù module)?\nAs I described at Section 1.12, strings in Zig are simply arrays of bytes in the language. So, you will find inside this mem module lots of excellent utility functions to work directly with bytes and arrays in Zig, and, as a result, these functions will also be very useful if you have to work with string data.\n\n\n6.7.6 Using the parse request function\nNow that we wrote the function responsible for parsing the HTTP Request, we can add the function call to parse_request() in the main() function of our program.\nAfter, is a good idea to test once again the state of our program. I execute this program again with the run command from the zig compiler, then, I use my web browser to connect once again to the server through the URL localhost:3490, and finally, the end result of our Request object is printed to the console.\nA quick observation, since I used the any format specifier in the print statement, the data members version and uri of the Request struct were printed as raw integer values. String data being printed as integer values is commom in Zig, and remember, these integer values are just the decimal representation of the bytes that form the string in question.\nIn the result below, the sequence of decimal values 72, 84, 84, 80, 47, 49, 46, 49, and 13, are the bytes that form the text ‚ÄúHTTP/1.1‚Äù. And the integer 47, is the decimal value of the character /, which represents our URI in this request.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst Request = @import(\"request.zig\");\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n\n    var buffer: [1000]u8 = undefined;\n    for (0..buffer.len) |i| {\n        buffer[i] = 0;\n    }\n    try Request.read_request(\n        connection, buffer[0..buffer.len]\n    );\n    const request = Request.parse_request(buffer[0..buffer.len]);\n    try stdout.print(\"{any}\\n\", .{request});\n}\n\nrequest.Request{\n    .method = request.Method.GET,\n    .version = {72, 84, 84, 80, 47, 49, 46, 49, 13},\n    .uri = {47}\n}\n\n\n6.7.7 Sending the HTTP Response to the client\nIn this last part, we are going to write the logic responsible for sending the HTTP Response from the server to the client. To make things simple, the server in this project will send just a simple web page containing the text ‚ÄúHello world‚Äù.\nFirst, I create a new Zig module in the project, named response.zig. In this module, I will declare just two functions. Each function corresponds to a specific status code in the HTTP Response. The send_200() function will send a HTTP Response with status code 200 (which means ‚ÄúSuccess‚Äù) to the client. While the send_404() sends a response with status code 404 (which means ‚ÄúNot found‚Äù).\nThis is definitely not the most ergonomic and adequate way of handling the HTTP Response, but it works for our case here. We are just building toy projects in this book after all. So, the source code we write do not need to be perfect. It just needs to work!\n\nconst std = @import(\"std\");\nconst Connection = std.net.Server.Connection;\npub fn send_200(conn: Connection) !void {\n    const message = (\n        \"HTTP/1.1 200 OK\\nContent-Length: 48\"\n        ++ \"\\nContent-Type: text/html\\n\"\n        ++ \"Connection: Closed\\n\\n&lt;html&gt;&lt;body&gt;\"\n        ++ \"&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n    );\n    _ = try conn.stream.write(message);\n}\n\npub fn send_404(conn: Connection) !void {\n    const message = (\n        \"HTTP/1.1 404 Not Found\\nContent-Length: 50\"\n        ++ \"\\nContent-Type: text/html\\n\"\n        ++ \"Connection: Closed\\n\\n&lt;html&gt;&lt;body&gt;\"\n        ++ \"&lt;h1&gt;File not found!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n    );\n    _ = try conn.stream.write(message);\n}\n\nNotice that both functions receives the connection object as input, and use the write() method to write the HTTP Response message directly into this communication channel. As result, the party in the other side of the connection (i.e.¬†the client), will receive such message.\nMost real-world HTTP Servers will have a single function (or a single struct) to effectively handle the response. It gets the HTTP Request already parsed as input, and then, it tries to build the HTTP Response bit by bit, before the function sends it over the connection.\nWe would also have a specialized struct to represent a HTTP Response, and a lot of methods that would be used to build each part or component of the response object. Take the Response struct created by the Javascript runtime Bun as an example. You can find this struct in the response.zig module4 in their GitHub project.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#the-end-result",
    "href": "Chapters/04-http-server.html#the-end-result",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "6.8 The end result",
    "text": "6.8 The end result\nWe can now, update once again our main() to incorporate our new functions from the respons.zig module. First I need to import this module into our main.zig module, then, I add the function calls to send_200() and send_404().\nNotice that I‚Äôm using if statements to decide which ‚Äúresponse function‚Äù to call, based specially on the URI present in the HTTP Request. If the user asked for a content (or a document) that is not present in our server, we should respond with a 404 status code. But since we have just a simple HTTP server, with no real documents to send, we can just check if the URI is the root path (/) or not to decide which function to call.\nAlso, notice that I‚Äôm using the function std.mem.eql() from the Zig Standard Library to check if the string from uri is equal or not the string \"/\". This function is used to check if two arrays are equal or not. In the first argument, you provide the type of the elements present in this array. While in the second and third arguments, you provide the arrays to be compared.\n\nconst std = @import(\"std\");\nconst SocketConf = @import(\"config.zig\");\nconst Request = @import(\"request.zig\");\nconst Response = @import(\"response.zig\");\nconst Method = Request.Method;\nconst stdout = std.io.getStdOut().writer();\n\npub fn main() !void {\n    const socket = try SocketConf.Socket.init();\n    try stdout.print(\"Server Addr: {any}\\n\", .{socket._address});\n    var server = try socket._address.listen(.{});\n    const connection = try server.accept();\n\n    var buffer: [1000]u8 = undefined;\n    for (0..buffer.len) |i| {\n        buffer[i] = 0;\n    }\n    try Request.read_request(connection, buffer[0..buffer.len]);\n    const request = Request.parse_request(buffer[0..buffer.len]);\n    if (request.method == Method.GET) {\n        if (std.mem.eql(u8, request.uri, \"/\")) {\n            try Response.send_200(connection);\n        } else {\n            try Response.send_404(connection);\n        }\n    }\n}\n\nNow that we adjusted our main() function, I can now execute our program, and see the effects of these last changes. First, I execute the program once again, with the run command of the zig compiler. The program will hang, waiting for a client to connect.\nThen, I open my web browser, and try to connect to the server again, using the URL localhost:3490. This time, instead of getting ar ‚Äúerror message‚Äù from the browser, you will get the message ‚ÄúHello World‚Äù printed into your web browser. Because this time, the server sended the HTTP Response succesfully to the web browser, as demonstrated by Figure¬†6.3.\n\n\n\n\n\n\nFigure¬†6.3: The Hello World message sent in the HTTP Response\n\n\n\n\n\n\n\nMeehan, Eric. 2021. ‚ÄúCreating a Web Server from Scratch in c.‚Äù Youtube. https://www.youtube.com/watch?v=gk6NL1pZi1M&ab_channel=EricOMeehan.\n\n\nWeerasiri, Nipun Chamikara. 2023. ‚ÄúA Simple Web Server Written in c.‚Äù Medium. https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6.\n\n\nWikipedia. 2024. ‚ÄúPort (Computer Networking).‚Äù Wikipedia. https://en.wikipedia.org/wiki/Port_(computer_networking).\n\n\nYu, Jeffrey. 2023. ‚ÄúHow i Built a Simple HTTP Server from Scratch Using c.‚Äù DEV Community. https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/04-http-server.html#footnotes",
    "href": "Chapters/04-http-server.html#footnotes",
    "title": "6¬† Building a HTTP Server from scratch",
    "section": "",
    "text": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview.‚Ü©Ô∏é\nIt can be also an IPv6 address. But normally, we use a IPv4 address for that.‚Ü©Ô∏é\nhttps://en.wikipedia.org/wiki/Media_type.‚Ü©Ô∏é\nhttps://github.com/oven-sh/bun/blob/main/src/bun.js/webcore/response.zig.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Building a HTTP Server from scratch</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html",
    "href": "Chapters/03-unittests.html",
    "title": "7¬† Unit tests in Zig",
    "section": "",
    "text": "7.1 Introducing the test block\nIn Zig, unit tests are written inside a test declaration, or, how I prefer to call it, inside a test block. Every test block is written by using the keyword test. You can optionally use a string literal to write a label, which is responsible for identifying the specific group of unit tests that you are writing inside this specific test block.\nIn the example below, we are testing if the sum of two objects (a and b) is equal to 4. The expect() function from the Zig Standard Library is a function that receives a logical test as input. If this logical test results in true, then, the test passes. But if it results in false, then, the test fails.\nYou can write any Zig code you want inside of each test block. Part of this code might be some necessary commands to setup your testing environment, or just initializing some necessary objects.\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\ntest \"testing simple sum\" {\n    const a: u8 = 2;\n    const b: u8 = 2;\n    try expect((a + b) == 4);\n}\nYou can have multiple test blocks written on the same Zig module. Also, you can mix test blocks with your source code, with no problems or consequences. If you mix test blocks with your normal source code, when you execute the build, build-exe, build-obj or build-lib commands from the zig compiler that we exposed at Section 1.2.4, these test blocks are automatically ignored by the compiler.\nIn other words, the zig compiler only builds and execute your tests when you ask it to. By default, the compiler always ignore test blocks written in your Zig modules. The compiler normally checks only if there are any syntax errors in these test blocks.\nIf you look at the source code for most of the files present in the Zig Standard Library1, you can see that the test blocks are written together with the normal source code of the library. You can see this for example, at the array_list module2. So, the standard that the Zig developers decided to adopt is to keep their unit tests together with the source code of the functionality that they are testing.\nEach programmer might have a different opinion on this. Some of them might prefer to keep unit tests separate from the actual source code of their application. If that is your case, you can simply create a separate tests folder in your project, and start writing Zig modules that contains only unit tests (as would normally do on a Python project with pytest, for example), and everything will work fine. It boils down to which is your preference here.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#how-to-run-your-tests",
    "href": "Chapters/03-unittests.html#how-to-run-your-tests",
    "title": "7¬† Unit tests in Zig",
    "section": "7.2 How to run your tests",
    "text": "7.2 How to run your tests\nIf the zig compiler ignores any test block by default, how can you compile and run your unit tests? The answer is the test command from the zig compiler. By running zig test command, the compiler will find every instance of test block in your Zig module, and, it will compile and run the unit tests you wrote.\nzig test simple_sum.zig\n1/1 simple_sum.test.testing simple sum... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-memory-allocations",
    "href": "Chapters/03-unittests.html#testing-memory-allocations",
    "title": "7¬† Unit tests in Zig",
    "section": "7.3 Testing memory allocations",
    "text": "7.3 Testing memory allocations\nOne of the advantages of Zig is that it offers great tools that hep us, programmers, to avoid (but also detect) memory problems, such as memory leaks and double-frees. The defer keyword is specially helpful in this regard.\nWhen developing your source code, you, the programmer, is responsible for making sure that your code do not produce such problems. However, you can also use a special type of allocator object in Zig, that is capable of automatically detect such problems for you. This is the std.testing.allocator object. This allocator object offers some basic memory safety detection features, which are capable of detecting memory leaks.\nAs we described at Section 2.1.5, to allocate memory on the heap, you need to use an allocator object, and your functions that use these objects to allocate memory on the heap, should receive an allocator object as one of it‚Äôs inputs. Every memory on the heap that you allocate using these allocator objects, must also be freed using this same allocator object.\nSo, if you want to test the memory allocations performed by your functions, and make sure that you don‚Äôt have problems in these allocations, you can simply write unit tests for these functions, where you provide the std.testing.allocator object as input to these functions.\nLook at the example below, where I‚Äôm defining a function that clearly causes a memory leak. Because we allocate memory with the allocator object, but we do not free this allocated memory in any point. So, when the function returns, we lose the reference to the buffer object, which contains the allocated memory, and, as a result, we can no longer free this memory.\nNotice that, inside a test block I execute this function with the std.testing.allocator. Since no visible errors were raised inside the test block, the zig compiler completes the process indicating that the unit tests performed inside the test block labeled as \"memory leak have all passed. But despite this result, the allocator object was capable of looking deeper in our program, and detecting the memory leak. As a result, this allocator object returns a message ‚Äútests leaked memory‚Äù, and also, a stack trace showing the exact point where the memory was leaked.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nfn some_memory_leak(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u32, 10);\n    _ = buffer;\n    // Return without freeing the\n    // allocated memory\n}\n\ntest \"memory leak\" {\n    const allocator = std.testing.allocator;\n    try some_memory_leak(allocator);\n}\n\nTest [1/1] leak_memory.test.memory leak...\n    [gpa] (err): memory address 0x7c1fddf39000 leaked: \n./ZigExamples/debugging/leak_memory.zig:4:39: 0x10395f2\n    const buffer = try allocator.alloc(u32, 10);\n                                      ^\n./ZigExamples/debugging/leak_memory.zig:12:25: 0x10398ea\n    try some_memory_leak(allocator);\n\n... more stack trace",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-errors",
    "href": "Chapters/03-unittests.html#testing-errors",
    "title": "7¬† Unit tests in Zig",
    "section": "7.4 Testing errors",
    "text": "7.4 Testing errors\nOne commom style of unit tests are those that look for specific errors in your functions. In other words, you write a unit test that tries to assert if a specific function call returns any error, or a specific type of error.\nIn C++ you would normally write this stye of unit test using, for example, the functions REQUIRE_THROWS() or CHECK_THROWS() from the Catch2 test framework3. In the case of a Python project, you would use the raises() function from pytest4. While in Rust, you would probably use assert_eq!() in conjunction with Err().\nBut in Zig, we use the expectError() function, from the std.testing module. With this function, you can test if a specific function call returns the exact type of error that you expect it to return. To use this function, you first write try expectError(). Then, on the first argument, you provide the type of error that you are expecting from the function call. Then, on the second argument, you write the function call you expect to fail.\nThe code example below demonstrates such type of unit test in Zig. Notice that, inside the function alloc_error() we are allocating 100 bytes of memory, or, an array of 100 elements, for the object ibuffer. However, in the test block, we are using the FixedBufferAllocator() allocator object, which is limited to 10 bytes of space, because the object buffer, which we provided to the allocator object, have only 10 bytes of space.\nThat is why, the alloc_error() function raises an OutOfMemory error on this case. Because this function is trying to allocate more space than the allocator object allows. So, in essence, we are testing for a specific type of error, which is OutOfMemory. If the alloc_error() function returns any other type of error, then, the expectError() function would make the entire test fail.\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expectError = std.testing.expectError;\nfn alloc_error(allocator: Allocator) !void {\n    var ibuffer = try allocator.alloc(u8, 100);\n    defer allocator.free(ibuffer);\n    ibuffer[0] = 2;\n}\n\ntest \"testing error\" {\n    var buffer: [10]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    try expectError(error.OutOfMemory, alloc_error(allocator));\n}\n\n1/1 oom.test.testing error... OK\nAll 1 tests passed.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#testing-simple-equalities",
    "href": "Chapters/03-unittests.html#testing-simple-equalities",
    "title": "7¬† Unit tests in Zig",
    "section": "7.5 Testing simple equalities",
    "text": "7.5 Testing simple equalities\nIn Zig, there are some different ways you can test for an equality. You already saw that we can use expect() with the logical operator == to essentially reproduce an equality test. But we also have some helper functions that you should know about, specially expectEqual(), expectEqualSlices() and expectEqualStrings().\nThe expectEqual() function, as the name suggests, is a classic test equality function. It receives two objects as input. The first object is the value that you expect to be in the second object. While second object is the object you have, or, the object that your application produced as result. So, with expectEqual() you are essentially testing if the values stored inside the two provided objects are equal or not.\nYou can see in the example below that, the test performed by expectEqual() failed. Because the objects v1 and v2 contain different values in them.\n\nconst std = @import(\"std\");\ntest \"values are equal?\" {\n    const v1 = 15;\n    const v2 = 18;\n    try std.testing.expectEqual(v1, v2);\n}\n\n1/1 ve.test.values are equal?...\n    expected 15, found 18\n    FAIL (TestExpectedEqual)\nve.zig:5:5: test.values are equal? (test)\n    try std.testing.expectEqual(v1, v2);\n    ^\n0 passed; 0 skipped; 1 failed.\nAlthough useful, the expectEqual() function does not work with arrays. For testing if two arrays are equal, you should use the expectEqualSlices() function instead. This function have three arguments. First, you provide the data type contained in both arrays that you are trying to compare. While the second and third arguments corresponds to the array objects that you want to compare.\nIn the example below, we are using this function to test if two array objects (array1 and array2) are equal or not. Since they are in fact equal, the unit test passed with no errors.\n\nconst std = @import(\"std\");\ntest \"arrays are equal?\" {\n    const array1 = [3]u32{1, 2, 3};\n    const array2 = [3]u32{1, 2, 3};\n    try std.testing.expectEqualSlices(\n        u32, &array1, &array2\n    );\n}\n\n1/1 oom.test.arrays are equal?... OK\nAll 1 tests passed.\nAt last, you might also want to use the expectEqualStrings() function. As the name suggests, you can use this function to test if two strings are equal or not. Just provide the two string objects that you want to compare, as inputs to the functions.\nIf the function finds any existing difference between the two strings, then, the function will raise an error, and also, print an error message that shows the exact difference between the two string objects provided, as the example below demonstrates:\n\nconst std = @import(\"std\");\ntest \"strings are equal?\" {\n    const str1 = \"hello, world!\";\n    const str2 = \"Hello, world!\";\n    try std.testing.expectEqualStrings(\n        str1, str2\n    );\n}\n\n1/1 t.test.strings are equal?... \n====== expected this output: =========\nhello, world!‚êÉ\n======== instead found this: =========\nHello, world!‚êÉ\n======================================\nFirst difference occurs on line 1:\nexpected:\nhello, world!\n^ ('\\x68')\nfound:\nHello, world!\n^ ('\\x48')",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/03-unittests.html#footnotes",
    "href": "Chapters/03-unittests.html#footnotes",
    "title": "7¬† Unit tests in Zig",
    "section": "",
    "text": "https://github.com/ziglang/zig/tree/master/lib/std‚Ü©Ô∏é\nhttps://github.com/ziglang/zig/blob/master/lib/std/array_list.zig‚Ü©Ô∏é\nhttps://github.com/catchorg/Catch2/tree/devel‚Ü©Ô∏é\nhttps://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Unit tests in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html",
    "href": "Chapters/07-build-system.html",
    "title": "8¬† Build System in Zig",
    "section": "",
    "text": "8.1 How source code is built?\nWe already talked about the challenges of building source code in low-level languages at Section 1.2.1. As we described at that section, programmers invented Build Systems to surpass these challenges on the building processes of low-level languages.\nLow-level languages uses a compiler to compile (or to build) your source code into binary instructions. In C and C++, we normally use compilers like gcc, g++ or clang to compile our C and C++ source code into these instructions. Every language have it‚Äôs own compiler, and this is no different in Zig.\nIn Zig, we have the zig compiler to compile our Zig source code into binary instructions that can be executed by our computer. In Zig, the compilation (or the build) process involves the following components:\nThese are the things that you need to connect together in order to build your source code in Zig. In C and C++, you would have an extra component, which is the header files of the libraries that you are using. But header files do not exist in Zig, so, you only need to care about them if you are linking your Zig source code with a C library. If that is not your case, you can forget about it.\nYour build process is usually organized in a build script. In Zig, we normally write this build script into a Zig module in the root directory of our project, named as build.zig. You write this build script, then, when you run it, your project get‚Äôs built into binary files that you can use and distribute to your users.\nThis build script is normally organized around target objects. A target is simply something to be built, or, in other words, it‚Äôs something that you want the zig compiler to build for you. This concept of ‚Äútargets‚Äù is present in most Build Systems, specially in CMake3.\nThere are four types of target objects that you can build in Zig, which are:\nWe are going to talk more about these target objects at Section 8.3.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#how-source-code-is-built",
    "href": "Chapters/07-build-system.html#how-source-code-is-built",
    "title": "8¬† Build System in Zig",
    "section": "",
    "text": "The Zig modules that contains your source code;\nLibrary files (either a dynamic library or a static library);\nCompiler flags that tailors the build process to your needs.\n\n\n\n\n\n\nAn executable, which is simply a binary executable file (e.g.¬†a .exe file on Windows).\nA shared library, which is simply a binary library file (e.g.¬†a .so file in Linux or a .dll file on Windows).\nA static library, which is simply a binary library file (e.g.¬†a .a file in Linux or a .lib file on Windows).\nAn unit tests executable, which is an executable file that executes only unit tests.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-build-fun",
    "href": "Chapters/07-build-system.html#sec-build-fun",
    "title": "8¬† Build System in Zig",
    "section": "8.2 The build() function",
    "text": "8.2 The build() function\nA build script in Zig always contains a public (and top-level) build() function declared. It is like the main() function on the main Zig module of your project, that we discussed at Section 1.2.3. But instead of creating the entrypoint to your code, this build() function is the entrypoint to the build process.\nThis build() function should accept a pointer to a Build object as input, and it should use this ‚Äúbuild object‚Äù to perform the necessary steps to build your project. The return type of this function is always void, and this Build struct comes directly from the Zig Standard Library (std.Build). So, you can access this struct by just importing the Zig Standard Library into your build.zig module.\nJust as a very simple example, here you can see the source code necessary to build an executable file from the hello.zig Zig module.\n\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_source_file = b.path(\"hello.zig\"),\n        .target = b.host,\n    });\n    b.installArtifact(exe);\n}\n\nYou can define and use other functions and objects in this build script. You can also import other Zig modules as you would normally do in any other module of your project. The only real requirement for this build script, is to have a public and top-level build() function defined, that accepts a pointer to a Build struct as input.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-targets",
    "href": "Chapters/07-build-system.html#sec-targets",
    "title": "8¬† Build System in Zig",
    "section": "8.3 Target objects",
    "text": "8.3 Target objects\nAs we described over the previous sections, a build script is composed around target objects. Each target object is normally a binary file (or an output) that you want to get from the build process. You can list multiple target objects in your build script, so that the build process generates multiple binary files for you at once.\nFor example, you may be a developer working in a cross-platform application, and, because this application is cross-platform, you probably need to realease binary files of your software for each OS supported by your application to your end users. You can define a target object in your build script for each OS (Windows, Linux, etc.) where you want to publish your software. This will make the zig compiler to build your project to multiple target OS‚Äôs at once. The Zig Build System official documentation have a great code example that demonstrates this strategy4.\nA target object is created by the following methods of the Build struct that we introduced at Section 8.2:\n\naddExecutable() creates an executable file;\naddSharedLibrary() creates a shared library file;\naddStaticLibrary() creates a static library file;\naddTest() creates an executable file that executes unit tests.\n\nThese functions are methods from the Build struct that you receive as input of the build() function. All of them, create as output a Compile object, which represents a target object to be compiled by the zig compiler. All of these functions accept a similar struct literal as input. This struct literal defines three essential specs about this target object that you are building: name, target and root_source_file.\nWe already saw these three options being used on the previous example, where we used the addExecutable() method to create an executable target object. This example is reproduced below. Notice the use of the path() method from the Build struct, to define a path in the root_source_file option.\n\nexe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n\nThe name option specificy the name that you want to give to the binary file defined by this target object. So, in this example, we are building an executable file named hello. Is traditional to set this name option to the name of your project.\nFurthermore, the target option specify the target computer architecture (or the target operational system) of this binary file. For example, if you want this target object to run on a Windows machine that uses a x86_64 architecture, you can set this target option to x86_64-windows-gnu for example. This will make the zig compiler to compile the project to run on a x86_64 Windows machine. You can see the full list of architectures and OS‚Äôs that the zig compiler supports by running the zig targets command in the terminal.\nNow, if you are building the project to run on the current machine that you are using to run this build script, you can set this target option to the host method of the Build object, like we did in the example above. This host method identifies the current machine where you are currently running the zig compiler.\nAt last, the root_source_file option specifies the root Zig module of your project. That is the Zig module that contains the entrypoint to your application (i.e.¬†the main() function), or, the main API of your library. This also means that, all the Zig modules that compose your project are automatically discovered from the import statements that you have inside this ‚Äúroot source file‚Äù. The zig compiler can detect when a Zig module depends on the other through the import statements, and, as a result, it can discover the entire map of Zig modules used in your project.\nThis is handy, and it is different from what happens in other build systems. In CMake for example, you have to explicitly list the paths to all source files that you want to include in your build process. This is probably a symptom of the ‚Äúlack of conditional compilation‚Äù in C and C++ compilers. Since they lack this feature, you have to explicitly choose which source files are sent to the C/C++ compiler, since not every C/C++ code is portable or supported in every operational system, and, therefore, would cause a compilation error in the C/C++ compiler.\nNow, one important detail about the build process is that, you have to explicitly install the target objects that you create in your build script, by using the installArtifact() method of the Build struct.\nEverytime you invoke the build process of your project, by calling the build command of the zig compiler, a new directory named zig-out is created in the root directory of your project. This new directory contains the output of the build process, that is, the binary files built from your source code.\nWhat the installArtifact() method do is install (or copy) the built target objects that you defined to this zig-out directory. This means that, if you do not install the target objects you define in your build script, these target objects are essentially discarded at the end of the build process.\nFor example, you might be building a project that uses a third party library that is built together with the project. So, when you build your project, you would need first, to build the third party library, and then, you link it with the source code of your project. So, in this case, we have two binary files that are generated in the build process (the executable file of your project, and the third party library). But only one is of interest, which is the executable file of our project. We can discard the binary file of the third party library, by simply not installing it into this zig-out directory.\nSo, is easy to use this installArtifact() method. Just remember to apply it to every target object that you want to save it into the zig-out directory, like in the example below:\n\nexe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n});\n\nb.installArtifact(exe);",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#setting-the-build-mode",
    "href": "Chapters/07-build-system.html#setting-the-build-mode",
    "title": "8¬† Build System in Zig",
    "section": "8.4 Setting the build mode",
    "text": "8.4 Setting the build mode\nWe talked about the three essential options that are set when you create a new target object. But there is also a fourth option that you can use to set the build mode of this target object, which is the optimize option. This option is called this way, because the build modes in Zig are treated more of an ‚Äúoptimization vs safety‚Äù problem. So optmization plays an important role here. Don‚Äôt worry, I‚Äôm going back to this question very soon.\nIn Zig, we have the four build modes listed below. Each one of these build modes offer different advantages and characteristics. As we described at Section 4.2.1, the zig compiler uses the Debug build mode by default, when you don‚Äôt explicitly choose a build mode.\n\nDebug, mode that produces and includes debugging information in the output of the build process (i.e.¬†the binary file defined by the target object);\nReleaseSmall, mode that tries to produce a binary file that is small in size;\nReleaseFast, mode that tries to optimize your code, in order to produce a binary file that is as fast as possible;\nReleaseSafe, mode that tries to make your code as safe as possible, by including safeguards when possible.\n\nSo, when you build your project, you can set the build mode of your target object to ReleaseFast for example, which will tell the zig compiler to apply important optimizations in your code. This creates a binary file that simply runs faster on most contexts, because it contains a more optimized version of your code. However, as a result, we normally loose some security funcionalities in our code. Because some safety checks are removed from the final binary file, which makes your code run faster, but in a less safe manner.\nThis choice depends on your current priorities. If you are building a cryptography or banking system, you might prefer to prioritize safety in your code, so, you would choose the ReleaseSafe build mode, which is a little slower to run, but much more secure, because it includes all possible runtime safety checks in the binary file built in the build process. In the other hand, if you are writing a game for example, you might prefer to prioritize performance over safety, by using the ReleaseFast build mode, so that your users can experience faster frame rates in your game.\nIn the example below, we are creating the same target object that we used on previous examples. But this time, we are specifying the build mode of this target object to use the ReleaseSafe mode.\n\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n    .optimize = .ReleaseSafe\n});\nb.installArtifact(exe);",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#setting-the-version-of-your-build",
    "href": "Chapters/07-build-system.html#setting-the-version-of-your-build",
    "title": "8¬† Build System in Zig",
    "section": "8.5 Setting the version of your build",
    "text": "8.5 Setting the version of your build\nEverytime you build a target object in your build script, you can assign a version number to this specific build, following a semantic versioning framework. You can find more about semantic versioning by visiting the Semantic Versioning website5. Anyway, in Zig, you can specify the version of your build, by providing a SemanticVersion struct to the version option, like in the example below:\n\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"hello.zig\"),\n    .target = b.host,\n    .version = .{\n        .major = 2, .minor = 9, .patch = 7\n    }\n});\nb.installArtifact(exe);",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#sec-detect-os",
    "href": "Chapters/07-build-system.html#sec-detect-os",
    "title": "8¬† Build System in Zig",
    "section": "8.6 Detecting the OS in your build script",
    "text": "8.6 Detecting the OS in your build script\nIs very commom in Build Systems to use different options, or, to include different modules, or, to link against different libraries depending on the Operational System (OS) that you are targeting in the build process.\nIn Zig, you can detect the target OS of the build process, by looking at the os.tag inside the builtin module from the Zig library. In the example below, we are using an if statement to run some arbitrary code when the target of the build process is a Windows system.\n\nconst builtin = @import(\"builtin\");\nif (builtin.target.os.tag == .windows) {\n    // Code that runs only when the target of\n    // the compilation process is Windows.\n}",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#adding-a-run-step-to-your-build-process",
    "href": "Chapters/07-build-system.html#adding-a-run-step-to-your-build-process",
    "title": "8¬† Build System in Zig",
    "section": "8.7 Adding a run step to your build process",
    "text": "8.7 Adding a run step to your build process\nOne thing that is neat in Rust is that you can compile and run your source code with one single command (cargo run) from the Rust compiler. We saw at Section 1.2.5 how can we perform a similar job in Zig, by building and running our Zig source code through the run command from the zig compiler.\nBut how can we, at the same time, build and run the binary file specified by a target object in our build script? The answer is by including a ‚Äúrun artifact‚Äù in our build script. A run artifact is created through the addRunArtifact() method from the Build struct. We simply provide as input to this function the target object that describes the binary file that we want to execute, and the function creates as output, a run artifact capable of executing this binary file.\nIn the example below, we are defining an executable binary file named hello, and we use this addRunArtifact() method to create a run artifact that will execute this hello executable file.\n\nconst exe = b.addExecutable(.{\n    .name = \"hello\",\n    .root_source_file = b.path(\"src/hello.zig\"),\n    .target = b.host\n});\nb.installArtifact(exe);\nconst run_arti = b.addRunArtifact(exe);\n\nNow that we created the run artifact, we need to include it in the build process. We do that by declaring a new step in our build script to call this artifact, through the step() method of the Build struct. We can give any name we want to this step, but, for our context here, I‚Äôm going to name this step as ‚Äúrun‚Äù. Also, I give it a brief description to this step (‚ÄúRun the project‚Äù).\n\nconst run_step = b.step(\n    \"run\", \"Run the project\"\n);\n\nNow that we declared this ‚Äúrun step‚Äù we need to tell Zig that this ‚Äúrun step‚Äù depends on the run artifact. In other words, a run artifact always depends on a ‚Äústep‚Äù to effectively be executed. By creating this dependency we finally stablish the necessary commands to build and run the executable file from the build script.\nWe establish a dependency between the run step and the run artifact by using the dependsOn() method from the run step. So, we first create the run step, and then, we link it with the run artifact, by using this dependsOn() method from the run step.\n\nrun_step.dependOn(&run_arti.step);\n\nThe entire source code of this specific build script that we wrote, piece by piece, in this section, is available in the build_and_run.zig module. You can see this module by visiting the official repository of this book 6.\nWhen you declare a new step in your build script, this step becomes available through the build command in the zig compiler. You can actually see this step by running zig build --help in the terminal, like in the example below, where we can see that this new ‚Äúrun‚Äù step that we declared in the build script appeared in the output.\nzig build --help\nSteps:\n  ...\n  run   Run the project\n  ...\nNow, everything that we need to is to call this ‚Äúrun‚Äù step that we created in our build script. We call it by using the name that we gave to this step after the build command from the zig compiler. This will cause the compiler to build our executable file and execute it at the same time.\nzig build run",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#build-unit-tests-in-your-project",
    "href": "Chapters/07-build-system.html#build-unit-tests-in-your-project",
    "title": "8¬† Build System in Zig",
    "section": "8.8 Build unit tests in your project",
    "text": "8.8 Build unit tests in your project\nWe talk at length about writing unit tests in Zig, and we also talk about how to execute these unit tests through the test command of the zig compiler at Chapter 7. However, as we did with the run command on the previous section, we also might want to include some commands in our build script to also build and execute the unit tests in our project.\nSo, once again, we are going to discuss how a specific built-in command from the zig compiler, (in this case, the test command) can be used in a build script in Zig. This means that, we can include a step in our build script to build and run all unit tests in our project at once.\nHere is where a ‚Äútest target object‚Äù comes into play. As was described at Section 8.3, we can create a test target object by using the addTest() method of the Build struct. So the first thing that we need to do is to declare a test target object in our build script.\n\nconst test_exe = b.addTest(.{\n    .name = \"unit_tests\",\n    .root_source_file = b.path(\"src/main.zig\"),\n    .target = b.host,\n});\nb.installArtifact(test_exe);\n\nA test target object essentially filter all test blocks in all Zig modules across your project, and builds only the source code present inside these test blocks in your project. As a result, this target object creates an executable file that contains only the source code present in all of these test blocks (i.e.¬†the unit tests) in your project.\nPerfect! Now that we declared this test target object, an executable file named unit_tests is built by the zig compiler when we trigger the build script with the build command. After the build process is finished, we can simply execute this unit_tests executable in the terminal.\nHowever, if you remember the previous section, we already learned how can we create a run step in our build script, to execute an executable file built by the build script.\nSo, we could simply add a run step in our build script to run these unit tests from a single command in the zig compiler, to make our lifes easier. In the example below, we demonstrate the commands to register a new build step called ‚Äútests‚Äù in our build script to run these unit tests.\n\nconst run_arti = b.addRunArtifact(test_exe);\nconst run_step = b.step(\"tests\", \"Run unit tests\");\nrun_step.dependOn(&run_arti.step);\n\nNow that we registered this new build step, we can trigger it by calling the command below in the terminal. You can also checkout the complete source code for this specific build script at the build_tests.zig module at the official repository of this book 7.\nzig build tests",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#tailoring-your-build-process-with-user-provided-options",
    "href": "Chapters/07-build-system.html#tailoring-your-build-process-with-user-provided-options",
    "title": "8¬† Build System in Zig",
    "section": "8.9 Tailoring your build process with user-provided options",
    "text": "8.9 Tailoring your build process with user-provided options\nSometimes, you want to make a build script that is customizable by the user of your project. You can do that by creating user-provided options in your build script. In Zig, we create these options using the option() method from the Build struct.\nWith this method, we create a ‚Äúbuild option‚Äù which can be passed to the build.zig script at the command line. The user have the power of setting this option at the build command from the zig compiler. In other words, each build option that we create becomes a new command line argument accessible in the build command of the compiler.\nThese ‚Äúuser-provided options‚Äù are set by using the prefix -D in the command line. For example, if we declare an option named use_zlib, that receives a boolean value which indicates if we should link our source code to zlib or not, we can set the value of this option in the command line with -Duse_zlib. The code example below demonstrates this idea:\n\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const use_zlib = b.option(\n        bool,\n        \"use_zlib\",\n        \"Should link to zlib?\"\n    ) orelse false;\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_source_file = b.path(\"example.zig\"),\n        .target = b.host,\n    });\n    if (use_zlib) {\n        exe.linkSystemLibrary(\"zlib\");\n    }\n    b.installArtifact(exe);\n}\n\nYou can set this use_zlib option at the command line when you are invoking the build command from the zig compiler. In the example below, we set this option to false, which means that the build script will not link our binary executable to the zlib library.\nzig build -Duse_zlib=false",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#linking-to-external-libraries",
    "href": "Chapters/07-build-system.html#linking-to-external-libraries",
    "title": "8¬† Build System in Zig",
    "section": "8.10 Linking to external libraries",
    "text": "8.10 Linking to external libraries\nOne essential part of every build process is the linking stage. This stage is responsible for combining the multiple object files that represent your code, into a single executable file. It also links this executable file to an external libraries, if you use any in your code.\nIn Zig, we have two notions of a ‚Äúlibrary‚Äù, which are: 1) a system‚Äôs library; 2) a local library. A system‚Äôs library is just a library that already is installed in your system. While a local library is a library that belongs to the current project. Is a library that is present in your project directory, and that you are building together with your project source code.\nThe basic difference between the two, is that a system‚Äôs library is already built and installed in your system, supposedly, and all you need to do is to link your source code to this library to start using it. We do that by using the linkSystemLibrary() method from a Compile object. This method accepts the name of the library in a string as input. Remember from Section 8.3 that a Compile object is a target object that you declare in your build script.\nWhen you link a particular target object with a system‚Äôs library, the zig compiler will use pkg-config to find where in your system are the binary files and also the header files of this library that you requested for. When it finds these files, the linker present in the zig compiler will link your object files with the files of this library to produce a single executable file.\nIn the example below, we are creating an executable file named image_filter, and, we are linking this executable file to the C Standard Library with the method linkLibC(), but we also are linking this executable file to the C library libpng that is currently installed in my system.\n\nconst std = @import(\"std\");\npub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"image_filter\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.linkLibC();\n    exe.linkSystemLibrary(\"png\");\n    b.installArtifact(exe);\n}\n\nIf you are linking with a C library in your project, is generally a good idea to also link your code with the C Standard Library. Because is very likely that this C library uses some functionality of the C Standard Library at some point. The same goes to C++ libraries. So, if you are linking with C++ libraries, is a good idea to link your project with the C++ Standard Library using the linkLibCpp() method.\nOn the order side, when you want to link with a local library, you should use the linkLibrary() method of a Compile object. This method expects to receive another Compile object as input. That is, another target object defined in your build script, using either the addStaticLibrary() or addSharedLibrary() methods which defines a library to be built.\nBecause as we discussed earlier, a local library is a library that is local to your project, and that is being built together with your project. So, you need to create a target object in your build script to build this local library. Then, you link the target objects of interest in your project, with this target object that identifies this local library.\nTake a look at this example extracted from the build script of the libxev library8. You can see in this snippet that we are declaring a shared library file, from the c_api.zig module. Then later in the build script, we declare an executable file named ‚Äúdynamic-binding-test‚Äù, which links to this shared library that we defined earlier in the script.\n\nconst optimize = b.standardOptimizeOption(.{});\nconst target = b.standardTargetOptions(.{});\n\nconst dynamic_lib = b.addSharedLibrary(.{\n    .name = dynamic_lib_name,\n    .root_source_file = b.path(\"src/c_api.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\nb.installArtifact(dynamic_lib);\n// ... more lines in the script\nconst dynamic_binding_test = b.addExecutable(.{\n    .name = \"dynamic-binding-test\",\n    .target = target,\n    .optimize = optimize,\n});\ndynamic_binding_test.linkLibrary(dynamic_lib);",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#building-c-code",
    "href": "Chapters/07-build-system.html#building-c-code",
    "title": "8¬† Build System in Zig",
    "section": "8.11 Building C code",
    "text": "8.11 Building C code\nThe zig compiler comes with a C compiler embedded in it. In other words, you can use the zig compiler to build C projects. This C compiler is available through the cc command of the zig compiler.\nAs an example, let‚Äôs use the famous FreeType library9. FreeType is one of the most widely used pieces of software in the world. It is a C library designed to produce high-quality fonts. But it is also heavily used in the industry to natively render text and fonts in the screen of your computer.\nIn this section, we are going to write a build script, piece by piece, that is capable of building the FreeType project from source. You can find the source code of this build script on the freetype-zig repository10 available at GitHub.\nAfter you download the source code of FreeType from the official website11, you can start writing the build.zig module. We begin by defining the target object that defines the binary file that we want to compile.\nAs an example, I will build the project as a static library file using the addStaticLibrary() method to create the target object. Also, since FreeType is a C library, I will also link the library against libc through the linkLibC() method, to garantee that any use of the C Standard Library is covered in the compilation process.\n\nconst target = b.standardTargetOptions(.{});\nconst opti = b.standardOptimizeOption(.{});\nconst lib = b.addStaticLibrary(.{\n    .name = \"freetype\",\n    .optimize = opti,\n    .target = target,\n});\nlib.linkLibC();\n\n\n8.11.1 Creating C compiler flags\nCompiler flags are also known as ‚Äúcompiler options‚Äù by many programmers, or also, as ‚Äúcommand options‚Äù in the GCC official documentation. It‚Äôs fair to also call them as the ‚Äúcommand-line arguments‚Äù of the C compiler. In general, we use compiler flags to turn on (or turn off) some features from the compiler, or to tweak the compilation process to fit the needs of our project.\nIn build scripts written in Zig, we normally list the C compiler flags to be used in the compilation process in a simple array, like in the example below.\n\nconst c_flags = [_][]const u8{\n    \"-Wall\",\n    \"-Wextra\",\n    \"-Werror\",\n};\n\nIn theory, there is nothing stopping you from using this array to add ‚Äúinclude paths‚Äù (with the -I flag) or ‚Äúlibrary paths‚Äù (with the -L flag) to the compilation process. But there are formal ways in Zig to add these types of paths in the compilation process. Both are discussed at Section 8.11.5 and Section 8.11.4.\nAnyway, in Zig, we add C flags to the build process together with the C files that we want to compile, using the addCSourceFile() and addCSourceFiles() methods. In the example above, we have just declared the C flags that we want to use. But we haven‚Äôt added them to the build process yet. To do that, we also need to list the C files to be compiled.\n\n\n8.11.2 Listing your C files\nThe C files that contains ‚Äúcross-platform‚Äù source code are listed in the c_source_files object below. These are the C files that are included by default in every platform supported by the FreeType library. Now, since the amount of C files in the FreeType library is big, I have omitted the rest of the files in the code example below, for brevity purposes.\n\nconst c_source_files = [_][]const u8{\n    \"src/autofit/autofit.c\",\n    \"src/base/ftbase.c\",\n    // ... and many other C files.\n};\n\nNow, in addition to ‚Äúcross-platform‚Äù source code, we also have some C files in the FreeType project that are platform-specific, meaning that, they contain source code that can obly be compiled in specific platforms, and, as a result, they are only included in the build process on these specific target platforms. The objects that list these C files are exposed in the code example below.\n\nconst windows_c_source_files = [_][]const u8{\n    \"builds/windows/ftdebug.c\",\n    \"builds/windows/ftsystem.c\"\n};\nconst linux_c_source_files = [_][]const u8{\n    \"src/base/ftsystem.c\",\n    \"src/base/ftdebug.c\"\n};\n\nNow that we declared both the files that we want to include and the C compiler flags to be used, we can add them to the target object that describes the FreeType library, by using the addCSourceFile() and addCSourceFiles() methods.\nBoth of these functions are methods from a Compile object (i.e.¬†a target object). The addCSourceFile() method is capable of adding a single C file to the target object, while the addCSourceFiles() method is used to add multiple C files in a single command. You might prefer to use addCSourceFile() when you need to use different compiler flags on specific C files in your project. But, if you can use the same compiler flags across all C files, then, you will probably find addCSourceFiles() a better choice.\nNotice that we are using the addCSourceFiles() method in the example below, to add both the C files and the C compiler flags. Also notice that we are using the os.tag that we learned about at Section 8.6, to add the platform-specific C files.\n\nconst builtin = @import(\"builtin\");\nlib.addCSourceFiles(\n    &c_source_files, &c_flags\n);\n\nswitch (builtin.target.os.tag) {\n    .windows =&gt; {\n        lib.addCSourceFiles(\n            &windows_c_source_files,\n            &c_flags\n        );\n    },\n    .linux =&gt; {\n        lib.addCSourceFiles(\n            &linux_c_source_files,\n            &c_flags\n        );\n    },\n    else =&gt; {},\n}\n\n\n\n8.11.3 Defining C Macros\nC Macros are an essential part of the C programming language, and they are commonly defined through the -D flag from a C compiler. In Zig, you can define a C Macro to be used in your build process by using the defineCMacro() method from the target object that defines the binary file that you are building.\nIn the example below, we are using the lib object that we defined on the previous sections to define some C Macros used by FreeType in the compilation process. These C Macros specify if FreeType should (or should not) include functionalities from different external libraries.\n\nlib.defineCMacro(\"FT_DISABLE_ZLIB\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_PNG\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_HARFBUZZ\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_BZIP2\", \"TRUE\");\nlib.defineCMacro(\"FT_DISABLE_BROTLI\", \"TRUE\");\nlib.defineCMacro(\"FT2_BUILD_LIBRARY\", \"TRUE\");\n\n\n\n8.11.4 Adding library paths\nLibrary paths are paths in your computer where the C compiler will look (or search) for library files to link against your source code. In other words, when you use a library in your C source code, and you ask the C compiler to link your source code against this library, the C compiler will search for the binary files of this library across the paths listed in this ‚Äúlibrary paths‚Äù set.\nThese paths are platform specific, and, by default, the C compiler starts by looking at a pre-defined set of places in your computer. But you can add more paths (or more places) to this list. For example, you may have a library installed in a non-conventional place of your computer, and you can make the C compiler ‚Äúsee‚Äù this ‚Äúnon-conventional place‚Äù by adding this path to this list of pre-defined paths.\nIn Zig, you can add more paths to this set by using the addLibraryPath() method from your target object. First, you defined a LazyPath object, containing the path you want to add, then, you provide this object as input to the addLibraryPath() method, like in the example below:\n\nconst lib_path: std.Build.LazyPath = .{\n    .cwd_relative = \"/usr/local/lib/\"\n};\nlib.addLibraryPath(lib_path);\n\n\n\n8.11.5 Adding include paths\nThe preprocessor search path is a popular concept from the C community, but it is also known by many C programmers as ‚Äúinclude paths‚Äù, because the paths in this ‚Äúsearch path‚Äù relate to the #include statements found in the C files.\nInclude paths are similar to library paths. They are a set of pre-defined places in your computer where the C compiler will look for files during the compilation process. But instead of looking for library files, the include paths are places where the compiler looks for header files included in your C source code. This is why many C programmers prefer to call these paths as the ‚Äúpreprocessor search path‚Äù. Because header files are processed during the preprocessor stage of the compilation process.\nSo, every header file that you include in your C source code, through a #include statements needs to be found somewhere, and the C compiler will search for this header file across the paths listed in this ‚Äúinclude paths‚Äù set. Include paths are added to the compilation process through the -I flag.\nIn Zig, you can add new paths to this pre-defined set of paths, by using the addIncludePath() method from your target object. This method also accepts a LazyPath object as input.\n\nconst inc_path: std.Build.LazyPath = .{\n    .path = \"./include\"\n};\nlib.addIncludePath(inc_path);",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "Chapters/07-build-system.html#footnotes",
    "href": "Chapters/07-build-system.html#footnotes",
    "title": "8¬† Build System in Zig",
    "section": "",
    "text": "https://ziglang.org/learn/build-system/#user-provided-options‚Ü©Ô∏é\nhttps://zig.news/xq/zig-build-explained-part-1-59lf‚Ü©Ô∏é\nhttps://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html‚Ü©Ô∏é\nhttps://ziglang.org/learn/build-system/#handy-examples‚Ü©Ô∏é\nhttps://semver.org/‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig‚Ü©Ô∏é\nhttps://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig‚Ü©Ô∏é\nhttps://github.com/mitchellh/libxev/tree/main‚Ü©Ô∏é\nhttps://freetype.org/‚Ü©Ô∏é\nhttps://github.com/pedropark99/freetype-zig/tree/main‚Ü©Ô∏é\nhttps://freetype.org/‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Build System in Zig</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chen, Jenny, and Ruohao Guo. 2022. ‚ÄúStack and Heap Memory.‚Äù\nIntroduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nMeehan, Eric. 2021. ‚ÄúCreating a Web Server from Scratch in\nc.‚Äù Youtube. https://www.youtube.com/watch?v=gk6NL1pZi1M&ab_channel=EricOMeehan.\n\n\nMicrosoft. 2021. ‚ÄúBitwise AND Operator: &.‚Äù Microsoft\nLearn. https://learn.microsoft.com/en-us/cpp/cpp/bitwise-and-operator-amp?view=msvc-170.\n\n\nSobeston. 2024. ‚ÄúZig Guide.‚Äù https://zig.guide/.\n\n\nWeerasiri, Nipun Chamikara. 2023. ‚ÄúA Simple Web Server Written in\nc.‚Äù Medium. https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6.\n\n\nWikipedia. 2024. ‚ÄúPort (Computer Networking).‚Äù Wikipedia.\nhttps://en.wikipedia.org/wiki/Port_(computer_networking).\n\n\nYu, Jeffrey. 2023. ‚ÄúHow i Built a Simple HTTP Server from Scratch\nUsing c.‚Äù DEV Community. https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739.\n\n\nZig Software Foundation. 2024. ‚ÄúLanguage Reference.‚Äù Zig\nSoftware Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "References"
    ]
  }
]